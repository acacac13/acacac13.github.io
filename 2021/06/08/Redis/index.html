

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.png">
  <link rel="icon" href="/img/icon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="It&#39;s fine">
  <meta name="author" content="AoCan">
  <meta name="keywords" content="">
  
  <title>Redis学习 - Blog Of AC</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/a11y-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"acacac13.top","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"RxykbovtXvEzAt8OUVAS1CqX-gzGzoHsz","app_key":"xjP4U0FLblVtlDA1XXAP2906","server_url":"https://rxykbovt.lc-cn-n1-shared.com"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>小朋友你回家吃饭吗</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/../picture/20210814145508.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Redis学习">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-06-08 20:11" pubdate>
        June 8, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      16.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      199
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis学习</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：June 20, 2022 pm
                
              </p>
            
            <div class="markdown-body">
              <h1 id="NoSQL概述"><a href="#NoSQL概述" class="headerlink" title="NoSQL概述"></a>NoSQL概述</h1><h2 id="为什么要用NoSQL"><a href="#为什么要用NoSQL" class="headerlink" title="为什么要用NoSQL"></a>为什么要用NoSQL</h2><p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等爆发式的增长</p>
<p>这时候就需要使用NoSQL数据库</p>
<blockquote>
<p>1、单机MySQL的年代</p>
</blockquote>
<p><img src="/2021/06/08/Redis/20210425101847.png" srcset="/img/loading.gif" lazyload alt="image-20210425101847275"></p>
<p>90年代，一个基本的网站访问量一般不会太大，单个数据库完全足够，那个时候，更多的是使用静态网页html，服务器没有太大压力</p>
<p>瓶颈</p>
<p>1、数据量如果太大，一个机器放不下</p>
<p>2、数据的索引（B + Tree），一个机器内存放不下</p>
<p>3、访问量（读写混合），一个服务器承受不了</p>
<p>出现以上情况就需要晋级</p>
<blockquote>
<p>2、Memcached（缓存）+ MySQL + 垂直拆分</p>
</blockquote>
<p>网站80%的情况都是在读，每次查询数据库十分麻烦，因此使用缓存来保证效率</p>
<p>发展过程：优化数据结构和索引 —&gt; 文件缓存（IO）—&gt; Memcached</p>
<p><img src="/2021/06/08/Redis/20210425101916.png" srcset="/img/loading.gif" lazyload alt="image-20210425101916307"></p>
<h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h2><blockquote>
<p>NoSQL</p>
</blockquote>
<p>NoSQL = Not Only SQL （不仅仅是SQL）</p>
<p>关系型数据库： 表格，行，列（POI）</p>
<p>泛指非关系型数据库，随着web2.0互联网的诞生！ 传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区！ 暴露出很多难以克服的问题，NoSQL在当今大数据的环境下发展十分迅速，Redis是发展最快的，而且是是当下必须要掌握的</p>
<p>很多数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式，不需要多余的操作就可以横向扩展的！Map<String, object>使用键值对来控制！</String,></p>
<blockquote>
<p>NoSQL特点</p>
</blockquote>
<p>解耦！</p>
<p>1、方便扩展（数据之间没有关系，很好扩展）</p>
<p>2、大数据高性能（Redis一秒写8万次，读取11万，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高）</p>
<p>3、数据类型是多样型的（不需要事先设计数据库！随取随用！如果是数据量十分大的表，很多人就无法设计了）</p>
<p>4、传统RDBMS和NoSQL</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">传统的RDBMS<br><span class="hljs-bullet">- </span>结构化组织<br><span class="hljs-bullet">- </span>SQL<br><span class="hljs-bullet">- </span>数据和关系都存在单独的表中 row col<br><span class="hljs-bullet">- </span>操作语言，数据定义语言<br><span class="hljs-bullet">- </span>严格的一致性<br><span class="hljs-bullet">- </span>基础的事务<br><span class="hljs-bullet">- </span>... ... <br></code></pre></div></td></tr></table></figure>
<figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">Nosql<br><span class="hljs-bullet">- </span>不仅仅是数据<br><span class="hljs-bullet">- </span>没有固定的查询语言<br><span class="hljs-bullet">- </span>键值对存储，列存储，文档存储，图形数据库（社交关系）<br><span class="hljs-bullet">- </span>最终一致性<br><span class="hljs-bullet">- </span>CAP定理和BASE<br><span class="hljs-bullet">- </span>高性能，高可用，高可扩展<br><span class="hljs-bullet">- </span>... ... <br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>了解：3V + 3高</p>
</blockquote>
<p>大数据时代的3V：主要是描述问题的</p>
<p>​    1、海量的Volume</p>
<p>​    2、多样的Variety</p>
<p>​    3、实时Velocity</p>
<p>大数据时代的3高：主要是对程序的要求</p>
<p>​    1、高并发</p>
<p>​    2、高可扩（随时水平拆分，机器不够了，可以扩展机器来）</p>
<p>​    3、高性能 （保证用户体验和性能）</p>
<p>真正的实践：NoSQL + RDBMS一起使用</p>
<p>技术没有高低之分，看如何使用！</p>
<h2 id="阿里演进分析"><a href="#阿里演进分析" class="headerlink" title="阿里演进分析"></a>阿里演进分析</h2><p><img src="/2021/06/08/Redis/20210425101948.png" srcset="/img/loading.gif" lazyload alt="image-20210425101948320"></p>
<figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># 1、商品的基本信息</span><br>	名称、价格、商家信息；<br>	关系型数据库姐可以解决了！ MySQL/Oracle（淘宝早年就去IOE了）<br>	淘宝内部的MySQL不是大家用的MySQL<br>	<br><span class="hljs-meta"># 2、商品的描述、评论（文字比较多）</span><br>	文档型数据库中，MongoDB<br>	<br><span class="hljs-meta"># 3、图片</span><br>	分布式文件系统 FastDFS<br>	- 淘宝自己的	TFS<br>	- Google的 GFS<br>	- Hadoop HDFS<br>	- 阿里云的	oss<br>	<br><span class="hljs-meta"># 4、商品的关键字（搜索）</span><br>	- 搜索引擎 solr elasticsearch<br>	- ISearch： 多隆<br>	<br><span class="hljs-meta"># 5、商品热门的波段信息</span><br>	- 内存数据库<br>	- Redis	Tair、Memache<br>	<br><span class="hljs-meta"># 6、商品的交易，外部的支付接口</span><br>	- 三方应用<br></code></pre></div></td></tr></table></figure>
<p>大型互联网应用的问题：</p>
<ul>
<li>数据类型太多了</li>
<li>数据源繁多，经常重构</li>
<li>数据要改造，大面积改造</li>
</ul>
<p>解决问题：</p>
<p><img src="/2021/06/08/Redis/20210425105321.png" srcset="/img/loading.gif" lazyload alt="image-20210425105321106"></p>
<p>以上都是NoSQL的入门概述</p>
<h2 id="NoSQL的四大分类"><a href="#NoSQL的四大分类" class="headerlink" title="NoSQL的四大分类"></a>NoSQL的四大分类</h2><p><strong>KV键值对：</strong></p>
<ul>
<li>新浪：<strong>Redis</strong></li>
<li>美团：Redis + Tair</li>
<li>阿里、百度：Redis + memcache</li>
</ul>
<p><strong>文档型数据库（bson格式和json一样）</strong></p>
<ul>
<li><strong>MongoDB</strong>（一般必须掌握）<ul>
<li>MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档</li>
<li>MongoDB是一个介于关系型数据库和非关系型数据库中间的产品！MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的</li>
</ul>
</li>
<li>ConthDB</li>
</ul>
<p><strong>列存储数据库</strong></p>
<ul>
<li><strong>HBase</strong></li>
<li>分布式文件系统</li>
</ul>
<p><strong>图关系型数据库</strong></p>
<p><img src="/2021/06/08/Redis/20210608200625.png" srcset="/img/loading.gif" lazyload alt="图关系型数据库"></p>
<ul>
<li>他不是存图形，放的是关系，比如：朋友圈社交网络，广告推荐</li>
<li><strong>Neo4j</strong>，InfoGrid</li>
</ul>
<blockquote>
<p>四者对比！</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">Examples举例</th>
<th style="text-align:center">典型应用场景</th>
<th style="text-align:center">数据模型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">键值（key-value）</td>
<td style="text-align:center">Tokyo Cabinet/Tyrant,Redis, Voldemort,Oracle BDB</td>
<td style="text-align:center">内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。[3]</td>
<td style="text-align:center">Key指向value的键值对，通常用hash table来实现[3]</td>
<td>查找速度快</td>
<td>数据无结构化，通常只被当作字符串或者二进制数据</td>
</tr>
<tr>
<td style="text-align:center">列存储数据库</td>
<td style="text-align:center">Cassandra, HBase,Riak</td>
<td style="text-align:center">分布式的文件系统</td>
<td style="text-align:center">以列簇式存储，将同一列数据存在一起</td>
<td>查找速度快，可扩展性强，更容易进行分布式扩展</td>
<td>功能相对局限</td>
</tr>
<tr>
<td style="text-align:center">文档型数据库</td>
<td style="text-align:center">CouchDB,MongoDb</td>
<td style="text-align:center">Web应用(与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容)</td>
<td style="text-align:center">Key-Value对应的键值对Value为结构化数据</td>
<td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要先定义表结构</td>
<td>查询性能不高，而且缺乏统一的查询语法</td>
</tr>
<tr>
<td style="text-align:center">图形(Graph)数据库</td>
<td style="text-align:center">Neo4J, InfoGrid, lnfinite Graph</td>
<td style="text-align:center">社交网络，推荐系统等。专注于构建关系图谱</td>
<td style="text-align:center">图结构</td>
<td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td>
<td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结果后不太好做分布式的集群方案</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Redis是什么？</p>
</blockquote>
<p>Redis（Remote Dictionary Server），即远程字典服务</p>
<p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</p>
<p><img src="/2021/06/08/Redis/20210425115126.png" srcset="/img/loading.gif" lazyload alt="image-20210425115119886"></p>
<p>redis会周期性的把更新的数据写入磁盘或把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步</p>
<p>免费和开源，是当下最热门的NoSQL技术之一，也被称为结构化数据库</p>
<blockquote>
<p>Redis用途</p>
</blockquote>
<p>1、内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）</p>
<p>2、效率高，可以用于高速缓存</p>
<p>3、发布订阅系统</p>
<p>4、地图信息分析</p>
<p>5、计时器、计数器（浏览量）</p>
<p>6、 … …</p>
<blockquote>
<p>特性</p>
</blockquote>
<p>1、多样的数据类型</p>
<p>2、持久化</p>
<p>3、集群</p>
<p>4、事务</p>
<p>… …</p>
<blockquote>
<p>准备</p>
</blockquote>
<p>官网：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
<p><img src="/2021/06/08/Redis/20210425115654.png" srcset="/img/loading.gif" lazyload alt="image-20210425115654201"></p>
<p><strong>Redis推荐都是在Linux服务器上搭建的</strong></p>
<h2 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h2><p>1、下载安装包：<a target="_blank" rel="noopener" href="https://github.com/dmajkic/redis/releases">https://github.com/dmajkic/redis/releases</a></p>
<p>2、下载完毕得到压缩包</p>
<p><img src="/2021/06/08/Redis/20210425120848.png" srcset="/img/loading.gif" lazyload alt="image-20210425120848964"></p>
<p>3、解压到自己电脑上的环境目录下</p>
<p>4、开启Redis，双击运行服务即可</p>
<p><img src="/2021/06/08/Redis/20210425121430.png" srcset="/img/loading.gif" lazyload alt="image-20210425121430781"></p>
<p>5、使用redis客户端来连接redis</p>
<p><img src="/2021/06/08/Redis/20210425121843.png" srcset="/img/loading.gif" lazyload alt="image-20210425121842974"></p>
<p>windows下使用确实简单，但是redis推荐使用Linux开发使用</p>
<p><img src="/2021/06/08/Redis/20210425122145.png" srcset="/img/loading.gif" lazyload alt="image-20210425122145780"></p>
<h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><p>1、下载安装包    <strong>redis-6.2.2.tar.gz</strong></p>
<p>2、解压安装包    程序/opt</p>
<p><img src="/2021/06/08/Redis/20210427095749.png" srcset="/img/loading.gif" lazyload alt="image-20210427095741964"></p>
<p>3、进入解压后的文件可以看到redis的配置文件</p>
<p><img src="/2021/06/08/Redis/20210427095900.png" srcset="/img/loading.gif" lazyload alt="image-20210427095900836"></p>
<p>4、基本的环境安装</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">yum install gcc-c++<br><br>make<br><br>make install<br></code></pre></div></td></tr></table></figure>
<p><img src="/2021/06/08/Redis/20210427100316.png" srcset="/img/loading.gif" lazyload alt="image-20210427100316774"></p>
<p><img src="/2021/06/08/Redis/20210427100346.png" srcset="/img/loading.gif" lazyload alt="image-20210427100346434"></p>
<p>5、redis默认安装路径    usr/local/bin</p>
<p><img src="/2021/06/08/Redis/20210427100537.png" srcset="/img/loading.gif" lazyload alt="image-20210427100537691"></p>
<p>6、将redis配置文件，复制到我们的当前目录下</p>
<p><img src="/2021/06/08/Redis/20210427100837.png" srcset="/img/loading.gif" lazyload alt="image-20210427100837447"></p>
<p>7、redis默认不是后台启动的，修改配置文件</p>
<p>​    改为yes</p>
<p><img src="/2021/06/08/Redis/20210427101016.png" srcset="/img/loading.gif" lazyload alt="image-20210427101016158"></p>
<p>8、启动redis服务</p>
<p><img src="/2021/06/08/Redis/20210427101429.png" srcset="/img/loading.gif" lazyload alt="image-20210427101429099"></p>
<p>9、使用redis-cli进行连接测试</p>
<p><img src="/2021/06/08/Redis/20210427103808.png" srcset="/img/loading.gif" lazyload alt="image-20210427103808221"></p>
<p>10、查看redis进程是否开启</p>
<p><img src="/2021/06/08/Redis/20210427104116.png" srcset="/img/loading.gif" lazyload alt="image-20210427104116052"></p>
<p>11、如何关闭redis服务    shutdown</p>
<p><img src="/2021/06/08/Redis/20210427104213.png" srcset="/img/loading.gif" lazyload alt="image-20210427104213680"></p>
<p>12、再次查看进程是否存在</p>
<p><img src="/2021/06/08/Redis/20210427104310.png" srcset="/img/loading.gif" lazyload alt="image-20210427104310636"></p>
<h2 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h2><p><strong>redis-benchmark</strong> 是一个压力测试工具</p>
<p>官方自带的性能测试工具</p>
<p><img src="/2021/06/08/Redis/20210427104647.png" srcset="/img/loading.gif" lazyload alt="image-20210427104647012"></p>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 测试：100个并发连接	100000个请求</span><br>redis-benchmark -h localhost -p 6379 -c 100 -n 100000<br></code></pre></div></td></tr></table></figure>
<p><img src="/2021/06/08/Redis/20210427110413.png" srcset="/img/loading.gif" lazyload alt="image-20210427110413714"></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>redis默认有16个数据库</p>
<p><img src="/2021/06/08/Redis/20210427110726.png" srcset="/img/loading.gif" lazyload alt="image-20210427110726503"></p>
<p>默认使用第0个</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; select 2	<span class="hljs-comment">#切换数据库</span><br>OK<br>127.0.0.1:6379[2]&gt; DBSIZE	<span class="hljs-comment">#查看DB大小</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379[2]&gt; keys *<br>(empty array)<br>127.0.0.1:6379[2]&gt; <span class="hljs-built_in">set</span> name aocan<br>OK<br>127.0.0.1:6379[2]&gt; get name<br><span class="hljs-string">&quot;aocan&quot;</span><br>127.0.0.1:6379[2]&gt; keys *	<span class="hljs-comment">#查看数据库所有的key</span><br>1) <span class="hljs-string">&quot;name&quot;</span><br>127.0.0.1:6379[2]&gt; flushall	<span class="hljs-comment">#清空所有数据库</span><br>OK<br>127.0.0.1:6379[2]&gt; flushdb	<span class="hljs-comment">#清空当前数据库</span><br>OK<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>Redis是单线程的</p>
</blockquote>
<p>Redis是很快的，Redis基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了，所以就使用单线程了</p>
<p>Redis是C语言写的，官方提供的数据为100000+的QPS，完全不比同样是使用key-value的Memcache差</p>
<p><strong>Redis为什么单线程还这么快</strong></p>
<p>1、误区1：高性能的服务器一定是多线程的</p>
<p>2、误区2：多线程（CPU上下文会切换）一定比单线程效率高</p>
<p>核心：redis是将所有的数据全部放在内存中的，所以使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的 ，在内存情况下，这个就是最佳方案</p>
<h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><blockquote>
<p>官网文档</p>
</blockquote>
<p><img src="/2021/06/08/Redis/20210427114027.png" srcset="/img/loading.gif" lazyload alt="image-20210427114027257"></p>
<p>Redis是一个开源(BSD许可)的，两存中的数据结构存储系统，它可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>。它支持多种类型的数据结构，如字符串 ( strings )，散列 ( hashes )，列表( lists )，集合( sets)，有序集合( sorted sets ）与范围查询，bitmaps ， hyperloglogs和地理空间(geospatial ）索引半径查询。Redis内置了复制( replication )，LUA脚本(LuaRedis是一个开源(BSD许可)的，两存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。它支持多种类型的数据结构，如字符串 ( strings )，散列 ( hashes )，列表( lists )，集合( sets)，有序集合( sorted sets ）与范围查询，bitmaps ，hyperloglogs和地理空间(geospatial）索引半径查询。Redis内置了复制( replication )，LUA脚本(Luascripting )，LRU驱动事件(LRU eviction )，事务 ( transactions）和不同级别的磁盘持久化 ( persistence)，并通过Redis哨兵( Sentinel )和自动分区( Cluster)提供高可用性( high availability )。</p>
<h2 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; keys *<br>(empty array)<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name aocan<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;name&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> age 1<br>OK<br>127.0.0.1:6379&gt; EXPIRE name 10	<span class="hljs-comment">#设置key的过期时间</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; ttl name	<span class="hljs-comment">#查看当前key的剩余时间，单位是秒</span><br>(<span class="hljs-built_in">integer</span>) -2<br>127.0.0.1:6379&gt; get name<br>(nil)<br>127.0.0.1:6379&gt; EXISTS name	<span class="hljs-comment">#判断当前key是否存在</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; move age 1	<span class="hljs-comment">#移动当前key</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name aocan<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;name&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">type</span> name	<span class="hljs-comment">#查看当前key的类型</span><br>string<br></code></pre></div></td></tr></table></figure>
<p>官网可以查命令</p>
<p><img src="/2021/06/08/Redis/20210427120112.png" srcset="/img/loading.gif" lazyload alt="image-20210427120112336"></p>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#######################################################################</span><br>[root@acacac bin]<span class="hljs-comment"># redis-server acconfig/redis.conf</span><br>[root@acacac bin]<span class="hljs-comment"># redis-cli -p 6379</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key1 v1		<span class="hljs-comment">#设置值</span><br>OK<br>127.0.0.1:6379&gt; get key1		<span class="hljs-comment">#获得值</span><br><span class="hljs-string">&quot;v1&quot;</span><br>127.0.0.1:6379&gt; keys *			<span class="hljs-comment">#获得所有的key</span><br>1) <span class="hljs-string">&quot;key1&quot;</span><br>127.0.0.1:6379&gt; EXISTS key1		<span class="hljs-comment">#判断key是否存在</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; exists key1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; append key1 <span class="hljs-string">&quot;hello&quot;</span>		<span class="hljs-comment">#追加字符串，如果当前key不存在，就相当于set key</span><br>(<span class="hljs-built_in">integer</span>) 7<br>127.0.0.1:6379&gt; get key1<br><span class="hljs-string">&quot;v1hello&quot;</span><br>127.0.0.1:6379&gt; strlen key1		<span class="hljs-comment">#获取字符串的长度</span><br>(<span class="hljs-built_in">integer</span>) 7<br>127.0.0.1:6379&gt; <br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># i++</span><br><span class="hljs-comment"># 步长 i+=</span><br>步长<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> views 0<br>OK<br>127.0.0.1:6379&gt; get views<br><span class="hljs-string">&quot;0&quot;</span><br>127.0.0.1:6379&gt; incr views	<span class="hljs-comment">#自增1</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; incr views<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; get views<br><span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; <br>127.0.0.1:6379&gt; decr views	<span class="hljs-comment">#自减1</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; decr views<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; incrby views 10	<span class="hljs-comment">#设置步长，指定增量</span><br>(<span class="hljs-built_in">integer</span>) 10<br>127.0.0.1:6379&gt; decrby views 5	<span class="hljs-comment">#设置步长，指定减量</span><br>(<span class="hljs-built_in">integer</span>) 5<br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># 字符串范围 range</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key1 <span class="hljs-string">&quot;hello&quot;</span>	<span class="hljs-comment">#设置key1的值</span><br>OK<br>127.0.0.1:6379&gt; get key1<br><span class="hljs-string">&quot;hello&quot;</span><br>127.0.0.1:6379&gt; getrange key1 0 3	<span class="hljs-comment">#截取字符串 [0, 3]</span><br><span class="hljs-string">&quot;hell&quot;</span><br>127.0.0.1:6379&gt; getrange key1 0 -1	<span class="hljs-comment">#获取全部字符串 和 get key是一样的</span><br><span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-comment"># 替换</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key2 absdds<br>OK<br>127.0.0.1:6379&gt; get key2<br><span class="hljs-string">&quot;absdds&quot;</span><br>127.0.0.1:6379&gt; setrange key2 1 xx	<span class="hljs-comment">#替换指定位置开始的字符串</span><br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; get key2<br><span class="hljs-string">&quot;axxdds&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># setex (set with expire)	#设置过期时间</span><br><span class="hljs-comment"># setnx (set if not exist)	#不存在再设置（再分布式锁中常使用）</span><br>127.0.0.1:6379&gt; setex key3 30 <span class="hljs-string">&quot;hello&quot;</span>	<span class="hljs-comment">#设置key3的值为hello。，30秒后过期</span><br>OK<br>127.0.0.1:6379&gt; ttl key3<br>(<span class="hljs-built_in">integer</span>) 25<br>127.0.0.1:6379&gt; ttl key3<br>(<span class="hljs-built_in">integer</span>) 23<br>127.0.0.1:6379&gt; get key3<br><span class="hljs-string">&quot;hello&quot;</span><br>127.0.0.1:6379&gt; ttl key3<br>(<span class="hljs-built_in">integer</span>) 7<br>127.0.0.1:6379&gt; ttl key3<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; get key3<br>(nil)<br>127.0.0.1:6379&gt; setnx mykey <span class="hljs-string">&quot;redis&quot;</span>		<span class="hljs-comment">#如果mykey不存在，创建mykey</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;key2&quot;</span><br>2) <span class="hljs-string">&quot;mykey&quot;</span><br>3) <span class="hljs-string">&quot;key1&quot;</span><br>127.0.0.1:6379&gt; setnx mykey <span class="hljs-string">&quot;MongoDB&quot;</span>	<span class="hljs-comment">#如果mykey存在，创建失败</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; get mykey<br><span class="hljs-string">&quot;redis&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># mset</span><br><span class="hljs-comment"># mget</span><br>127.0.0.1:6379&gt; keys *<br>(empty array)<br>127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3	<span class="hljs-comment">#同时设置多个值</span><br>OK<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;k2&quot;</span><br>2) <span class="hljs-string">&quot;k3&quot;</span><br>3) <span class="hljs-string">&quot;k1&quot;</span><br>127.0.0.1:6379&gt; mget k1 k2 k3	<span class="hljs-comment">#同时获取多个值</span><br>1) <span class="hljs-string">&quot;v1&quot;</span><br>2) <span class="hljs-string">&quot;v2&quot;</span><br>3) <span class="hljs-string">&quot;v3&quot;</span><br>127.0.0.1:6379&gt; msetnx k1 v1 k4 v4	<span class="hljs-comment">#msetnx是一个原子性操作，要么一起成功要么一起失败</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; get k4<br>(nil)<br><br><span class="hljs-comment"># 对象</span><br><span class="hljs-built_in">set</span> user:1 &#123;name:zhangsan, age:3&#125;	<span class="hljs-comment">#设置一个user:1对象 值为json字符串来保存一个对象</span><br><br><span class="hljs-comment">#这里的key是一个巧妙的设计：user:&#123;id&#125;:&#123;filed&#125;</span><br><br>127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 3<br>OK<br>127.0.0.1:6379&gt; mget user:1:name user:1:age<br>1) <span class="hljs-string">&quot;zhangsan&quot;</span><br>2) <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br>getset <span class="hljs-comment"># 先get再set</span><br><br>127.0.0.1:6379&gt; getset db redis		<span class="hljs-comment">#如果不存在值，则返回nil</span><br>(nil)<br>127.0.0.1:6379&gt; get db<br><span class="hljs-string">&quot;redis&quot;</span><br>127.0.0.1:6379&gt; getset db mongodb	<span class="hljs-comment">#如果存在值，获取原来的值，并设置新的值</span><br><span class="hljs-string">&quot;redis&quot;</span><br>127.0.0.1:6379&gt; get db<br><span class="hljs-string">&quot;mongodb&quot;</span><br></code></pre></div></td></tr></table></figure>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>基本的数据类型，列表</p>
<p><img src="/2021/06/08/Redis/20210602141315.png" srcset="/img/loading.gif" lazyload alt="List"></p>
<p>在Redis里面，可以把llist当作栈，队列，阻塞队列</p>
<p>所有的list命令都是用l开头的，Redis不区分大小写命令</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">###########################################################################</span><br>127.0.0.1:6379&gt; lpush list one	<span class="hljs-comment">#将一个值或者多个值，插入到列表头部（左）</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lpush list two<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; lpush list three<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; lrange list 0 -1	<span class="hljs-comment">#获取list中的值</span><br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>3) <span class="hljs-string">&quot;one&quot;</span><br>127.0.0.1:6379&gt; lrange list 0 1		<span class="hljs-comment">#通过区间获取具体的值</span><br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>127.0.0.1:6379&gt; rpush list right	<span class="hljs-comment">#将一个值或者多个值，插入到列表尾部（右）</span><br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; lrange list 0 1<br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>3) <span class="hljs-string">&quot;one&quot;</span><br>4) <span class="hljs-string">&quot;right&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># lpop/rpop	移除元素</span><br><br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>3) <span class="hljs-string">&quot;one&quot;</span><br>4) <span class="hljs-string">&quot;right&quot;</span><br>127.0.0.1:6379&gt; lpop list	<span class="hljs-comment">#移除list的第一个元素</span><br><span class="hljs-string">&quot;three&quot;</span><br>127.0.0.1:6379&gt; rpop list	<span class="hljs-comment">#移除list的最后一个元素</span><br><span class="hljs-string">&quot;right&quot;</span><br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;two&quot;</span><br>2) <span class="hljs-string">&quot;one&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># lindex	通过下标获取list中的某一个值</span><br><br>127.0.0.1:6379&gt; lindex list 1<br><span class="hljs-string">&quot;one&quot;</span><br>127.0.0.1:6379&gt; lindex list 0<br><span class="hljs-string">&quot;two&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># llen	返回list的长度</span><br><br>127.0.0.1:6379&gt; lpush list one<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lpush list two<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; lpush list three<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; lpush list four<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; llen list<br>(<span class="hljs-built_in">integer</span>) 4<br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># lrem 移除list集合中指定个数的value，精确匹配</span><br><br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;four&quot;</span><br>2) <span class="hljs-string">&quot;four&quot;</span><br>3) <span class="hljs-string">&quot;three&quot;</span><br>4) <span class="hljs-string">&quot;two&quot;</span><br>5) <span class="hljs-string">&quot;one&quot;</span><br>127.0.0.1:6379&gt; lrem list 1 one<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;four&quot;</span><br>2) <span class="hljs-string">&quot;four&quot;</span><br>3) <span class="hljs-string">&quot;three&quot;</span><br>4) <span class="hljs-string">&quot;two&quot;</span><br>127.0.0.1:6379&gt; lpush list four<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; lrem list 2 four<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;four&quot;</span><br>2) <span class="hljs-string">&quot;three&quot;</span><br>3) <span class="hljs-string">&quot;two&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># ltrim 修剪： list 截断</span><br><br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello&quot;</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello1&quot;</span><br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello2&quot;</span><br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello3&quot;</span><br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; ltrim mylist 1 2	<span class="hljs-comment">#通过下标截取指定长度，这个list已经改变了，截断了只剩下截取的元素</span><br>OK<br>127.0.0.1:6379&gt; lrange mylist 0 -1<br>1) <span class="hljs-string">&quot;hello1&quot;</span><br>2) <span class="hljs-string">&quot;hello2&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># rpoplpush	移除列表的最后一个元素，并添加到另一个列表</span><br><br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello&quot;</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello1&quot;</span><br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello2&quot;</span><br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello3&quot;</span><br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; rpoplpush mylist myotherlist<br><span class="hljs-string">&quot;hello3&quot;</span><br>127.0.0.1:6379&gt; lrange mylist 0 -1	<span class="hljs-comment">#查看原来的列表</span><br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;hello1&quot;</span><br>3) <span class="hljs-string">&quot;hello2&quot;</span><br>127.0.0.1:6379&gt; lrange myotherlist 0 -1	<span class="hljs-comment">#查看目标列表</span><br>1) <span class="hljs-string">&quot;hello3&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># lset 将列表中指定下标的值替换为另外一个值，更新操作</span><br><br>127.0.0.1:6379&gt; exists list	<span class="hljs-comment"># 判断这个列表是否存在</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; lset list 0 item	<span class="hljs-comment">#如果不存在列表我们去更新就会报错</span><br>(error) ERR no such key<br>127.0.0.1:6379&gt; lpush list value<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lrange list 0 0 <br>1) <span class="hljs-string">&quot;value&quot;</span><br>127.0.0.1:6379&gt; lset list 0 item<br>OK<br>127.0.0.1:6379&gt; lrange list 0 0 <br>1) <span class="hljs-string">&quot;item&quot;</span><br>127.0.0.1:6379&gt; lset list 1 item<br>(error) ERR index out of range<br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># linsert 	将某个具体的值插入到列表中某个元素的前面或者后面</span><br><br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello&quot;</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;world&quot;</span><br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; linsert mylist before <span class="hljs-string">&quot;world&quot;</span> <span class="hljs-string">&quot;other&quot;</span><br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; lrange mylist 0 -1<br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;other&quot;</span><br>3) <span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; linsert mylist after world new<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; lrange mylist 0 -1<br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;other&quot;</span><br>3) <span class="hljs-string">&quot;world&quot;</span><br>4) <span class="hljs-string">&quot;new&quot;</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>实际上是一个链表，before Node after，left，right都可以插入值</li>
<li>如果key不存在，创建新的链表</li>
<li>如果key存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在</li>
<li>在两边插入或者改动值，效率最高。中间元素，相对来说效率会低一点</li>
</ul>
<p>消息排队，消息队列 （lpush rpop），栈（lpush，lpop）</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>set中的值是不能重读的</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">###########################################################################</span><br>127.0.0.1:6379&gt; sadd myset hello	<span class="hljs-comment">#set集合中添加元素</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset hello2<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset ac<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; smembers myset		<span class="hljs-comment">#查看指定set的所有值</span><br>1) <span class="hljs-string">&quot;ac&quot;</span><br>2) <span class="hljs-string">&quot;hello2&quot;</span><br>3) <span class="hljs-string">&quot;hello&quot;</span><br>127.0.0.1:6379&gt; sismember myset hello	<span class="hljs-comment">#判断某一个值是不是在set集合中</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sismember myset world<br>(<span class="hljs-built_in">integer</span>) 0<br><br><span class="hljs-comment">###########################################################################</span><br>127.0.0.1:6379&gt; scard myset		<span class="hljs-comment">#获取set集合中的元素个数</span><br>(<span class="hljs-built_in">integer</span>) 3<br><br><span class="hljs-comment">###########################################################################</span><br>srem<br><br>127.0.0.1:6379&gt; srem myset hello	<span class="hljs-comment">#移除set集合中的指定元素</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; scard myset<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; smembers myset<br>1) <span class="hljs-string">&quot;ac&quot;</span><br>2) <span class="hljs-string">&quot;hello2&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># set 无序不重复</span><br>127.0.0.1:6379&gt; srandmember myset	<span class="hljs-comment">#随机输出一个元素</span><br><span class="hljs-string">&quot;ac&quot;</span><br>127.0.0.1:6379&gt; srandmember myset 2	<span class="hljs-comment">#随机抽选出指定个数的元素</span><br>1) <span class="hljs-string">&quot;ac&quot;</span><br>2) <span class="hljs-string">&quot;hello2&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># 删除指定的key，随机删除key</span><br><br>127.0.0.1:6379&gt; smembers myset<br>1) <span class="hljs-string">&quot;ac&quot;</span><br>2) <span class="hljs-string">&quot;hello2&quot;</span><br>3) <span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; spop myset<br><span class="hljs-string">&quot;hello2&quot;</span><br>127.0.0.1:6379&gt; spop myset<br><span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; smembers myset<br>1) <span class="hljs-string">&quot;ac&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># 将一个指定的值，移动到另外一个set集合中</span><br><br>127.0.0.1:6379&gt; sadd myset hello<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset world<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset redis<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset aaa<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; smembers myset<br>1) <span class="hljs-string">&quot;aaa&quot;</span><br>2) <span class="hljs-string">&quot;hello&quot;</span><br>3) <span class="hljs-string">&quot;redis&quot;</span><br>4) <span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; sadd myset2 hello2<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; smembers myset2<br>1) <span class="hljs-string">&quot;hello2&quot;</span><br>127.0.0.1:6379&gt; smove myset myset2 hello<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; smembers myset<br>1) <span class="hljs-string">&quot;aaa&quot;</span><br>2) <span class="hljs-string">&quot;redis&quot;</span><br>3) <span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; smembers myset2<br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;hello2&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># eg：共同关注（交集）</span><br><span class="hljs-comment">#	数字集合类</span><br><span class="hljs-comment">#	 - 差集 sdiff</span><br><span class="hljs-comment">#	 - 交集 sinter</span><br><span class="hljs-comment">#	 - 并集 sunion</span><br><br>127.0.0.1:6379&gt; sadd k1 a<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd k1 b<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd k1 c<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd k2 c<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd k2 d<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd k2 e<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sdiff k1 k2		<span class="hljs-comment">#差集</span><br>1) <span class="hljs-string">&quot;b&quot;</span><br>2) <span class="hljs-string">&quot;a&quot;</span><br>127.0.0.1:6379&gt; sinter k1 k2	<span class="hljs-comment">#交集</span><br>1) <span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6379&gt; sunion k1 k2	<span class="hljs-comment">#并集</span><br>1) <span class="hljs-string">&quot;b&quot;</span><br>2) <span class="hljs-string">&quot;c&quot;</span><br>3) <span class="hljs-string">&quot;a&quot;</span><br>4) <span class="hljs-string">&quot;e&quot;</span><br>5) <span class="hljs-string">&quot;d&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>微博，A用户将所有关注的人放在一个set集合中，将他的粉丝也放在一个集合中</p>
<p>共同关注，共同爱好，二度好友（六度分割理论）</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Map集合，key-map 这个值是一个map集合，本质和String类型没有太大区别，还是一个简单的key-value</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; hset myhash field1 redis		<span class="hljs-comment">#set一个具体的key-value</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hget myhash field1	<span class="hljs-comment">#获取一个字段值</span><br><span class="hljs-string">&quot;redis&quot;</span><br>127.0.0.1:6379&gt; hmset myhash field1 hello field2 world	<span class="hljs-comment">#set多个key-value</span><br>OK<br>127.0.0.1:6379&gt; hmget myhash field1 field2	<span class="hljs-comment">#获取多个字段值</span><br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; hgetall myhash	<span class="hljs-comment">#获取全部的数据</span><br>1) <span class="hljs-string">&quot;field1&quot;</span><br>2) <span class="hljs-string">&quot;hello&quot;</span><br>3) <span class="hljs-string">&quot;field2&quot;</span><br>4) <span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; hdel myhash field1	<span class="hljs-comment">#删除hash指定key字段，对应的value值也就消失了</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hgetall myhash<br>1) <span class="hljs-string">&quot;field2&quot;</span><br>2) <span class="hljs-string">&quot;world&quot;</span><br><span class="hljs-comment">###########################################################################</span><br>hlen<br><br>127.0.0.1:6379&gt; hmset myhash field1 hello field2 world<br>OK<br>127.0.0.1:6379&gt; hgetall myhash<br>1) <span class="hljs-string">&quot;field2&quot;</span><br>2) <span class="hljs-string">&quot;world&quot;</span><br>3) <span class="hljs-string">&quot;field1&quot;</span><br>4) <span class="hljs-string">&quot;hello&quot;</span><br>127.0.0.1:6379&gt; hlen myhash	<span class="hljs-comment">#获取hash表的字段数量</span><br>(<span class="hljs-built_in">integer</span>) 2<br><br><span class="hljs-comment">###########################################################################</span><br>127.0.0.1:6379&gt; hexists myhash field1	<span class="hljs-comment">#判断hash中指定字段是否存在</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hexists myhash field3<br>(<span class="hljs-built_in">integer</span>) 0<br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># 只获得所有field</span><br><span class="hljs-comment"># 只获得所有value</span><br>127.0.0.1:6379&gt; hkeys myhash	<span class="hljs-comment">#只获取所有field</span><br>1) <span class="hljs-string">&quot;field2&quot;</span><br>2) <span class="hljs-string">&quot;field1&quot;</span><br>127.0.0.1:6379&gt; hvals myhash	<span class="hljs-comment">#只获取所有value</span><br>1) <span class="hljs-string">&quot;world&quot;</span><br>2) <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>hash变更的数据 user name age，尤其是用户信息之类的，经常变动的信息。Hash更适合对象的存储，String更适合字符串的存储</p>
<h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><p>在set的基础上，增加了一个值，set k1 v1, zset k1 score1 v1</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; zadd myset 1 one	<span class="hljs-comment">#添加一个值</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd myset 2 two 3 three	<span class="hljs-comment">#添加多个值</span><br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; zrange myset 0 -1<br>1) <span class="hljs-string">&quot;one&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>3) <span class="hljs-string">&quot;three&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br>排序<br>127.0.0.1:6379&gt; zadd salary 2000 zhangsan<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd salary 2500 lisi<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd salary 200 wangwu<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zrangebyscore salary -inf +inf	<span class="hljs-comment">#升序排序 显示全部用户</span><br>1) <span class="hljs-string">&quot;wangwu&quot;</span><br>2) <span class="hljs-string">&quot;zhangsan&quot;</span><br>3) <span class="hljs-string">&quot;lisi&quot;</span><br>127.0.0.1:6379&gt; zrevrangebyscore salary +inf -inf	<span class="hljs-comment">#降序排序</span><br>1) <span class="hljs-string">&quot;lisi&quot;</span><br>2) <span class="hljs-string">&quot;zhangsan&quot;</span><br>3) <span class="hljs-string">&quot;wangwu&quot;</span><br>127.0.0.1:6379&gt; zrevrangebyscore salary +inf -inf withscores<br>1) <span class="hljs-string">&quot;lisi&quot;</span><br>2) <span class="hljs-string">&quot;2500&quot;</span><br>3) <span class="hljs-string">&quot;zhangsan&quot;</span><br>4) <span class="hljs-string">&quot;2000&quot;</span><br>5) <span class="hljs-string">&quot;wangwu&quot;</span><br>6) <span class="hljs-string">&quot;200&quot;</span><br><br></code></pre></div></td></tr></table></figure>
<h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1><h2 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h2><p>…</p>
<h2 id="hyperloglog基数统计"><a href="#hyperloglog基数统计" class="headerlink" title="hyperloglog基数统计"></a>hyperloglog基数统计</h2><p>基数（不重复的元素个数）</p>
<p>优点：占用的内存是固定的，2^64不同元素的基数，只需要12KB的内存</p>
<p><strong>网页的UV （一个人访问一个网站多次，但是还是算作一个人）</strong></p>
<p>传统方式：set保存用户的id，然后就可以统计set中的元素数量来作为标准判断，这个方式如果保存大量的用户id，就会比较麻烦，我们的目的是为了计数，而不是保存用户id</p>
<p>0.81%错误率</p>
<p>…</p>
<h2 id="bitmaps位图"><a href="#bitmaps位图" class="headerlink" title="bitmaps位图"></a>bitmaps位图</h2><blockquote>
<p>位存储</p>
</blockquote>
<p>统计用户信息，活跃，不活跃     登录，未登录     打卡</p>
<p>两个状态的，都可以使用Bitmaps</p>
<p>Bitmaps位图，数据结构，都是操作二进制位来进行记录，就只有0和1两个状态</p>
<p>…</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis事务本质：一组命令的集合，一个事务中所有的命令会被序列化，在事务执行过程中，会按照顺序执行</p>
<p>一次性、顺序性、排他性</p>
<p>==Redis事务没有隔离级别的概念==</p>
<p>所有的命令在事务中，并没有直接被执行，只有发起执行命令的时候才会执行</p>
<p>==Redis单条命令是保证原子性的，但是事务不保证原子性==</p>
<p>redis事务：</p>
<ul>
<li>开启事务（multi）</li>
<li>命令入队（）</li>
<li>执行事务（exec）</li>
</ul>
<blockquote>
<p>正常执行事务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi	<span class="hljs-comment">#开启事务</span><br>OK<br><span class="hljs-comment"># 命令入队</span><br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k1 v1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k2 v2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; get k2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k3 v3<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span>	<span class="hljs-comment">#执行事务</span><br>1) OK<br>2) OK<br>3) <span class="hljs-string">&quot;v2&quot;</span><br>4) OK<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>放弃事务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi	<span class="hljs-comment">#开启事务</span><br>OK<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k1 v1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k2 v2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k4 v4<br>QUEUED<br>127.0.0.1:6379(TX)&gt; discard		<span class="hljs-comment">#取消事务</span><br>OK<br>127.0.0.1:6379&gt; get k4	<span class="hljs-comment">#事务队列中的命令都不会被执行</span><br>(nil)<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>编译型异常（代码有问题，命令有错），事务中所有的命令都不会被执行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k1 v1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k2 v2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k3 v3<br>QUEUED<br>127.0.0.1:6379(TX)&gt; getset k3	<span class="hljs-comment">#错误的命令</span><br>(error) ERR wrong number of arguments <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;getset&#x27;</span> <span class="hljs-built_in">command</span><br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k4 v4<br>QUEUED <br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k5 v5<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span>	<span class="hljs-comment">#执行事务报错</span><br>(error) EXECABORT Transaction discarded because of previous errors.<br>127.0.0.1:6379&gt; get k5		<span class="hljs-comment">#所有的命令都不会被执行</span><br>(nil)<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>运行时异常（1/0），如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令会抛出异常</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; incr k1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> v2 k2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k3 v3<br>QUEUED<br>127.0.0.1:6379(TX)&gt; get k3<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span><br>1) (error) ERR value is not an <span class="hljs-built_in">integer</span> or out of range	<span class="hljs-comment">#虽然第一条命令报错了，但是依旧正常执行成功了</span><br>2) OK<br>3) OK<br>4) <span class="hljs-string">&quot;v3&quot;</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>监控    Watch</p>
</blockquote>
<p><strong>悲观锁：</strong></p>
<ul>
<li>很悲观，认为什么时候都会出问题，无论做什么都会加锁</li>
</ul>
<p><strong>乐观锁：</strong></p>
<ul>
<li>很乐观，认为什么时候都不会出问题，所以不会上锁，更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li>
<li>获取version</li>
<li>更新的时候比较version</li>
</ul>
<blockquote>
<p> Redis监视测试</p>
</blockquote>
<p>正常执行成功</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> money 100<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> out 0<br>OK<br>127.0.0.1:6379&gt; watch money 	<span class="hljs-comment">#监视money对象</span><br>OK<br>127.0.0.1:6379&gt; multi		<span class="hljs-comment">#事务正常结束，数据期间没有发生变动，这个时候就正常执行成功</span><br>OK<br>127.0.0.1:6379(TX)&gt; decrby money 20<br>QUEUED<br>127.0.0.1:6379(TX)&gt; incrby out 20<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span><br>1) (<span class="hljs-built_in">integer</span>) 80<br>2) (<span class="hljs-built_in">integer</span>) 20<br></code></pre></div></td></tr></table></figure>
<p>测试多线程修改值，使用watch当作redis的乐观锁操作</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; watch money		<span class="hljs-comment">#监视money</span><br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; decrby money 10<br>QUEUED<br>127.0.0.1:6379(TX)&gt; incrby money 10<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span>		<span class="hljs-comment">#执行之前，另外一个线程修改了money的值，导致事务执行失败</span><br>(nil)<br></code></pre></div></td></tr></table></figure>
<p>如果修改失败，获取最新的值就好</p>
<p><img src="/2021/06/08/Redis/20210602175313.png" srcset="/img/loading.gif" lazyload alt="Redis执行乐观锁操作"></p>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>使用Java来操作Redis</p>
<blockquote>
<p>Jedis是Redis官方推荐的java连接开发工具，使用Java操作Redis中间件</p>
<p>测试</p>
</blockquote>
<ol>
<li>导入对应的依赖</li>
<li>编码测试<ul>
<li>连接数据库</li>
<li>操作命令</li>
<li>断开连接</li>
</ul>
</li>
</ol>
<h2 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h2><p>String</p>
<p>List</p>
<p>Set</p>
<p>Hash</p>
<p>ZSet</p>
<h1 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h1><p>启动的时候，通过配置文件启动</p>
<blockquote>
<p>单位</p>
</blockquote>
<p><img src="/2021/06/08/Redis/20210608091709.png" srcset="/img/loading.gif" lazyload alt="单位"></p>
<ol>
<li>配置文件unit单位对大小写不敏感</li>
</ol>
<blockquote>
<p>包含</p>
</blockquote>
<p><img src="/2021/06/08/Redis/20210608091913.png" srcset="/img/loading.gif" lazyload alt="包含"></p>
<blockquote>
<p>网络</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> 127.0.0.1 -::1		<span class="hljs-comment">#绑定的ip</span><br>protected-mode yes		<span class="hljs-comment">#保护模式</span><br>port 6379				<span class="hljs-comment">#端口设置</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>通用GENERAL</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs BASH">daemonize yes			<span class="hljs-comment">#以守护进程的方式运行，默认是no，需要自己开启为yes</span><br><br>pidfile /var/run/redis_6379.pid		<span class="hljs-comment">#如果以后台的方式运行，就需要指定一个pid文件</span><br><br><span class="hljs-comment"># 日志</span><br><span class="hljs-comment"># Specify the server verbosity level.</span><br><span class="hljs-comment"># This can be one of:</span><br><span class="hljs-comment"># debug (a lot of information, useful for development/testing)</span><br><span class="hljs-comment"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="hljs-comment"># notice (moderately verbose, what you want in production probably)	生产环境</span><br><span class="hljs-comment"># warning (only very important / critical messages are logged)</span><br>loglevel notice<br>logfile <span class="hljs-string">&quot;&quot;</span>		<span class="hljs-comment">#日志的文件名</span><br>databases 16	<span class="hljs-comment">#数据库的数量，默认是16个数据库</span><br>always-show-logo no		<span class="hljs-comment">#是否总是显示logo</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>快照</p>
</blockquote>
<p>持久化，在规定时间内，执行了多少次操作，则会持久化到文件 .rdb .aof</p>
<p>redis是内存数据库，如果没有持久化，那么数据断电即失</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 如果900s内，至少有一个key进行了修改，就进行持久化操作</span><br>save 3600 1<br><span class="hljs-comment"># 如果300s内，至少10key进行了修改，就进行持久化操作</span><br>save 300 100<br><span class="hljs-comment"># 如果60s内，至少10000key进行了修改，就进行持久化操作</span><br>save 60 10000<br><span class="hljs-comment"># 可以自定义</span><br><br>stop-writes-on-bgsave-error yes		<span class="hljs-comment"># 如果持久化出错，是否还要继续工作</span><br><br>rdbcompression yes		<span class="hljs-comment"># 是否压缩rdb文件，需要消耗一些cpu资源</span><br><br>rdbchecksum yes		<span class="hljs-comment"># 保存rdb文件的时候，进行错误的检查校验</span><br><br>dir ./		<span class="hljs-comment"># reb文件保存的目录</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>限制CLIENTS</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">maxclients 10000		<span class="hljs-comment"># 设置能连接上redis的最大客户端的数量</span><br><br>maxmemory &lt;bytes&gt;		<span class="hljs-comment"># redis配置的最大的内存容量</span><br><br>maxmemory-policy noeviction		<span class="hljs-comment"># 内存到达上限之后的处理策略</span><br>	1. volatile-lru：只设置了过期时间的key进行LRU（默认值）<br>	2. allkeys-lru：删除lru算法的key<br>	3. volatile-random：随机删除即将过期的key<br>	4. allkeys-random：随机删除<br>	5. volatile-ttl：删除即将过期的<br>	6. noeviction：永不过期，返回错误<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>APPEND ONLY 模式    aof配置</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">appendonly no		<span class="hljs-comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用</span><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span>		<span class="hljs-comment"># 持久化的文件的名字</span><br><br><span class="hljs-comment"># appendfsync always		# 每次修改都会sync，消耗性能</span><br>appendfsync everysec		<span class="hljs-comment"># 每秒执行一次sync，可能会丢失这1s的数据</span><br><span class="hljs-comment"># appendfsync no		# 不执行sync，这个时候操作系统自己同步数据，速度最快</span><br></code></pre></div></td></tr></table></figure>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能</p>
<h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><blockquote>
<p>什么是RDB</p>
</blockquote>
<p><img src="/2021/06/08/Redis/20210608103012.png" srcset="/img/loading.gif" lazyload alt="RDB"></p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<p>Redis会单独创建 （ fork )一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。一般默认用RDB</p>
<p>==rdb保存的文件是dump.rdb==</p>
<p><img src="/2021/06/08/Redis/20210608103436.png" srcset="/img/loading.gif" lazyload alt="image-20210608103436795"></p>
<blockquote>
<p>触发机制</p>
</blockquote>
<ol>
<li>save 的规则满足的情况下，会自动触发rdb的规则</li>
<li>执行flushall命令，也会触发rdb规则</li>
<li>退出redis，也会产生rdb文件</li>
</ol>
<p>备份就会自动生成一个rdb文件dump.rdb</p>
<blockquote>
<p>如何恢复rdb文件</p>
</blockquote>
<ol>
<li><p>只需要将rdb文件放在redis的启动目录就可以，redis启动的时候会自动检查dump.rdb恢复其中的数据</p>
</li>
<li><p>查看位置</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; config get dir<br>1) <span class="hljs-string">&quot;dir&quot;</span><br>2) <span class="hljs-string">&quot;/&quot;</span>		<span class="hljs-comment"># 如果在这个目录下存在dump.rdb文件，启动就会自动恢复其中的数据</span><br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>默认配置一般够用</p>
</blockquote>
<p><strong>优点：</strong></p>
<div class="hljs code-wrapper"><pre><code> 1. 适合大规模的数据恢复
 2. 对数据的完整性要求不高
</code></pre></div><p><strong>缺点：</strong></p>
<div class="hljs code-wrapper"><pre><code>1. 需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改数据就没有了
2. fork进行的时候，会占用一定的内容空间
</code></pre></div><h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>将所有命令记录下来，恢复的时候就把这个文件全部再执行一遍</p>
<blockquote>
<p>是什么</p>
</blockquote>
<p><img src="/2021/06/08/Redis/20210608105137.png" srcset="/img/loading.gif" lazyload alt="AOF"></p>
<p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来(读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p>==AOF保存的是aof文件appendonly.aof==</p>
<p><img src="/2021/06/08/Redis/20210608105333.png" srcset="/img/loading.gif" lazyload alt="aof配置"></p>
<p>默认是不开启的，需要手动配置，只需要将appendonly改为yes就开启了aof</p>
<p>重启，redis就可以生效了</p>
<p>如果aof文件有错误，redis是启动不起来的，需要修复这个aof文件</p>
<p>redis提供了一个修复工具==redis-check-aof —fix==</p>
<p>如果文件正常，重启就可以直接恢复了</p>
<blockquote>
<p>优点和缺点</p>
</blockquote>
<p><strong>优点：</strong></p>
<ol>
<li>每一次修改都同步，文件的完整性会更好</li>
<li>每秒同步一次，可能会丢失一秒的数据</li>
<li>从不同步，效率是最高的</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢</li>
<li>Aof运行效率也比rdb慢，所以redis默认的配置就是rdb持久化</li>
</ol>
<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><ol>
<li>RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</li>
<li><strong>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</strong></li>
<li>同时开启两种持久化方式<ul>
<li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢?作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段</li>
</ul>
</li>
<li>性能建议<ul>
<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 9001这条规则。</li>
<li>如果Enable AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IО，二是AOF rewrite 的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li>
<li>如果不Enable AOF，仅靠Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉（断电），会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave 中的RDB文件，载入较新的那个，微博就是这种架构。</li>
</ul>
</li>
</ol>
<h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><p>Redis 发布订阅(pub/sub)是一种<strong>消息通信模式</strong>∶发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。<br>订阅/发布消息图︰</p>
<p><img src="/2021/06/08/Redis/20210608114751.png" srcset="/img/loading.gif" lazyload alt="订阅/发布消息图"></p>
<p>下图展示了频道channel1，以及订阅这个频道的三个客户端—client2、 client5和client1之间的关系：</p>
<p><img src="/2021/06/08/Redis/20210608115132.png" srcset="/img/loading.gif" lazyload alt="关系图"></p>
<p>当有新消息通过PUBLISH 命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="/2021/06/08/Redis/20210608115205.png" srcset="/img/loading.gif" lazyload alt="publish"></p>
<blockquote>
<p>命令</p>
</blockquote>
<p>广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。</p>
<p><img src="/2021/06/08/Redis/20210608115339.png" srcset="/img/loading.gif" lazyload alt="常用命令"></p>
<blockquote>
<p>原理</p>
</blockquote>
<p>Redis是使用C实现的，通过分析Redis源码里的pubsub.c文件，了解发布和订阅机制的底层实现，籍此加深对Redis的理解。<br>Redis通过PUBLISH、SUBSCRIBE和PSUBSCRIBE等命令实现发布和订阅功能。<br>微信︰<br>通过SUBSCRIBE命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个个频道!，而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。SUBSCRIBE命令的关键，就是将客户端添加到给定channel的订阅链表中。</p>
<p>通过PUBLISH命令向订阅者发送消息，redis-server会使用给定的频道作为键，在它所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。<br>Pub/Sub从字面上理解就是发布( Publish )与订阅(Subscribe )，在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>
<p>使用场景：</p>
<div class="hljs code-wrapper"><pre><code>1. 实时消息系统
2. 实时聊天（频道当作聊天室，将消息回显给所有人）
3. 订阅，关注系统
</code></pre></div><p>稍微复杂的场景就会使用 消息中间件来做MQ（）</p>
<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；==数据的复制是单向的，只能由主节点到从节点。==Master以<strong>写</strong>为主，Slave以<strong>读</strong>为主。<br>默认情况下，每台Redis服务器都是主节点;且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。主从复制的作用主要包括︰</p>
<ol>
<li>数据冗余︰主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复︰当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复;实际上是一种服务的冗余。</li>
<li>负载均衡︰在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载;尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>高可用（集群）基石∶除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ol>
<p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下︰</p>
<ol>
<li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大;</li>
<li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，==<strong>单台Redis最大使用内存不应该超过20G</strong>==。</li>
</ol>
<p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p>
<p><img src="/2021/06/08/Redis/20210608120510.png" srcset="/img/loading.gif" lazyload alt="架构图"></p>
<p>主从复制，读写分离。80%的情况下都是在进行读操作，减缓服务器的压力，架构中经常使用，一主二从</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>只配置从库，不用配置主库</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; info replication		<span class="hljs-comment"># 查看当前库的信息</span><br><span class="hljs-comment"># Replication</span><br>role:master		<span class="hljs-comment">#角色  master</span><br>connected_slaves:0		<span class="hljs-comment"># 没有从机</span><br>master_failover_state:no-failover<br>master_replid:7cdca0c685bfe1a2eb296b1534f23dbb14dcd382<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></div></td></tr></table></figure>
<p>复制3个配置文件，然后修改对应的信息</p>
<ol>
<li>端口</li>
<li>pid 名字</li>
<li>log文件名字</li>
<li>dump.rdb名字</li>
</ol>
<blockquote>
<p>细节</p>
</blockquote>
<p>主机可以写，从机不能写只能读。主机中的所有信息和数据，都会自动被从机保存</p>
<p><strong>主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候主机如果回来了，从机依旧可以直接获取到主机写的信息</strong></p>
<p>如果是使用命令行来配置的主从，这个时候如果重启了，就会变成主机。只要变为从机，立马就会从主机中获取值</p>
<blockquote>
<p> 复制原理</p>
</blockquote>
<p>Slave启动成功连接到 master后会发送一个sync同步命令<br>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，==master将传送整个数据文件到slave，并完成一次完全同步==</p>
<ul>
<li><strong>全量复制</strong>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中</li>
<li><strong>增量复制</strong>：Master继续将新的所有收集到的修改命令依次传给slave，完成同步但是只要是重新连接master，一次完全同步(全量复制)将被自动执行</li>
</ul>
<p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行，我们是数据一定可以在从机中看到</p>
<blockquote>
<p>手动</p>
</blockquote>
<p>如果主机断开了连接，我们可以使用下面的指令来让自己变成主机，其他的节点就可以手动连接到最新的这个主节点（手动）。如果原主机修复了，那就重新连接</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">SLAVEOF no one<br></code></pre></div></td></tr></table></figure>
<h2 id="哨兵模式（自动）"><a href="#哨兵模式（自动）" class="headerlink" title="哨兵模式（自动）"></a>哨兵模式（自动）</h2><blockquote>
<p>概述</p>
</blockquote>
<p>主从切换技术的方法是︰当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel (哨兵）架构来解决这个问题。</p>
<p>能够后台监控主机是否故障，如果故障了根据投票数自动<strong>将从库转化为主库</strong>。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例</strong>。</p>
<p><img src="/2021/06/08/Redis/20210608191620.png" srcset="/img/loading.gif" lazyload alt="哨兵模式"></p>
<p>这里的哨兵有两个作用</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器</li>
<li>当哨兵监测到master宕机，会自动将slave切换成为mater，然后通过<strong>发布订阅</strong>通知其他的从服务器，修改配置文件，让他们切换主机</li>
</ul>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式</p>
<p><img src="/2021/06/08/Redis/20210608192044.png" srcset="/img/loading.gif" lazyload alt="多哨兵模式"></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<p>主机回来后只能归并到新的主机下，当作从机，这就是哨兵模式的规则</p>
<blockquote>
<p>哨兵模式</p>
</blockquote>
<p>优点：</p>
<ol>
<li>哨兵集群，基于主从复制模式，所有的主从配置优点</li>
<li>主从可以切换，故障可以转移，系统的可用性会更好</li>
<li>哨兵模式就是主从模式的升级版，手动到自动，更加健壮</li>
</ol>
<p>缺点：</p>
<ol>
<li>Redis不方便在线扩容，集群容量一旦到达上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择</li>
</ol>
<h1 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h1><blockquote>
<p>服务的高可用问题</p>
</blockquote>
<p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/javalanguage/p/12401829.html">https://www.cnblogs.com/javalanguage/p/12401829.html</a></p>
<h2 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h2><blockquote>
<p>概念</p>
</blockquote>
<p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>布隆过滤器</strong></p>
<p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43263751">https://zhuanlan.zhihu.com/p/43263751</a></p>
<p><strong>缓存空对象</strong></p>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源</p>
<p><img src="/2021/06/08/Redis/20210608194813.png" srcset="/img/loading.gif" lazyload alt="缓存空对象"></p>
<p>但是这种方法会存在两个问题:</p>
<ol>
<li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</li>
<li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li>
</ol>
<h2 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h2><blockquote>
<p>概念</p>
</blockquote>
<p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。<br>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>设置热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题。</p>
<p><strong>加互斥锁</strong></p>
<p>分布式锁︰使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote>
<p>概念</p>
</blockquote>
<p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis宕机</p>
<p>比如对于系统A，假设每天高峰期每秒5000个请求，本来缓存在高峰期可以扛住每秒4000个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。</p>
<p><img src="/2021/06/08/Redis/20210608195615.png" srcset="/img/loading.gif" lazyload alt="缓存雪崩"></p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>redis高可用</strong></p>
<p>增加redis，一台挂掉还有其他的继续工作，其实就是搭建集群</p>
<p><strong>限流降级</strong></p>
<p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如说对某个key只允许一个线程查询数据和写数据，其他线程等待</p>
<p><strong>数据预热</strong></p>
<p>数据预热的含义就是在正式部署之前，把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问签手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="Redis-和-MemeCache-有什么区别？"><a href="#Redis-和-MemeCache-有什么区别？" class="headerlink" title="Redis 和 MemeCache 有什么区别？"></a>Redis 和 MemeCache 有什么区别？</h2><ol>
<li>存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。</li>
<li>数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。</li>
<li>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型</li>
<li>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除</li>
</ol>
<h2 id="Redis-为什么是单线程的？"><a href="#Redis-为什么是单线程的？" class="headerlink" title="Redis 为什么是单线程的？"></a>Redis 为什么是单线程的？</h2><p>因为 redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p>
<ol>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ol>
<h2 id="Redis-支持的数据类型有哪些？"><a href="#Redis-支持的数据类型有哪些？" class="headerlink" title="Redis 支持的数据类型有哪些？"></a>Redis 支持的数据类型有哪些？</h2><ul>
<li>string 字符串（可以为整形、浮点型和字符串，统称为元素）</li>
<li>list 列表（实现队列,元素不唯一，先入先出原则）</li>
<li>set 集合（各不相同的元素）</li>
<li>hash hash散列值（hash的key必须是唯一的）</li>
<li>sort set 有序集合</li>
</ul>
<h2 id="Redis-支持的-Java-客户端都有哪些？"><a href="#Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？"></a>Redis 支持的 Java 客户端都有哪些？</h2><p>Redis Desktop Manager 、Redis Client、Redis Studio、jedis</p>
<h2 id="Jedis-和-Redisson-有哪些区别？"><a href="#Jedis-和-Redisson-有哪些区别？" class="headerlink" title="Jedis 和 Redisson 有哪些区别？"></a>Jedis 和 Redisson 有哪些区别？</h2><p>Jedis 是 Redis的 java 实现客户端，其 API 提供了比较全面的 Redis 命令的支持；Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务‘管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h2 id="怎么保证缓存和数据库数据的一致性？"><a href="#怎么保证缓存和数据库数据的一致性？" class="headerlink" title="怎么保证缓存和数据库数据的一致性？"></a>怎么保证缓存和数据库数据的一致性？</h2><ul>
<li>延时双删</li>
<li>binLog 和消息队列</li>
</ul>
<h2 id="Redis-持久化方式"><a href="#Redis-持久化方式" class="headerlink" title="Redis 持久化方式"></a>Redis 持久化方式</h2><ul>
<li>RDB 快照的方式：直接使用快照将数据定时写入磁盘当中，数据量大具有优势。</li>
<li>AOF 方式：存储redis操作日志进行存储数据，方便数据的复现。</li>
</ul>
<h2 id="Redis-分布式锁有什么缺陷？"><a href="#Redis-分布式锁有什么缺陷？" class="headerlink" title="Redis 分布式锁有什么缺陷？"></a>Redis 分布式锁有什么缺陷？</h2><p>在工作和网络上看到过各个版本的Redis分布式锁实现，每种实现都有一些不严谨的地方，甚至有可能是错误的实现，包括在代码中，如果不能正确的使用分布式锁，可能造成严重的生产环境故障。</p>
<p>redis分布式锁的缺陷</p>
<p>传送门： <a target="_blank" rel="noopener" href="https://blog.csdn.net/matt8/article/details/64442064">https://blog.csdn.net/matt8/article/details/64442064</a></p>
<h2 id="Redis-淘汰策略有哪些？"><a href="#Redis-淘汰策略有哪些？" class="headerlink" title="Redis 淘汰策略有哪些？"></a>Redis 淘汰策略有哪些？</h2><p>redis 提供 8 种数据淘汰策略：</p>
<ul>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰（最常用）</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-enviction（驱逐）：禁止驱逐数据，写入报错</li>
<li>volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li>
<li>allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ul>
<h2 id="Redis-常见的性能问题有哪些？该如何解决？"><a href="#Redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="Redis 常见的性能问题有哪些？该如何解决？"></a>Redis 常见的性能问题有哪些？该如何解决？</h2><ol>
<li><p>master 写内存快照，save 命令调度 rdbsave 函数，会阻塞主线程的工程，当快照比较大的时候对性能的影响是非常大的，会间断性暂停服务 。所以 master 最好不要写内存快照。</p>
</li>
<li><p>master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响 master重启时的恢复速度。master 最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化，如果数据比较关键，某个 slave 开启 AOF 备份数据，策略每秒为同步一次。 </p>
</li>
<li><p>master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂的服务暂停现象。</p>
</li>
<li><p>redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，slave 和 master 最好在同一个局域网内。</p>
</li>
</ol>
<h2 id="Redis-和-Mysql-数据库数据如何保持一致性"><a href="#Redis-和-Mysql-数据库数据如何保持一致性" class="headerlink" title="Redis 和 Mysql 数据库数据如何保持一致性"></a>Redis 和 Mysql 数据库数据如何保持一致性</h2><ul>
<li><p>主要采用策略是延迟双删</p>
</li>
<li><p>参考文献：<a target="_blank" rel="noopener" href="https://www.51cto.com/article/701851.html">https://www.51cto.com/article/701851.html</a></p>
</li>
</ul>
<h2 id="Redisson-分布式锁（单机）"><a href="#Redisson-分布式锁（单机）" class="headerlink" title="Redisson 分布式锁（单机）"></a>Redisson 分布式锁（单机）</h2><p>下图的意思就是可重入锁的机制，它最大的优点就是相同线程不需要在等待锁，而是可以直接进行相应操作。</p>
<p><img src="/2021/06/08/Redis/20220302220718.png" srcset="/img/loading.gif" lazyload alt="Redisson 分布式锁（单机）"></p>
<p>Redis分布式锁会有个缺陷，就是在 Redis 哨兵模式下:</p>
<p><code>客户端1</code>对某个 <code>master节点</code>写入了 redisson 锁，此时会异步复制给对应的 slave 节点。但是这个过程中一旦发生 master 节点宕机，主备切换，slave 节点从变为了 master 节点。这时 <code>客户端2</code>来尝试加锁的时候，在新的 master 节点上也能加锁，此时就会导致多个客户端对同一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题， <strong>导致各种脏数据的产生</strong> 。</p>
<p><code>缺陷</code>在哨兵模式或者主从模式下，如果 master 实例宕机的时候，可能导致多个客户端同时完成加锁。</p>
<h2 id="RedLock分布式锁（多机版本）"><a href="#RedLock分布式锁（多机版本）" class="headerlink" title="RedLock分布式锁（多机版本）"></a>RedLock分布式锁（多机版本）</h2><p>现在假设有5个 Redis 主节点（<strong>大于3的奇数个</strong>），这样基本保证他们不会同时都宕掉，获取锁和释放锁的过程中，客户端会执行以下操作：</p>
<ul>
<li><p>1.获取当前 Unix 时间，以毫秒为单位；</p>
</li>
<li><p>2.依次尝试从5个实例，使用相同的 key 和具有唯一性的 value 获取锁；<br>当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间，这样可以避免客户端死等；</p>
</li>
<li><p>3.客户端使用当前时间减去开始获取锁时间就得到获取锁使用的时间。当且仅当从半数以上的 Redis 节点取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功；</p>
</li>
<li><p>4.如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间，这个很重要；</p>
</li>
<li><p>5.如果因为某些原因，获取锁失败（没有在半数以上实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁，无论 Redis 实例是否加锁成功，因为可能服务端响应消息丢失了但是实际成功了，毕竟多释放一次也不会有问题。</p>
</li>
</ul>
<h2 id="Redis-可以做消息队列么？"><a href="#Redis-可以做消息队列么？" class="headerlink" title="Redis 可以做消息队列么？"></a>Redis 可以做消息队列么？</h2><p>Redis 5.0 新增加的一个数据结构 <code>Stream</code> 可以用来做消息队列，<code>Stream</code> 支持：</p>
<ul>
<li>发布 / 订阅模式</li>
<li>按照消费者组进行消费</li>
<li>消息持久化（ RDB 和 AOF）</li>
</ul>
<p>不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</p>
<p>我们通常建议是不需要使用 Redis 来做消息队列的，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p>
<p>相关文章推荐：<a target="_blank" rel="noopener" href="https://javakeeper.starfish.ink/data-management/Redis/Redis-MQ.html">Redis 消息队列的三种方案（List、Streams、Pub/Sub）</a></p>
<h2 id="Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复"><a href="#Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)"></a>Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</h2><p><strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。</p>
<p><strong>快照（snapshotting）持久化（RDB）</strong></p>
<p>Redis 可以通过<strong>创建快照来获得存储在内存里面的数据在某个时间点上的副本</strong>。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>           #在<span class="hljs-number">900</span>秒(<span class="hljs-number">15</span>分钟)之后，如果至少有<span class="hljs-number">1</span>个key发生变化，Redis就会自动触发BGSAVE命令创建快照。<br><br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span>          #在<span class="hljs-number">300</span>秒(<span class="hljs-number">5</span>分钟)之后，如果至少有<span class="hljs-number">10</span>个key发生变化，Redis就会自动触发BGSAVE命令创建快照。<br><br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span>        #在<span class="hljs-number">60</span>秒(<span class="hljs-number">1</span>分钟)之后，如果至少有<span class="hljs-number">10000</span>个key发生变化，Redis就会自动触发BGSAVE命令创建快照。<br></code></pre></div></td></tr></table></figure>
<p><strong>AOF（append-only file）持久化</strong></p>
<p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启。</p>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">appendfsync</span> always    <span class="hljs-comment">#每次有数据修改发生时都会写入AOF文件，这样会严重降低Redis的速度</span><br>appendfsync everysec  <span class="hljs-comment">#每秒钟同步一次，显式地将多个写命令同步到硬盘 （推荐）</span><br>appendfsync <span class="hljs-literal">no</span>        <span class="hljs-comment">#让操作系统决定何时进行同步</span><br></code></pre></div></td></tr></table></figure>
<p><strong>拓展：Redis 4.0 对于持久化机制的优化</strong></p>
<p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<h2 id="3种常用的缓存读写策略"><a href="#3种常用的缓存读写策略" class="headerlink" title="3种常用的缓存读写策略"></a>3种常用的缓存读写策略</h2><ul>
<li><p><strong>Cache Aside Pattern（旁路缓存模式）</strong></p>
<p>写：</p>
<ol>
<li><p>先更新 DB</p>
</li>
<li><p>然后直接删除 cache </p>
</li>
</ol>
<p><strong>若改变顺序会导致数据库缓存数据不一致的问题。</strong></p>
<p>读：</p>
<ol>
<li><p>从 cache 中读取数据，读取到就直接返回</p>
</li>
<li><p>cache中读取不到的话，就从 DB 中读取数据返回</p>
</li>
<li><p>再把数据放到 cache 中</p>
</li>
</ol>
<p>缺陷：</p>
<ol>
<li>首次请求数据一定不在 cache</li>
<li>写操作比较频繁的话导致 cache 中的数据会被频繁删除，这样会影响缓存命中率</li>
</ol>
<p>解决：</p>
<ol>
<li>可以将热点数据可以提前放入 cache 中。</li>
<li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题</li>
</ol>
</li>
<li><p><strong>Read/Write Through Pattern（读写穿透）</strong></p>
<p>服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。这种策略非常少见， Redis 也没有提供 cache 将数据写入DB的功能。</p>
<p>写：</p>
<ol>
<li>先查 cache，cache 中不存在，直接更新 DB</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）</li>
</ol>
<p>读：</p>
<ol>
<li>从 cache 中读取数据，读取到就直接返回 </li>
<li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应</li>
</ol>
</li>
<li><p><strong>Write Behind Pattern（异步缓存写入）</strong></p>
<p>与读写穿透相似都是由 cache 服务来负责和 DB 的读写。</p>
<p>不同是<strong>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p>
<p>这种策略在我们平时开发过程中也非常少见</p>
</li>
</ul>
<h2 id="本地缓存与-Redis-缓存的区别"><a href="#本地缓存与-Redis-缓存的区别" class="headerlink" title="本地缓存与 Redis 缓存的区别"></a>本地缓存与 Redis 缓存的区别</h2><ol>
<li>读写速度，不考虑并发，本地缓存自然是最快的。</li>
<li>redis 内存可能 n 多扩充，而本地扩大堆内存代价是很大的。</li>
<li>本地缓存需要自己实现过期功能，实现不好可能导致极其严重的后果，而redis经过大量的流量验证，许多漏洞无需考试，安全。</li>
<li>本地缓存无法提供丰富的数据结构，redis可以。redis可以写磁盘，持久化，本地缓存不可以或者说很麻烦要考虑的东西太多。</li>
<li>使用本地缓存极有可能导致严重的线程安全问题，并发考虑严重。</li>
</ol>
<h2 id="Redis-为什么这么快"><a href="#Redis-为什么这么快" class="headerlink" title="Redis 为什么这么快"></a>Redis 为什么这么快</h2><p>根据官方数据，Redis 的 QPS 可以达到约 100000（每秒请求数）。</p>
<ol>
<li><p>Redis 是基于内存的数据库，跟磁盘数据库相比，完全吊打磁盘的速度</p>
</li>
<li><p>高效的数据结构</p>
<p><img src="/2021/06/08/Redis/20220320140044.jpg" srcset="/img/loading.gif" lazyload alt="数据结构"></p>
</li>
<li><p>采用 I/O 多路复用技术，并发处理连接。采用了 epoll + 自己实现的简单的事件框架。</p>
</li>
</ol>
<p><strong>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1S54y1R7SB">狂神说</a></strong></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java%E5%90%8E%E7%AB%AF/">Java后端</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/redis/">redis</a>
                    
                      <a class="hover-with-bg" href="/tags/linux/">linux</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/12/Heap/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">堆</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/05/12/EsDeploy/">
                        <span class="hidden-mobile">Docker部署elasticsearch</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"RxykbovtXvEzAt8OUVAS1CqX-gzGzoHsz","appKey":"xjP4U0FLblVtlDA1XXAP2906","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://rxykbovt.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"requiredFields":[]},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  <div>
    <span id="timeDate">载入天数...</span>
    <span id="times">载入时分秒...</span>
    <script>
    var now = new Date();
    function createtime(){
        var grt= new Date("4/5/2021 12:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){
            hnum = "0" + hnum;
        }
        minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if(String(mnum).length ==1 ){
                  mnum = "0" + mnum;
        }
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if(String(snum).length ==1 ){
                  snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = "本站已经运行&nbsp"+dnum+"&nbsp天";
        document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
    }
    setInterval("createtime()",250);
    </script>
  </div>  
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


  <!-- 页面点击小红心 -->
  
    <script type="text/javascript" src="/js/clicklove.js"></script>
  
  
  <!-- 雪花特效-->
  
    <script type="text/javascript" src="/js/snow.js"></script>
  

  <!--彩带1.点击自动替换彩带-->
  
    <script type="text/javascript" src="/js/ribbon.js"></script>
  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
