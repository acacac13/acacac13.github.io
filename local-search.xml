<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ddd 学习</title>
    <link href="/2022/06/23/ddd/"/>
    <url>/2022/06/23/ddd/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>DDD 全称是（Domain-Driven Desgin，简称 DDD），领域驱动设计。</p><h1 id="为什么要学习-DDD-领域驱动设计？"><a href="#为什么要学习-DDD-领域驱动设计？" class="headerlink" title="为什么要学习 DDD 领域驱动设计？"></a>为什么要学习 DDD 领域驱动设计？</h1><p>在早期软件开发，对于一些简单业务，只需要使用一个模块，编写多个业务逻辑就可以搞定。但是随着业务增长，当需要修改其中某一项功能，则修改困难，原因是该功能可能会侵蚀其他代码模块。修改需要谨慎，投入时间成本，人力成本过高。DDD 模型可以很好的解决这个问题。</p><h1 id="DDD-模型解决了什么问题？"><a href="#DDD-模型解决了什么问题？" class="headerlink" title="DDD 模型解决了什么问题？"></a>DDD 模型解决了什么问题？</h1><p>粒度更小，架构更加清晰，业务需求变化的时候，系统架构也能随之变化。DDD 所呈现的系统必然是高内聚，低耦合的，在业务系统中，不会因为修改 A 模块影响到了 B 模块的使用。</p><h2 id="过度耦合"><a href="#过度耦合" class="headerlink" title="过度耦合"></a>过度耦合</h2><p>在系统创建初期，业务初期，功能对于基础设计都非常简单，普通的 CRUD 就可以满足业务需要，但是随着系统的迭代，业务逻辑变得复杂，此时系统的冗余程度也会随之增加。此时需要修改其中的某个节点的逻辑，可能伴随着影响到其他模块的业务逻辑。此问题的根源出现在系统架构不清晰，划分出来的模块内聚度低，高耦合。</p><p>有一种解决方案，按照演进式设计的理论，让系统的设计随着系统的实现增长而增长。不需要提前设计，就让系统伴随业务成长而演进。敏捷实践中的重构、测试驱动设计及持续集成可以对付各种混乱问题。</p><p>事实上，在解决现实问题的时候，我们会将问题映射到脑海中的概念模型，在模型中解决问题，再将解决方案转换为实际的代码。上述问题在于我们解决了设计到代码之间的重构，但提炼出来的设计模型，并不具有实际的业务含义，这就导致在开发需求的时候，其他同学不能自然的将业务问题映射到该设计模型。并不具有实际的业务含义。</p><p>用 DDD 则可以很好的解决领域驱动模型到设计模型的同步、演化，最后再将反映了领域的设计模型转为实际的代码。</p><h2 id="贫血症和失忆症"><a href="#贫血症和失忆症" class="headerlink" title="贫血症和失忆症"></a>贫血症和失忆症</h2><p>贫血领域对象：贫血领域对象（Academic Domain Object）是指仅用做数据载体，而没有行为和动作的领域对象。</p><ul><li>场景需求</li></ul><p>奖池中配置了很多奖项，我们需要按运营预先配置的概率抽中一个奖项。实现非常简单，生成一个随机数，匹配符合该随机数生成概率的奖项即可。</p><ul><li>贫血模型实现方案</li></ul><p>先设计奖池和奖项的库 2张数据库表</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwardPool</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> awardPoolId;<br>    List&lt;Award&gt; awards;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Award&gt; <span class="hljs-title">getAwards</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> awards;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAwards</span><span class="hljs-params">(List&lt;Award&gt; awards)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.awards = awards;<br>    &#125;<br>    ......<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Award</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> awardId;<br>   <span class="hljs-keyword">int</span> probability;<span class="hljs-comment">//概率</span><br><br>   ......<br>&#125;<br><br><span class="hljs-comment">// Service的实现</span><br>AwardPool awardPool = awardPoolDao.getAwardPool(poolId);<span class="hljs-comment">//sql查询，将数据映射到AwardPool对象</span><br><span class="hljs-keyword">for</span> (Award award : awardPool.getAwards()) &#123;<br>   <span class="hljs-comment">//寻找到符合award.getProbability()概率的award</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>按照传统开发思想可以发现，我们的业务逻辑都是在 Service 中去编写的，Award 只是一个数据载体，没有任何行为。简单的业务系统采用这种贫血模型和过程化设计是没有问题的，但是业务逻辑一旦复杂了，业务逻辑状态会散落在大量的方法中，原本的代码意图会渐渐不明确，我们将这种情况称为由贫血引起的<strong>失忆症</strong>。</p><p>更好的是采用领域模型的开发方式，将数据和行为封装在一起，并与现实世界中的业务对象映射。各类具备明确的职责划分，将领域逻辑分散到领域对象中。按照这种思想，上述的例子就应该把概率放在 AwardPool 中。</p><h1 id="DDD-相比-MVC"><a href="#DDD-相比-MVC" class="headerlink" title="DDD 相比 MVC"></a>DDD 相比 MVC</h1><p><img src="file:///Users/aocan/Desktop/code/acacac13.github.io/source/_posts/ddd/bj-ea220c42c286a9495b6d0123f4807b25b7d4abec.png" title alt data-align="center"></p><ol><li><p><strong>用户接口层</strong> 用户接口层负责向用户显示信息和解释用户指令。</p></li><li><p><strong>应用层</strong> 应用层是很薄的一层，理论上不应该由业务规则或逻辑，主要面向用例和流程相关的操作。也可以完成编排多个聚合服务和领域对象完成业务操作；调用其他微服务的应用服务，完成微服务之间服务的组合和编排。<br>应用服务是在应用层的，它负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装，以粗粒度的服务通过 API 网关向前端发布。还有，应用服务还可以进行安全认证、权限校验、事务控制、发送或订阅领域事件等。</p></li><li><p><strong>领域层（domain层）</strong> 领域层的作用是<strong>实现企业核心业务逻辑</strong>，通过各种校验手段保证业务的正确性。领域层主要体现领域模型的业务能力，它用来表达业务概念，业务状态和业务规则；领域层包含聚合根，实体，值对象。领域服务等领域模型中的领域对象；领域模型的业务逻辑主要是由实体和领域服务来实现的。</p><p><strong>实体会采用充血模型来实现所有与之相关的业务功能。</strong> 实体和领域对象在实现业务逻辑上是同级的，当领域中的某些功能，单一实体（或者值对象）不能实现时，领域服务就会出马他可以组合聚合内的多个实体（或者值对象），实现复杂的业务逻辑。</p></li><li><p><strong>基础层（Repository）</strong> 基础层是贯穿所有层的，它的作用就是为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等。比较常见的功能还是提供数据库持久化。</p><p>基础层包含基础服务，它采用依赖倒置设计，封装基础资源服务，实现应用层、领域层与基础层的解耦，降低外部资源变化对应用的影响。</p><p>比如说，在传统架构设计中，由于上层应用对数据库的强耦合，很多公司在架构演进中最担忧的可能就是换数据库了，因为一旦更换数据库，就可能需要重写大部分的代码，这对应用来说是致命的。那采用依赖倒置的设计以后，应用层就可以通过解耦来保持独立的核心业务逻辑。当数据库变更时，我们只需要更换数据库基础服务就可以了，这样就将资源变更对应用的影响降到了最低。</p></li></ol><h1 id="设计领域模型的一般步骤"><a href="#设计领域模型的一般步骤" class="headerlink" title="设计领域模型的一般步骤"></a>设计领域模型的一般步骤</h1><ol><li>根据需求划分出初步的领域和限界上下文，以及上下文之间的关系；</li><li>进一步分析每个上下文内部，识别出哪些是实体，哪些是值对象</li><li>对实体、值对象进行关联聚合，划分出聚合的范畴和聚合根</li><li>为聚合根设计仓储，并思考实体或值对象的创建方式</li><li>在工程中实践领域模型，并且在实践中检验模型的合理性，倒推模型中的不足的地方并重构</li></ol><h1 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h1><p>贫血模型定义对象的简单的属性值，没有业务逻辑上的方法。将“行为”和“状态”分离到不用的对象中。</p><ul><li><p>“行为”：逻辑、过程</p></li><li><p>“状态”：数据，对应到语言就是对象成员变量</p></li><li><p>只有状态的对象就是所谓的“贫血对象”（常称为 VO）</p></li><li><p>只有行为的对象就是，我们常见的N层结构中的 Logic/Service/Manager 层</p></li></ul><p>贫血领域模型是一个存在已久的反模式。</p><p><img src="https://pic2.zhimg.com/v2-75522d954d602361789e16497e519739_r.jpg" title alt="preview" data-align="center"></p><p>贫血领域模型的基本特征是第一眼看起来还真像这么回事。项目中有许多对象，他们的命名都是根据领域来的。对象之间有着丰富的连接方式，和真正的领域模型非常相似。而且这些对象基本没有任何行为，仅仅是一堆 getter/setter。</p><p>其实这些对象在设计之初就被定义为只能包含数据，不能加入领域逻辑；逻辑要全部写入 Service 的对象中，而 Service 则构建在领域模型上，需要使用这些模型来传递数据。</p><p>面向对象设计主张将数据和行为绑定在一起，而贫血领域模型则更像是一种面向过程设计，如今，面向对象的概念已经传播的很广泛了，而要反对这种贫血领域模型的做法，还需要更多论据。贫血领域模型的根本问题是，它引入了领域模型设计的所有成本，却没有带来任何好处。最主要的成本是将对象映射到数据库中，从而产生了一个 O/R（对象关系）映射层。</p><p>只有当充分使用了面向对象设计来组织复杂的业务逻辑后，这一成本才能够被抵消。如果将所有行为都写入到 Service 对象，那最终就会得到一组事务脚本，从而错过了领域模型带来的好处。</p><p>将行为放入领域模型，这点和分层设计（领域层、持久层、展现层等）并不冲突。因为领域模型中放入的是和领域相关的逻辑—验证、计算、业务规则等。一些面向对象专家的观点有时会让人产生疑惑，他们认为的确应该有一个面向过程的服务层。但是这并不意味着领域模型就不应该包含行为。事实上，service 层需要和一组富含行为的领域模型结合使用。</p><h2 id="应用层（即-Service-层）"><a href="#应用层（即-Service-层）" class="headerlink" title="应用层（即 Service 层）"></a>应用层（即 Service 层）</h2><p>描述应用程序所要做的工作，并调度丰富的领域模型来完成它。这个层次的任务是描述业务逻辑，或和其它项目的应用层做交互。这层很薄，不包含任何业务规则或知识，仅用于调度和派发任务给下一层的领域模型。这层没有业务状态，但可以为用户或程序提供任务状态。</p><h2 id="领域层（或者叫模型层）"><a href="#领域层（或者叫模型层）" class="headerlink" title="领域层（或者叫模型层）"></a>领域层（或者叫模型层）</h2><p>表示业务逻辑、业务场景和规则。该层次会控制和使用业务状态，即使这些状态最终会交由持久层来存储。总之，该层是软件核心。</p><p>服务层很薄—所有重要的业务逻辑都写在领域层。他在服务模式中复述了这一观点：如今人们常犯的错误是不愿花时间将业务逻辑放到合适的领域模型中，从而逐渐形成面向过程的程序设计。</p><h1 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a>充血模型</h1><p>面向对象设计的本质是：“一个对象是拥有状态和行为的”。</p><p>比如一个人：</p><ul><li><p>他眼睛什么样鼻子怎么样这就是状态</p></li><li><p>人可以去打游戏或是写程序，这就是行为</p></li></ul><p>为什么需要由一个“人 Manager”这样的东西存在去帮人“打游戏”呢？举个简单的 J2EE 案例，设计一个用户（User）相关功能。</p><p>传统设计一般是：</p><ul><li><p>类：User + UserManager</p></li><li><p>保存用户调用：<code>userManager.save(User user)</code></p></li></ul><p>充血的设计则可能会是：</p><ul><li><p>类：User</p></li><li><p>保存用户调用：<code>user.save()</code></p></li><li><p>User 有一个行为是：保存它自己</p></li></ul><p>OOP 总是比面向过程的编程有更丰富的语义、更合理的组织、更强的可维护性，当然也更难掌握。</p><p>在实际工程场景中使用充血模型还有很多细节问题，其中最大的难关就是”如何设计充血模型“或者说”如何从复杂的业务中分离出恰到好处且包含予以的逻辑放到 VO 的行为中“。如果一个对象包含其他对象，那就将职责继续委托下去，由具体的 POJO 执行业务逻辑，将策略模式更加细粒度，而不是写 <code>ifelse</code>。</p><h1 id="DDD-与充血模型的关系"><a href="#DDD-与充血模型的关系" class="headerlink" title="DDD 与充血模型的关系"></a>DDD 与充血模型的关系</h1><p>我们在平时进行web开发的时候，就是定义DTO，定义数据库Model，BO等，对其进行get set方法，然后通过service 对Bo对象进行操作，最后通过copy属性持久化数据库和DTO传输。但是如果是充血模型的话，就不用在service进行属性赋值，而是在创建这个对象的时候，进行业务操作，赋予其属性值。这里也就是DDD的思想，这个对象也就是DDD所定义的Entity 或者 value 。Service也就是domianService，由多个Entity 和value 组成，构造最终的领域模型。</p><p><img src="https://pic1.zhimg.com/v2-2bc4c559fad595f71016f2097c15cb8c_r.jpg" title alt="preview" data-align="center"></p><h1 id="传统架构对比-DDD"><a href="#传统架构对比-DDD" class="headerlink" title="传统架构对比 DDD"></a>传统架构对比 DDD</h1><p>软件架构模式发展到现在可以主要经历了三个阶段：UI + DataBase的两层架构、UI + Service + DataBase的多层SOA架构、分布式微服务架构。</p><h2 id="传统架构的缺点"><a href="#传统架构的缺点" class="headerlink" title="传统架构的缺点"></a>传统架构的缺点</h2><p>在前两种架构中，系统分析、设计和开发往往是独立、分阶段割裂进行的。</p><ol><li><p>两层架构是面向发数据库的架构，根本没有灵活性。</p></li><li><p>微服务盛行的今天，多层 SOA 架构已经完全不能满足微服务架构应用的需求，它存在一些问题</p></li></ol><ul><li><p>臃肿的 Service</p></li><li><p>三层分层后文件的随意组装方式</p></li><li><p>技术导向分层，导致业务分离，不能快速定位</p></li></ul><h1 id="DDD-领域驱动"><a href="#DDD-领域驱动" class="headerlink" title="DDD 领域驱动"></a>DDD 领域驱动</h1><p>虽说分布式微服务有这么好的优点，但也不是适合所有的系统，而且也会有许多问题。</p><p>微服务的粒度应该多大呀？微服务到底应该如何拆分和设计呢？微服务的边界应该在哪里？这些都是微服务设计要解决的问题，但是很久以来都没有一套系统的理论和方法可以指导微服务的拆分，综合来看，我认为微服务拆分困境产生的根本原因就是不知道业务或者微服务的边界到底在什么地方。换句话说，确定了业务边界和应用边界，这个困境也就迎刃而解了。</p><p><strong>DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性。</strong></p><p>领域驱动设计是一种以<strong>业务</strong>为导向的软件设计方法和思路。我们在开发前，通常需要进行大量的业务知识梳理，而后到达软件设计的层面，最后才是开发。而在业务知识梳理的过程中，我们必然会形成某个领域知识，根据领域知识来一步步驱动软件设计，就是领域驱动设计的基本概念。而领域驱动设计的核心就在于建立正确的领域驱动模型。</p><h2 id="DDD-包括战略设计和战术设计两部分"><a href="#DDD-包括战略设计和战术设计两部分" class="headerlink" title="DDD 包括战略设计和战术设计两部分"></a>DDD 包括战略设计和战术设计两部分</h2><p><strong>战略设计</strong>主要从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的限界上下文，限界上下文可以作为微服务设计的参考边界。</p><p><strong>战术设计</strong>则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码扩及的设计和实现。</p><p>战略设计时构建的领域模型，是微服务设计和开发的输入，它确定了微服务的边界、聚合、代码对象以及服务等关键领域对象。领域模型边界划分得请不清晰，领域对象定义得名不明确，会决定微服务的设计和开发质量。没有领域模型的输入，基于 DDD 的微服务的设计和开发将无从谈起。因此我们不仅需要重视战术设计，更要重视战略设计。</p><h1 id="DDD-的优势"><a href="#DDD-的优势" class="headerlink" title="DDD 的优势"></a>DDD 的优势</h1><ol><li>接触到需求第一步就是考虑领域模型，而不是将其切割成数据和行为，然后数据用数据库实现，行为使用服务实现，最后造成需求的首肢分离。DDD让你首先考虑的是业务语言，而不是数据。重点不同导致编程世界观不同。</li><li>DDD可以更加领域模型界限上下文边界快速拆分微服务，实现系统架构适应业务的快速变化，例如：系统的用户量并发量增长得很快，单体应用很快就支持不了，如果我们一开始就采用DDD领域驱动设计，那我们就能很快的把服务拆分成多个微服务，以适应快速增长的用户量。</li><li>DDD 是一套完整而系统的设计方法，它能带给你从战略设计到战术设计的标准设计过程，使得你的设计思路能够更加清晰，设计过程更加规范。</li><li>使用DDD可以降低服务的耦合性，让系统设计更加规范，即使是刚加入团队的新人也可以根据业务快速找到对应的代码模块，降低维护成本。</li><li>DDD 善于处理与领域相关的拥有高复杂度业务的产品开发，通过它可以建立一个核心而稳定的领域模型，有利于领域知识的传递与传承。</li><li>DDD 强调团队与领域专家的合作，能够帮助你的团队建立一个沟通良好的氛围，构建一致的架构体系。</li><li>DDD 的设计思想、原则与模式有助于提高你的架构设计能力。</li><li>无论是在新项目中设计微服务，还是将系统从单体架构演进到微服务，都可以遵循 DDD 的架构原则。</li></ol><h1 id="DDD-设计原则"><a href="#DDD-设计原则" class="headerlink" title="DDD 设计原则"></a>DDD 设计原则</h1><ol><li>要领域驱动设计，而不是数据驱动设计，也不是界面驱动设计。</li><li>要边界清晰的微服务，而不是泥球小单体。</li><li>要职能清晰的分层，而不是什么都放的大箩筐。</li><li>要做自己能 hold 住的微服务，而不是过度拆分的微服务。</li></ol><h1 id="微服务拆分需要考虑哪些元素？"><a href="#微服务拆分需要考虑哪些元素？" class="headerlink" title="微服务拆分需要考虑哪些元素？"></a>微服务拆分需要考虑哪些元素？</h1><p>理论上一个限界上下文内的领域模型可以被设计为微服务，但是由于领域建模主要从业务视角出发，没有考虑非业务因素，比如需求变更频率、高性能、安全、团队以及技术异构等因素，而这些非业务因素对于领域模型的系统落地也会起到决定性作用，因此在微服务拆分时我们需要重点考虑它们。</p><p><strong>基于领域模型</strong></p><ul><li>基于领域模型进行拆分，围绕业务领域按职责单一性、功能完整性拆分。</li></ul><p><strong>基于业务需求变化频率</strong></p><ul><li>识别领域模型中的业务需求变动频繁的功能，考虑业务变更频率与相关度，将业务需求变动较高和功能相对稳定的业务进行分离。这是因为需求的经常性变动必然会导致代码的频繁修改和版本发布，这种分离可以有效降低频繁变动的敏态业务对稳态业务的影响。</li></ul><p><strong>基于应用性能</strong></p><ul><li>识别领域模型中性能压力较大的功能。因为性能要求高的功能可能会拖累其它功能，在资源要求上也会有区别，为了避免对整体性能和资源的影响，我们可以把在性能方面有较高要求的功能拆分出去。</li></ul><p><strong>基于组织架构和团队规模</strong></p><ul><li>除非有意识地优化组织架构，否则微服务的拆分应尽量避免带来团队和组织架构的调整，避免由于功能的重新划分，而增加大量且不必要的团队之间的沟通成本。拆分后的微服务项目团队规模保持在 10～12 人左右为宜。</li></ul><p><strong>基于安全边界</strong></p><ul><li>有特殊安全要求的功能，应从领域模型中拆分独立，避免相互影响。</li></ul><p><strong>基于技术异构</strong></p><ul><li>领域模型中有些功能虽然在同一个业务域内，但在技术实现时可能会存在较大的差异，也就是说领域模型内部不同的功能存在技术异构的问题。由于业务场景或者技术条件的限制，有的可能用.NET，有的则是 Java，有的甚至大数据架构。对于这些存在技术异构的功能，可以考虑按照技术边界进行拆分。</li></ul><h1 id="CQRS-架构"><a href="#CQRS-架构" class="headerlink" title="CQRS 架构"></a>CQRS 架构</h1><p>核心思想是将应用程序的<strong>查询</strong>部分和<strong>命令</strong>部分完全隔离，这两部分可以用完全不同的模型和技术去实现。比如命令部分可以通过领域驱动设计来实现；查询部分可以直接用最快的非面向对象的方式去实现，比如用 SQL。这样的思想有很多好处：</p><ol><li><p>实现命令部分的领域模型不用经常为了领域对象可能会被如何查询而做一些折中处理；</p></li><li><p>由于命令和查询是隔离开的，所以这两部分可以用不同的技术架构实现，包括数据库设计都可以分开设计，每一部分可以充分发挥其长处；</p></li><li><p>高性能，命令端因为没有返回值，可以像消息队列一样接受命令，放在队列中，慢慢处理；处理完后，可以通过异步的方式通知查询端，这样查询端可以做数据同步的处理。</p></li></ol><h1 id="Event-Sourcing（事件溯源）"><a href="#Event-Sourcing（事件溯源）" class="headerlink" title="Event Sourcing（事件溯源）"></a>Event Sourcing（事件溯源）</h1><p>对于 ddd 中的聚合，不保存聚合的当前状态，而是保存对象上发生的每个事件。当要重建一个聚合对象时，可以通过这些事件（即让这些事件重新发生）来让对象恢复到某个特定的状态；因为有时一个聚合可能会发生很多事件，所以每次要在重建对象时都从头回溯事件，会导致性能低下，所以我们会在一定的时候为聚合创建一个快照。</p><h1 id="四色模型"><a href="#四色模型" class="headerlink" title="四色模型"></a>四色模型</h1><ul><li><p>时刻-时间段原型（Moment-Interval Archetype）</p><p>表示在某个时刻或某一段时间内发生的某个活动。使用粉色表示，简写为 MI。</p></li><li><p>参与方-地点-物品原型（Part-Place-Thing Archetype）</p><p>表示参与某个活动的人或物，地点则是活动的发生地。使用绿色表示。简写为 PPT。</p></li><li><p>描述原型（Description Archetype）</p><p>表示对 PPT 的本质描述，不是 PPT 的分类。使用蓝色表示，简写为 DESC。</p></li><li><p>角色原型（Role Archetype）</p><p>角色就是我们平时所理解的“身份”。使用黄色表示，简写为 Role。</p></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="1-应用服务和领域服务的区别？为什么需要应用层来连接领域层和接口层？"><a href="#1-应用服务和领域服务的区别？为什么需要应用层来连接领域层和接口层？" class="headerlink" title="1. 应用服务和领域服务的区别？为什么需要应用层来连接领域层和接口层？"></a>1. 应用服务和领域服务的区别？为什么需要应用层来连接领域层和接口层？</h2><p><strong>应用服务</strong></p><p>应用服务负责组织业务场景，编排业务。它将要实现的功能委托给一个或多个领域对象来实现，它本身只负责处理业务用例的执行顺序以及结果的拼装。通过这样一种方式，它隐藏了领域层的复杂性及其内部实现机制，隔离场景对领域层的差异。</p><p>应用层相对来说是较“薄”的一层，除了定义应用服务之外，在该层我们可以进行安全认证，权限校验，持久化事务控制，或者向其他系统发生基于事件的消息通知，另外还可以用于创建邮件以发送给客户等。</p><p><strong>领域服务</strong></p><p>领域服务是用来协调领域对象完成某个操作，用来处理业务逻辑的，它本身是一个行为，所以是无状态的。状态由领域对象（具有状态和行为）保存。</p><p>一般来说，在下面的几种情况下，我们可以使用领域服务：</p><ul><li>执行一个显著的业务操作过程</li><li>对领域对象进行转换</li><li>以多个领域对象为输入，返回一个值对象。</li></ul><p><strong>为什么需要应用层？</strong></p><p>应用层作为用户接口层与领域层的桥梁。用户接口层与应用层通过DTO（数据传输对象）进行数据交互，从而达到展现层与DO（领域对象）解耦的目的。</p><p>如果没有应用层，导致领域服务和场景绑定，复用性大大降低。例如系统接受用户自己注册，也可以使用微信登录完成一个隐藏的用户注册。另外一个例子，对于新用户，系统会为他赠送一些积分，在没有应用层的情况下，服务被前端直接调用，于是服务不得不定义来自不同渠道的 API。随着对接的业务越来越多，微服务中的代码的分支条件越来越多。所以需要你添加一层来隔离差异。</p><p>应用层和领域层的定位：</p><blockquote><p>领域层，实现具体的业务逻辑、规则，为应用层提供无差别的服务能力。<br>应用层，组织业务场景，编排业务，隔离场景对领域层的差异。</p></blockquote><h2 id="2-基础设施层能直接调用领域层的对象吗？"><a href="#2-基础设施层能直接调用领域层的对象吗？" class="headerlink" title="2. 基础设施层能直接调用领域层的对象吗？"></a>2. 基础设施层能直接调用领域层的对象吗？</h2><p>基础设施层能直接调用领域层的对象，因为依赖倒置了，基础设施层与领域层依赖于相同的抽象接口，但领域层不能使用基础设施层的对象。</p><h2 id="3-dao和Repository（资源库）有什么区别？"><a href="#3-dao和Repository（资源库）有什么区别？" class="headerlink" title="3. dao和Repository（资源库）有什么区别？"></a>3. dao和Repository（资源库）有什么区别？</h2><p>dao 是 Data Access Object 的缩写，是一种结构型设计模式，用于分离业务层（应用）和持久化层（数据库）。dao 模式是一种分层的思想，这层就是用于处理和数据库交互（CRUD），而业务层不需要知道 dao 层的实现细节。<strong>dao 模式可以理解为数据库操作的简单封装。</strong></p><p><strong>资源库的定义类似 dao，位于 dao 之上的更高一层，更接近于业务层。</strong> 资源库位于领域模型和数据映射层之间，就像一个位于内存的领域对象集合，提供了一种管理领域对象的机制。资源库的工作流程是：业务层使用近乎自然语言构建查询条件提交给资源库，资源库执行对象增删改查操作（就像操作集合一样），最后资源库自动将操作转为 SQL 的 CRUD 并执行。资源库可以使用 dao 执行数据查询，将返回结果转为领域对象，或新建领域对象，戏院哭执行新增操作，它自动转为 dao 新增方法实现数据持久化。</p><p><strong>对比</strong></p><ul><li><p>dao 抽象数据持久化，资源库抽象领域对象集合；</p></li><li><p>dao 是底层概念，更接近数据库，资源库是高层概念，更接近领域对象（业务逻辑）；</p></li><li><p>dao 简单、通用，可以简单理解为 CRUD 的封装，操作对象是 SQL 语句，资源库复杂、抽象，可以理解为对领域模型的封装，操作对象是领域对象，不再关心数据库；</p></li><li><p>dao 旨在隐藏数据库操作的复杂性，资源库旨在隐藏领域对象的复杂性，使领域业务逻辑更加清晰；</p></li><li><p>dao 不能使用资源库，但资源库可以使用 dao，可以简单认为：资源库 = dao + 领域对象。</p></li></ul><h2 id="4-依赖倒置有什么好处？"><a href="#4-依赖倒置有什么好处？" class="headerlink" title="4. 依赖倒置有什么好处？"></a>4. 依赖倒置有什么好处？</h2><blockquote><p>在面向对象编程领域中，依赖反转原则是指一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒，从而使得低层次模块依赖于高层次模块的需求抽象。</p><p>该原则规定：</p><ol><li><p>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</p></li><li><p>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口</p></li></ol><p>——维基百科</p></blockquote><p>依赖倒置原则的定义在DDD设计中可以改述为：领域层等其他层不应该依赖于基础实施层，两者都应该依赖于抽象，具体落地的时候，这些抽象的接口定义放在了领域层等下方层中。这也就是意味着一个重要的落地指导原则： <strong>所有依赖基础实施实现的抽象接口，都应该定义在领域层或应用层中</strong>。</p><p><img src="/2022/06/23/ddd/aocan/Desktop/code/acacac13.github.io/source/_posts/ddd/647-1aeff661566da6a0.png" alt></p><p>依赖倒置原则 DIP 的好处是：</p><ol><li>通过依赖于接口，隔离了具体实现类</li><li>低一层的变动并不会导致高一层的变动</li><li>提高了代码的容错性、扩展性和易于维护</li></ol><p>这种分层结构更加地高内聚低耦合。每一层只依赖于抽象，因为具体的实现在基础实施层，无需关心。只要抽象不变，就无需改动那一层，实现如果需要改变，只需要修改基础实施层就可以了。</p><h2 id="5-应该在哪一层处理多个聚合之间的关系？"><a href="#5-应该在哪一层处理多个聚合之间的关系？" class="headerlink" title="5. 应该在哪一层处理多个聚合之间的关系？"></a>5. 应该在哪一层处理多个聚合之间的关系？</h2><p>应该在应用层编排多个聚合之间的关系。因为应用服务负责组织业务场景，编排业务。它将要实现的功能委托给一个或多个领域对象来实现，它本身只负责处理业务用例的执行顺序以及结果的拼装。</p><h2 id="6-除了vo和entity以外，还有哪些对象定义？"><a href="#6-除了vo和entity以外，还有哪些对象定义？" class="headerlink" title="6. 除了vo和entity以外，还有哪些对象定义？"></a>6. 除了vo和entity以外，还有哪些对象定义？</h2><p>如下表：</p><div class="table-container"><table><thead><tr><th></th><th>领域元素</th><th>英文</th><th>命名规则</th><th>举例</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>实体</td><td>Entity</td><td>类名以Entity结尾</td><td>OrderEntity</td><td><br></td></tr><tr><td>2</td><td>值对象</td><td>Value Object</td><td>类名以VO结尾</td><td>AddressVO</td><td>现存有些UI/视图DTO对象也叫xxxVO，建议改为xxxUO</td></tr><tr><td>3</td><td>领域服务</td><td>Domain Service</td><td>以动词命名领域服务类和方法，并以DomainService结尾</td><td>ValidatingOrderDomainService</td><td><br></td></tr><tr><td>4</td><td>工厂</td><td>Factory</td><td>类名以Factory结尾</td><td>OrderFactory</td><td><br></td></tr><tr><td>5</td><td>资源库</td><td>Repository</td><td>类名以Repository结尾</td><td>OrderRepository</td><td><br></td></tr><tr><td>6</td><td>领域事件</td><td>Domain Event</td><td>类名以名词+动词过去式+Event命名</td><td>OrderCreatedEvent</td><td><br></td></tr><tr><td>7</td><td>应用服务</td><td>Application Service</td><td>类名以AppService结尾</td><td>PlaceOrderAppService</td><td><br></td></tr><tr><td>8</td><td>DTO</td><td>data transfer object</td><td>类名分别以Cmd、Qry、UO、DTO结尾</td><td>OrderAddCmd、OrderQry、OrderUO、OrderDTO</td><td>sdk里暴露的DTO可细分为：<br><br>1. 入参xxxCmd：表示写数据接口的入参<br> <br>2. 入参xxxQry：表示读数据接口的入参<br> <br>3. 出参xxxUO，表示面向UI/视图组装的对象<br> <br>4. 出参xxxDTO，表示面向接口组装的对象<br> <br>5. 不符合上述场景的用xxxDTO<br><br></td></tr><tr><td>9</td><td>对应db表的数据对象</td><td>PO</td><td>类名以PO结尾</td><td>OrderPO</td><td><br></td></tr><tr><td>10</td><td>转换类</td><td>Convertor</td><td>app层：在DTO和entity间相互转换</td><td>OrderDTOConvertor</td><td><br></td></tr><tr><td>11</td><td>infra层：在PO和entity间相互转换</td><td>OrderPOConvertor</td><td><br></td><td></td><td></td></tr><tr><td>12</td><td>领域层里的函数命名</td><td><br></td><td>尽量用有领域语义化的词语命名，尽量不要用getxxx，setxxx</td><td><br></td><td><br></td></tr><tr><td>13</td><td>测试类</td><td>XXXTest</td><td>单元测试、集成测试类</td><td>OrderEntityTest</td><td><br></td></tr></tbody></table></div><h2 id="7-DDD-和-MVC-的区别是什么？"><a href="#7-DDD-和-MVC-的区别是什么？" class="headerlink" title="7. DDD 和 MVC 的区别是什么？"></a>7. DDD 和 MVC 的区别是什么？</h2><p>MVC 三层架构中的 M 表示 Model，V 表示 View，C 表示 Controller。它将整个项目分为三层：展示层、逻辑层、数据层。</p><p>MVC 的缺点就是虽然 M 和 V 是两份文件，但是数据和业务逻辑高度耦合的，也就是说，M 只负责了数据的定义，而数据的操作都在 V，一旦修改了 M，改 V 是真是苦不堪言，这种将数据与操作分离的特点，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p><p>导致了这么一些问题：</p><ol><li>臃肿的servcie</li><li>三层分层后文件的随意组装方式</li><li>技术导向分层，导致业务分离，不能快速定位。</li></ol><p>DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性。</p><p>领域驱动设计是一种以业务为导向的软件设计方法和思路。我们在开发前，通常需要进行大量的业务知识梳理，而后到达软件设计的层面，最后才是开发。而在业务知识梳理的过程中，我们必然会形成某个领域知识，根据领域知识来一步步驱动软件设计，就是领域驱动设计的基本概念。而领域驱动设计的核心就在于建立正确的领域驱动模型。</p><p>领域模型具有以下特点：</p><ol><li>领域模型是对具有某个边界的领域的一个抽象，反映了领域内用户业务需求的本质；领域模型是有边界的，只反应了我们在领域内所关注的部分；</li><li><strong>领域模型只反映业务，和任何技术实现无关</strong>；领域模型不仅能反映领域中的一些实体概念，如货物，书本，应聘记录，地址，等；还能反映领域中的一些过程概念，如资金转账，等；</li><li>领域模型确保了我们的软件的业务逻辑都在一个模型中，都在一个地方；这样对提高软件的可维护性，业务可理解性以及可重用性方面都有很好的帮助；</li><li>领域模型能够帮助开发人员相对平滑地将领域知识转化为软件构造；</li><li>领域模型贯穿软件分析、设计，以及开发的整个过程；领域专家、设计人员、开发人员通过领域模型进行交流，彼此共享知识与信息；因为大家面向的都是同一个模型，所以可以防止需求走样，可以让软件设计开发人员做出来的软件真正满足需求；</li><li>要建立正确的领域模型并不简单，需要领域专家、设计、开发人员积极沟通共同努力，然后才能使大家对领域的认识不断深入，从而不断细化和完善领域模型；</li><li>为了让领域模型看的见，我们需要用一些方法来表示它；图是表达领域模型最常用的方式，但不是唯一的表达方式，代码或文字描述也能表达领域模型；</li><li>领域模型是整个软件的核心，是软件中最有价值和最具竞争力的部分；设计足够精良且符合业务需求的领域模型能够更快速的响应需求变化；</li></ol><h2 id="8-聚合的意义是什么？"><a href="#8-聚合的意义是什么？" class="headerlink" title="8. 聚合的意义是什么？"></a>8. 聚合的意义是什么？</h2><p><strong>聚合</strong>: 聚合往往是一些实体为了某项业务而聚类在一起形成的集合 ，举个例子， 社会是由一个个的个体组成的，象征着我们每一个人。随着社会的发展，慢慢出现了社团、机构、部门等组织，我们开始从个人变成了组织的一员，大家可以协同一致的工作，朝着一个最大的目标前进，发挥出更大的力量。领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。可以这么理解，聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。</p><p><strong>聚合划分的原则</strong></p><ul><li>生命周期一致性</li><li>问题域一致性</li><li>场景频率一致性</li><li>聚合内的元素尽可能少</li></ul><p><strong>如何设计聚合？</strong></p><p>DDD 领域建模通常采用事件风暴，它通常采用用例分析、场景分析和用户旅程分析等方法，通过头脑风暴列出所有可能的业务行为和事件，然后找出产生这些行为的领域对象，并梳理领域对象之间的关系，找出聚合根，找出与聚合根业务紧密关联的实体和值对象，再将聚合根、实体和值对象组合，构建聚合。</p><p>下面以保险的投保业务场景为例，看一下聚合的构建过程。</p><p><img src="file:///Users/aocan/Desktop/code/acacac13.github.io/source/_posts/ddd/2002319-20210608002338829-1627378702.png" title alt data-align="center"></p><ol><li><p>采用事件风暴，根据业务行为，梳理出在投保过程中发生这些行为的所有的实体和值对象，比如投保单、标的、客户、被保人等等。</p></li><li><p>从众多实体中选出适合作为对象管理者的根实体，也就是聚合根。判断一个实体是否是聚合根，你可以结合以下场景分析：是否有独立的生命周期？是否有全局唯一 ID？是否可以创建或修改其它对象？是否有专门的模块来管这个实体。图中的聚合根分别是投保单和客户实体。</p></li><li><p>根据业务单一职责和高内聚原则，找出与聚合根关联的所有紧密依赖的实体和值对象。构建出 1 个包含聚合根（唯一）、多个实体和值对象的对象集合，这个集合就是聚合。在图中我们构建了客户和投保这两个聚合。</p></li><li><p>在聚合内根据聚合根、实体和值对象的依赖关系，画出对象的引用和依赖模型。这里我需要说明一下：投保人和被保人的数据，是通过关联客户 ID 从客户聚合中获取的，在投保聚合里它们是投保单的值对象，这些值对象的数据是客户的冗余数据，即使未来客户聚合的数据发生了变更，也不会影响投保单的值对象数据。从图中我们还可以看出实体之间的引用关系，比如在投保聚合里投保单聚合根引用了报价单实体，报价单实体则引用了报价规则子实体。</p></li><li><p>多个聚合根据业务语义和上下文一起划分到同一个限界上下文内。这就是一个聚合诞生的完整过程了。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/361427612?utm_source=com.baidu.hi&amp;utm_medium=social&amp;utm_oi=836364635941801984">什么是DDD（领域驱动设计）？ 这是我见过最容易理解的一篇关于DDD 的文章了 - 知乎</a></li><li><a href="https://www.jianshu.com/p/df2e3c5eccf2">什么是DDD领域驱动设计？ - 简书</a></li><li><a href="https://zhuanlan.zhihu.com/p/423892114">都在聊DDD，哪里超越了MVC？ - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/266635942">DDD（领域驱动设计）之你必须知道的贫血模型和充血模型 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/75931257">后端开发实践系列——领域驱动设计(DDD)编码实践 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/91525839">DDD 模式从天书到实践 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/383229291">深入理解领域驱动设计中的聚合 - 知乎</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口算法</title>
    <link href="/2022/05/09/SlidingWindow/"/>
    <url>/2022/05/09/SlidingWindow/</url>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口模板"><a href="#滑动窗口模板" class="headerlink" title="滑动窗口模板"></a>滑动窗口模板</h1><p>滑动窗口算法的思路，就是维护一个窗口，不断滑动，然后更新答案。大致逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(right &lt; s.length()) &#123;<br>    <span class="hljs-comment">// 增大窗口</span><br>    window.add(s.charAt(right));<br>    right++;<br>    <br>    <span class="hljs-keyword">while</span>(window needs shrink) &#123;<br>        <span class="hljs-comment">// 缩小窗口</span><br>        window.remove(s.charAt(left));<br>        left++;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个算法的时间复杂度是 O(n)，优于字符串暴力算法。</p><p><strong>难点</strong></p><ul><li>如何向窗口中添加新元素</li><li>如何缩小窗口</li><li>在窗口滑动的哪个阶段更新结果</li><li>…</li></ul><p>下面就是滑动窗口算法的代码框架</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 滑动窗口算法框架</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slidingWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>    Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 左闭又开</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 计数</span><br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 记录字符串 t</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>        need.put(t.charAt(i), need.getOrDefault(t.charAt(i), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(right &lt; s.length()) &#123;<br>        <span class="hljs-comment">// c 是将移入窗口的字符</span><br>        <span class="hljs-keyword">char</span> c = s.charAt(right);<br>        <span class="hljs-comment">// 增大窗口</span><br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        ...<br>            <br>        <span class="hljs-comment">/*** debug 输出的位置 ***/</span><br>        System.out.println(<span class="hljs-string">&quot;window: [%d, %d)\n&quot;</span>, left, right);<br>        <span class="hljs-comment">/********************/</span><br>        <br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span>(window needs shrink) &#123;<br>            <span class="hljs-comment">// d 是将移出窗口的字符</span><br>            <span class="hljs-keyword">char</span> d = s.charAt(left);<br>            <span class="hljs-comment">// 缩小窗口</span><br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>...</code>表示更新窗口数据的地方，根据实际情况填入相应代码即可。而且，这两处的操作分别是扩大和缩小窗口的更新操作，它们操作是完全对称的。</p><h1 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h1><ol><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/">LeetCode76题-最小覆盖子串</a></li><li><a href="https://leetcode-cn.com/problems/permutation-in-string/">LeetCode567题-字符串的排列</a></li><li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">LeetCode438题-找到字符串中所有字母异位词</a></li><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LeetCode3题-无重复字符的最长子串</a></li></ol><h2 id="1-最小覆盖子串"><a href="#1-最小覆盖子串" class="headerlink" title="1. 最小覆盖子串"></a>1. 最小覆盖子串</h2><p><img src="/2022/05/09/SlidingWindow/image-20220509145017394.png" alt="LeetCode76题-最小覆盖子串"></p><p>这一题暴力解法的思路如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; s.length(); j++) &#123;<br>        <span class="hljs-keyword">if</span> s[i:j] 包含t的字母<br>            更新答案<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>显然，这个思路的时间复杂度是大于 O(n^2) 的。下面描述一下滑动窗口的思路：</p><ol><li>在字符串 s 中使用双指针，初始化<code>left = right = 0</code>，且左闭右开区间<code>[left, right)</code>称为一个窗口；</li><li>不断增大<code>right</code>指针扩大窗口，直到窗口中的所有字符串都符合要求。</li><li>此时，停止增加<code>right</code>，开始增加<code>left</code>指针缩小窗口，直到窗口中的字符串不再符合要求。同时，每增加一次<code>left</code>，都要更新一轮结果。</li><li>重复第2步和第3步，直到<code>right</code>到达字符串 s 的尾部。</li></ol><p>下面是具体代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>    <span class="hljs-comment">// 计数，记录t</span><br>    Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">// 计数，记录s</span><br>    Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 左闭又开</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 计数</span><br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 记录最小子串的起始位置和长度</span><br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> len = Integer.MAX_VALUE;<br>    <span class="hljs-comment">// 记录字符串 t</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>        need.put(t.charAt(i), need.getOrDefault(t.charAt(i), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(right);<br>        <span class="hljs-comment">// 扩大窗口</span><br>        right++;<br>        <span class="hljs-comment">// 窗口内数据更新</span><br>        <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (window.get(c).equals(need.get(c))) &#123;<br>                valid++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 判断左侧窗口是否收缩</span><br>        <span class="hljs-keyword">while</span> (valid == need.size()) &#123;<br>            <span class="hljs-comment">// 更新最小覆盖子串</span><br>            <span class="hljs-keyword">if</span> (right - left &lt; len) &#123;<br>                <span class="hljs-comment">// 更新起始位置和长度</span><br>                start = left;<br>                len = right - left;<br>            &#125;<br>            <span class="hljs-comment">// d 是移除窗口的元素</span><br>            <span class="hljs-keyword">char</span> d = s.charAt(left);<br>            left++;<br>            <span class="hljs-comment">// 更新</span><br>            <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                <span class="hljs-keyword">if</span> (window.get(d).equals(need.get(d))) &#123;<br>                    valid--;<br>                &#125;<br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start, start + len);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-字符串排列"><a href="#2-字符串排列" class="headerlink" title="2. 字符串排列"></a>2. 字符串排列</h2><p><img src="/2022/05/09/SlidingWindow/image-20220509151502096.png" alt="LeetCode567题-字符串的排列"></p><p>这个题目是明显的滑动窗口算法，问题可以转换为：给你字符串 s 和 t，请问 s 中是否存在一个子串，包含 t 中所有字符且不包含其他字符（排列）。</p><p>对于本题的解法代码，与最小覆盖子串相比只需要改变两个地方。</p><ol><li>本题<code>left</code>指针右移时应该是窗口大小大于<code>t.length()</code></li><li>当发现<code>valid == need.size()</code>时，立即返回<code>true</code></li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>    Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s1.length(); i++) &#123;<br>        need.put(s1.charAt(i), need.getOrDefault(s1.charAt(i), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 前面与最小覆盖子串相同</span><br>    <br>    <span class="hljs-keyword">while</span>(right &lt; s2.length()) &#123;<br>        <span class="hljs-keyword">char</span> c = s2.charAt(right);<br>        right++;<br>        <br>        <span class="hljs-comment">// 更新数据</span><br>        <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (need.get(c).equals(window.get(c))) &#123;<br>                valid++;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 收缩 注意</span><br>        <span class="hljs-keyword">while</span>(right - left &gt;= s1.length()) &#123;<br>            <span class="hljs-keyword">if</span> (valid == need.size()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">char</span> d = s2.charAt(left);<br>            left++;<br>            <span class="hljs-comment">// 更新</span><br>            <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                <span class="hljs-keyword">if</span> (window.get(d).equals(need.get(d))) &#123;<br>                    valid--;<br>                &#125;<br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-找出所有字母异位词"><a href="#3-找出所有字母异位词" class="headerlink" title="3. 找出所有字母异位词"></a>3. 找出所有字母异位词</h2><p><img src="/2022/05/09/SlidingWindow/image-20220509153214579.png" alt="LeetCode438题-找到字符串中所有字母异位词"></p><p>这个问题同样可以转化为：给你字符串 s 和 t，找到 s 中所有 t 的排列，并返回其起始索引。</p><p>与字符串排列的区别就是找到排列后，将起始索引存入集合。</p><p>直接上具体代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p.length(); i++) &#123;<br>       need.put(p.charAt(i), need.getOrDefault(p.charAt(i), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 存结果</span><br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <br>    <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(right);<br>        right++;<br>        <br>        <span class="hljs-comment">// 更新数据</span><br>        <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(window.get(c).equals(need.get(c))) &#123;<br>                valid++;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 收缩</span><br>        <span class="hljs-keyword">while</span> (right - left &gt;= p.length()) &#123;<br>            <span class="hljs-keyword">if</span> (valid == need.size()) &#123;<br>                res.add(left);<br>            &#125;<br>            <span class="hljs-keyword">char</span> d = s.charAt(left);<br>            left++;<br>            <span class="hljs-comment">// 更新</span><br>            <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                <span class="hljs-keyword">if</span>(window.get(d).equals(need.get(d))) &#123;<br>                    valid--;<br>                &#125;<br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="4-最长无重复子串"><a href="#4-最长无重复子串" class="headerlink" title="4. 最长无重复子串"></a>4. 最长无重复子串</h2><p><img src="/2022/05/09/SlidingWindow/image-20220509154727450.png" alt="LeetCode3题-无重复字符的最长子串"></p><p>这一题连<code>need</code>和<code>valid</code>都不需要了，只需要一个更新计数器<code>window</code>即可。<code>window.get(c) &gt; 1</code>时，说明窗口中有重复字符，不符合条件，此时开始移动<code>left</code>。</p><p>需要注意的是，本题需要在收缩窗口完成后更新<code>res</code>，因为窗口收缩的<code>while</code>条件是存在重复元素，收缩完成后窗口中才一定没有重复。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 记录结果</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(right);<br>        right++;<br>        <span class="hljs-comment">// 更新</span><br>        window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-comment">// 收缩</span><br>        <span class="hljs-keyword">while</span>(window.get(c) &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">char</span> d = s.charAt(left);<br>            left++;<br>            <span class="hljs-comment">// 更新</span><br>            window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 注意 res 的更新位置</span><br>        res = Math.max(res, right - left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://labuladong.github.io/algo/2/18/25/">labuladong 的算法小抄-我写了首诗，把滑动窗口算法算法变成了默写题</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2022/04/27/MonotoneStack/"/>
    <url>/2022/04/27/MonotoneStack/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h1><p>栈是一种简单的先进后出的数据结构，单调栈实际上就是栈，只是利用了一些逻辑，使得每次新元素入栈后，栈内元素都保持有序。单调栈的用途不太广泛，只处理一种典型的问题，叫做<code>Next Greater Element</code>。</p><p>题目如下：提供数组<code>nums</code>，请返回一个等长的结果数组，结果数组种对应索引存储着下一个更大元素，如果没有更大的元素，就存-1。</p><p><img src="/2022/04/27/MonotoneStack/image-20220427193058418.png" alt></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] nextGreaterElement(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// 倒序遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 判定高低</span><br>        <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &lt;= nums[i]) &#123;<br>            <span class="hljs-comment">// 栈顶小则出栈</span><br>            stack.pop();<br>        &#125;<br>        <span class="hljs-comment">// nums[i] 后面的 next great number</span><br>        res[i] = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>        stack.push(nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以上就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为借助的是栈的结构，倒着入栈，就是正着出栈。while 循环是把两个 个子高 的元素排除，因为他们的存在没有意义，前面挡着个更高的元素，所以不可能作为后续进来的元素的<code>Next Great Number</code>了。</p><p>这个算法的时间复杂度其实是<code>O(n)</code>，从整体来看：总共有 <code>n</code> 个元素，每个元素都被 <code>push</code> 入栈了一次，而最多会被 <code>pop</code> 一次，没有任何冗余操作。所以总的计算规模是和元素规模 <code>n</code> 成正比的，也就是 <code>O(n)</code> 的复杂度。</p><p><a href="https://leetcode-cn.com/problems/next-greater-element-i/">LeetCode496题-下一个更大元素 I</a></p><p><img src="/2022/04/27/MonotoneStack/image-20220428101312819.png" alt="LeeCode496题-下一个更大元素 I"></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] nextGreaterElement(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;<br>    <span class="hljs-keyword">int</span> n = nums1.length;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>    LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums2.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= nums2[i]) &#123;<br>            stack.pop();<br>        &#125;<br>        map.put(nums2[i], stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek());<br>        stack.push(nums2[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res[i] = map.get(nums1[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="问题变形"><a href="#问题变形" class="headerlink" title="问题变形"></a>问题变形</h1><p><a href="https://leetcode-cn.com/problems/daily-temperatures/">LeetCode739题-每日温度</a></p><p><img src="/2022/04/27/MonotoneStack/image-20220427194100135.png" alt="LeeCode739题-每日温度"></p><p>相同的思路，直接使用模板稍作改动。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] nextGreaterElement(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;<br>    <span class="hljs-keyword">int</span> n = nums1.length;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>    LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums2.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= nums2[i]) &#123;<br>            stack.pop();<br>        &#125;<br>        map.put(nums2[i], stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek());<br>        stack.push(nums2[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res[i] = map.get(nums1[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="处理循环数组"><a href="#处理循环数组" class="headerlink" title="处理循环数组"></a>处理循环数组</h1><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">LeetCode503题-下一个更大元素 II</a></p><p><img src="/2022/04/27/MonotoneStack/image-20220427194255147.png" alt="LeetCode503题-下一个更大元素 II"></p><p>一般通过<code>%</code>运算符取模，来获得环形特效。<strong>对于这种需求，常用套路就是将数组长度翻倍</strong>。</p><p><img src="/2022/04/27/MonotoneStack/image-20220427194816459.png" alt="图解"></p><p>思路就是把这个双倍长度的数组构造出来，然后套用算法模板。但是，<strong>我们可以不用构造新数组，而是利用循环数组的技巧来模拟数组长度翻倍的效果</strong>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] nextGreaterElements(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] answer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>    <span class="hljs-comment">// 单调栈模板</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek()  &lt;= nums[i % n]) &#123;<br>            stack.pop();<br>        &#125;<br>        answer[i % n] = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>        stack.push(nums[i % n]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> answer;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批量修改文件内容（解决图片失效问题）</title>
    <link href="/2022/04/24/replacePic/"/>
    <url>/2022/04/24/replacePic/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前博客的图片都是利用gitee当图床存储的，在上个月的某一天gitee突然给我发了个邮件屏蔽了我的图床仓库，如下：</p><p><img src="/2022/04/24/replacePic/image-20220424152304773.png" alt="邮件内容"></p><p>周围用gittee当图床的同学也都是这个情况，属于是养肥之后收割了。博客图片全部失效，我之前也没有备份，直接心态崩了，看着满屏的gitee的logo就脑袋疼，还好之后联系管理员给我把仓库开了供我下载备份。由于3月到现在一直在忙着找实习，一直没空来管这个，最近总算有空来解决这个问题了。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>现在图片是有了，不管是找其他图床还是直接把图片和文章一块部署上去，都需要对文章里面图片的路径做一个全局替换。显然这是个体力活，对于体力活来说，必须偷懒，所以有了下面的一个脚本。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> regex <span class="hljs-keyword">as</span> re<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modifyContent</span>(<span class="hljs-params">top</span>):</span><br>    <span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(top, topdown=<span class="hljs-literal">False</span>):<br>        <span class="hljs-comment"># 循环文件</span><br>        <span class="hljs-keyword">for</span> file_name <span class="hljs-keyword">in</span> files:<br>            file_name_split = file_name.split(<span class="hljs-string">&#x27;.&#x27;</span>)<br><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">if</span> file_name_split[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;md&#x27;</span>:<br>                    <span class="hljs-comment"># 找到md文件并且复制一份md文件路径</span><br>                    md_file_path = os.path.join(root, <span class="hljs-string">&#x27;.&#x27;</span>.join(file_name_split))<br>                    copy_md_file_path = os.path.join(root, <span class="hljs-string">&#x27;.&#x27;</span>.join([<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;file_name_split[<span class="hljs-number">0</span>]&#125;</span>_copy&#x27;</span>, file_name_split[<span class="hljs-number">1</span>]]))<br><br>                    <span class="hljs-comment"># 打开md文件然后进行替换</span><br>                    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(md_file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf8&#x27;</span>) <span class="hljs-keyword">as</span> fr, \<br>                            <span class="hljs-built_in">open</span>(copy_md_file_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf8&#x27;</span>) <span class="hljs-keyword">as</span> fw:<br>                        data = fr.read()<br>                        <span class="hljs-comment"># 替换前的字符串 -- 替换后的字符串</span><br>                        data = re.sub(<span class="hljs-string">&#x27;https://gitee.com/acacac13/images/raw/master&#x27;</span>, <span class="hljs-string">&#x27;picture&#x27;</span>, data)<br>                        fw.write(data)  <span class="hljs-comment"># 新文件一次性写入原文件内容</span><br>                    <span class="hljs-comment"># 删除原文件</span><br>                    os.remove(md_file_path)<br>                    <span class="hljs-comment"># 重命名新文件名为原文件名</span><br>                    os.rename(copy_md_file_path, md_file_path)<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;md_file_path&#125;</span> done...&#x27;</span>)<br>                    time.sleep(<span class="hljs-number">0.5</span>)<br>            <span class="hljs-keyword">except</span> FileNotFoundError <span class="hljs-keyword">as</span> e:<br>                <span class="hljs-built_in">print</span>(e)<br>        time.sleep(<span class="hljs-number">0.5</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    top = <span class="hljs-string">r&#x27;....../source/_posts&#x27;</span><br>    modifyContent(top)<br></code></pre></div></td></tr></table></figure><p>简单记录一下步骤：</p><ol><li>在博客的<code>source</code>文件夹下新建一个图片文件夹<code>picture</code>，并把所有图片放入其中；</li><li>通过上面的脚本替换掉<code>_post</code>文件夹下所有文章中的图片路径；</li><li>可以打开md文件看到已经可以正常显示图片了；</li><li><code>hexo clean</code>；</li><li><code>hexo g</code>查看<code>public</code>文件夹下是否有<code>picture</code>文件夹，若有则替换成功，若没有则检查第一步是否是在<code>source</code>文件夹下新建的图片文件夹；</li><li>最后<code>hexo d</code>部署。</li></ol><p>这样的话只是把封面图片和顶部图片恢复了，仔细查看public文件夹的文章路径可以知道用之前的相对路径是不行的，因此恢复文章的图片还得需要在<code>_post</code>文件夹下建立与文章相同文件名的文件夹放入图片，再修改文章中的图片路径，此时修改路径其实将 typora 的偏好设置设置如下然后再直接cv即可，后面的步骤就是正常的部署文章了。</p><p><img src="/2022/04/24/replacePic/image-20220424165626055.png" alt="typora 设置"></p>]]></content>
    
    
    <categories>
      
      <category>博客问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>批量修改文件内容</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 学习笔记</title>
    <link href="/2022/02/24/Jvm/"/>
    <url>/2022/02/24/Jvm/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM-与-Java-体系结构"><a href="#JVM-与-Java-体系结构" class="headerlink" title="JVM 与 Java 体系结构"></a>JVM 与 Java 体系结构</h1><p>  JVM 是一个跨语言的平台</p><p><img src="/2022/02/24/Jvm/20220204110515.png" alt></p><p><strong>虚拟机概念</strong></p><p>所谓虚拟机<code>(Vitual Machine)</code>，就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong>。</p><ul><li>Visual Box ，VMware 就是属于系统虚拟机，<strong>完全是对物理计算机的仿真</strong>，提供了一个可运行完整操作系统的软件平台。</li><li>程序虚拟机的典型代表就是 Java 虚拟机， <strong>专门为执行单个计算机程序而设计</strong>，在 Java 虚拟机中执行的指令我们称为 Java 字节码指令。</li></ul><h2 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h2><p>Java 虚拟机是一台执行 Java 字节码的虚拟计算机，它拥有独立的运行机制，其运行的 Java 字节码也未必由 Java 语言编译而成。</p><p>JVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。</p><p><strong>Java 技术的核心就是 Java 虚拟机</strong>，因为所有的 Java 程序都运行在 Java 虚拟机内部。</p><ul><li><p>作用：</p><p>Java 虚拟机就是二进制字节码的运行环境，负责装在字节码到其内部，解释/编译为对应平台上的机器指令执行。</p></li><li><p>特点：</p><p>一次编译，到处运行</p><p>自动内存管理</p><p>自动垃圾回收功能</p></li></ul><p><strong>JVM 的位置</strong></p><p><img src="/2022/02/24/Jvm/20220204120538.png" alt="JVM 的位置"></p><p>JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</p><p><strong>JVM 的整体结构</strong></p><p><img src="/2022/02/24/Jvm/20220204120853.png" alt="HotSpot VM 的整体结构"></p><p><strong>Java 代码执行流程</strong></p><p><img src="/2022/02/24/Jvm/20220204121617.png" alt="Java 代码执行流程"></p><h2 id="JVM-的架构模型"><a href="#JVM-的架构模型" class="headerlink" title="JVM 的架构模型"></a>JVM 的架构模型</h2><p>Java 编译器输入的指令流基本上是一种基于<strong>栈的指令集结构</strong>，另外一种指令集架构则是基于<strong>寄存器的指令集架构</strong>。</p><h2 id="JVM-的生命周期"><a href="#JVM-的生命周期" class="headerlink" title="JVM 的生命周期"></a>JVM 的生命周期</h2><p>虚拟机的启动</p><p>Java 虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><p>虚拟机的执行</p><ul><li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序</li><li>程序开始执行时他才开始运行，程序结束时他就停止</li><li>执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程</li></ul><p>虚拟机的退出</p><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致 Java 虚拟机进程终止</li><li>某线程调用 Runtime 类或 System 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作</li><li>除此之外，<code>JNI(Java Native Interface)</code>规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况</li></ul><h2 id="JVM-发展历程"><a href="#JVM-发展历程" class="headerlink" title="JVM 发展历程"></a>JVM 发展历程</h2><p>SUN Classic VM、Exact VM、<strong>HotSpot VM</strong>、<strong>JRockit VM</strong>、<strong>IBM J9 VM</strong>、KVM、CDC/CLDC HotSpot、Azul VM、BEA Liquid VM、Apache Harmony、Microsoft JVM、TaobaoJVM、Dalvik VM、<strong>Graal VM</strong></p><h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="类加载子系统的作用"><a href="#类加载子系统的作用" class="headerlink" title="类加载子系统的作用"></a>类加载子系统的作用</h2><p><img src="/2022/02/24/Jvm/20220206165752.png" alt></p><ul><li>类加载子系统负责从文件系统或者网络中加载 class 文件， class 文件在文件开头有特定的文件标识</li><li>ClassLoader 只负责 class 文件的<strong>加载</strong>，至于它是否可以运行，则由 Execution Engine 决定</li><li>加载的类信息存放于一块称为<strong>方法区</strong>的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 cllass 文件中常量池部分的内存映射）</li></ul><h2 id="类加载器-ClassLoader-角色"><a href="#类加载器-ClassLoader-角色" class="headerlink" title="类加载器 ClassLoader 角色"></a>类加载器 ClassLoader 角色</h2><p><img src="/2022/02/24/Jvm/20220206170206.png" alt></p><ol><li>class file 存在与本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 中来根据这个文件实例化出 n 个一模一样的实例。</li><li>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区。</li><li>在 class 文件 -&gt; JVM -&gt; 最终称为元数据模板，此过程就要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色。</li></ol><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><img src="/2022/02/24/Jvm/20220209211245.png" alt="类的加载过程"></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为<strong>方法区</strong>的运行时数据结构</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口</li></ol><p>补充：加载<code>.class</code>文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从<code>zip</code>压缩包中读取，成为日后<code>jar</code>、<code>war</code>格式的基础</li><li>运行时计算生成，使用最多的是：<a href="https://cloud.tencent.com/developer/article/1461796">动态代理</a>技术</li><li>由其他文件生成，典型场景：<code>JSP</code>应用</li><li>从专有数据库中提取<code>.class</code>文件，比较少见</li><li>从加密文件中获取，典型的防<code>Class</code>文件被反编译的保护措施</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>验证<code>(Verify)</code><ul><li>目的是确保<code>Class</code>文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证</li></ul></li><li>准备<code>(Prepare)</code><ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值</li><li>这里不包含用<code>final</code>修饰的<code>static</code>，因为<code>final</code>在编译的时候就会分配了，准备阶段会显式初始化</li><li><strong>这里不会为实例变量分配初始化</strong>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到<code>Java</code>堆中</li></ul></li><li>解析<code>(Resolve)</code><ul><li>将常量池内的符号引用转换为直接引用的过程</li><li>解析操作往往会伴随着<code>JVM</code>在执行完初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li><li>解析动作主要是针对类或接口、字段、类方法、接口方法、方法类型等</li></ul></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li><li>此方法不需定义，是<code>javac</code>编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li><li>构造器方法中指令按语句在源文件中出现的顺序执行</li><li><code>&lt;clinit&gt;()</code>不同于类的构造器</li><li>若该类具有父类，<code>JVM</code>会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法子啊多线程下被同步加锁</li></ul><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><ul><li><p><code>JVM</code>支持两种类型的类加载器。分别为引导类加载器<code>(Bootstrap ClassLoader)</code>和自定义类加载器<code>(User-Defined ClassLoader)</code></p></li><li><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类加载器，但是<code>Java</code>虚拟机规范却没有这么定义，而是将所有派生于抽象类<code>ClassLoader</code>的类加载器都划分为自定义加载器</p></li><li><p>无论类加载器的类型和如何划分，在程序最常见的类加载器始终只有3个</p><ul><li><code>Bootstrap Class Loader</code> 引导类加载器</li><li><code>Extension Class Loader</code> 扩展类加载器</li><li><code>System Class Loader</code> 系统类加载器</li></ul><p><img src="/2022/02/24/Jvm/20220210154236.png" alt="三者关系"></p></li></ul><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器-（引导类加载器，Bootstarp-ClassLoader）"><a href="#启动类加载器-（引导类加载器，Bootstarp-ClassLoader）" class="headerlink" title="启动类加载器 （引导类加载器，Bootstarp ClassLoader）"></a>启动类加载器 （引导类加载器，Bootstarp ClassLoader）</h4><ul><li>这个类加载是用<code>C/C++</code>实现的，嵌套在<code>JVM</code>内部</li><li>它用来加载<code>Java</code>的核心库，用于提供<code>JVM</code>自身需要的类</li><li>并不继承自<code>java.lang.ClassLoader</code>，没有父加载器</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li><li>出于安全考虑，<code>Bootstrap</code>启动类加载器只加载包名为<code>java</code>、<code>javax</code>、<code>sun</code>等开头的类</li></ul><h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul><li><code>Java</code>编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现</li><li>派生于<code>ClassLoader</code>类</li><li>父类加载器为启动类加载器</li><li>从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或从<code>JDK</code>的安装目录的<code>jre/lib/ext</code>子目录（扩展目录）下加载类库。如果用户创建的<code>JAR</code>放在此目录下，也会自动由扩展类加载器加载</li></ul><h4 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h4><ul><li><code>java</code>编写，由<code>sun.misc.Launcher$AppClassLoader</code>实现</li><li>派生于<code>ClassLoader</code>类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量<code>classpath</code>或系统属性<code>java.class.path</code>指定路径下的类库</li><li>该类是程序中默认的类加载器，一般来说，<code>Java</code>应用的类都是由它来完成加载</li><li>通过<code>ClassLoader$getSystemClassLoader()</code>方法可以获取到该类加载器</li></ul><h3 id="用户自定义的加载器"><a href="#用户自定义的加载器" class="headerlink" title="用户自定义的加载器"></a>用户自定义的加载器</h3><p>需要自定义类加载器的原因</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄露</li></ul><p>用户自定义类加载器实现步骤：</p><ol><li>通过继承抽象类<code>java.lang.ClassLoader</code>类的方式实现</li><li>把自定义的类加载逻辑写在<code>findClass()</code>方法中</li><li>在没有太过于复杂的需求时，可以直接继承<code>URLClassLoader</code>类，避免自己编写<code>findClass()</code>方法及前期获取字节码流的方式，使自定义类加载器编写更加简洁</li></ol><h3 id="关于-ClassLoader"><a href="#关于-ClassLoader" class="headerlink" title="关于 ClassLoader"></a>关于 ClassLoader</h3><p><code>ClassLoader</code>类是一个抽象类，其后所有的类加载器都继承自<code>ClassLoader</code>（不包括启动类加载器）</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>getParent()</code></td><td style="text-align:left">返回该类加载器的超类加载器</td></tr><tr><td style="text-align:left"><code>loadClass(String name)</code></td><td style="text-align:left">加载名称为<code>name</code>的类，返回结果为<code>java.lang.Class</code>类的实例</td></tr><tr><td style="text-align:left"><code>findClass(String name)</code></td><td style="text-align:left">查找名称为<code>name</code>的类，返回结果为<code>java.lang.Class</code>类的实例</td></tr><tr><td style="text-align:left"><code>findLoadedClass(String name)</code></td><td style="text-align:left">查找名称为<code>name</code>的已经被加载过的类，返回结果为<code>java.lang.Class</code>类的实例</td></tr><tr><td style="text-align:left"><code>defineClass(String name, byte[] b, int off, int len)</code></td><td style="text-align:left">把字节数组<code>b</code>中的内容转换为一个<code>Java</code>类，返回结果为<code>java.lang.Class</code>类的实例</td></tr><tr><td style="text-align:left"><code>resolveClass(Class&lt;?&gt; c)</code></td><td style="text-align:left">连接指定的一个<code>Java</code>类</td></tr></tbody></table></div><p><code>sun.misc.Launcher</code>是一个<code>Java</code>虚拟机的入口应用。</p><p><img src="/2022/02/24/Jvm/20220210155249.png" alt="继承关系"></p><p><strong>获取 ClassLoader 的途径</strong></p><ol><li><p>获取当前类的<code>ClassLoader</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">clazz.getClassLoader();<br></code></pre></div></td></tr></table></figure></li><li><p>获取当前线程上下文的<code>ClassLoader</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Thread.currentThread().getContextClassLoader()<br></code></pre></div></td></tr></table></figure></li><li><p>获取系统的<code>ClassLoader</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ClassLoader.getSystemClassLoader()<br></code></pre></div></td></tr></table></figure></li><li><p>获取调用者的<code>ClassLoader</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">DriverManager.getCallerClassLoader()<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java 虚拟机对 class 文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是<strong>双亲委派模式</strong>，即把请求交由父类处理，它是一种任务委派模式。</p><p><img src="/2022/02/24/Jvm/20220210164659.png" alt="工作原理"></p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ol><p><img src="/2022/02/24/Jvm/20220210165554.png" alt="另一种双亲委派机制举例"></p><p><strong>双亲委派机制优势</strong></p><ul><li>避免重复加载</li><li>保护程序安全，防止核心<code>API</code>被篡改<ul><li>自定义类：<code>java.lang.String</code></li><li>自定义类：<code>java.lang.ShkStart</code></li></ul></li></ul><h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件<code>(rt.jar包中java\lang\string.class)</code>，报错信息说没有 main 方法：就是因为加载的是 rt.jar 包中的 String 类。这样可以保证对 java 核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在<code>JVM</code>中表示两个<code>class</code>对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名</li><li>加载这个类的<code>ClassLoader</code>实例对象必须相同</li></ul><p>即在<code>JVM</code>中，即使这两个类对象（<code>class</code>对象）来源同一个<code>class</code>文件，被同一个虚拟机所加载，但只要加载它们的<code>classLoader</code>实例对象不同，那么这两个类对象也是不相等的。</p><h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><p>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会<strong>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。</p><h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java 程序对类的使用方式分为：主动使用和被动使用。</p><p>主动使用，又分为七种情况：</p><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：<code>class.forName (&quot;com.xxx.Test&quot;)</code>）</li><li>初始化一个类的子类</li><li><code>Java</code>虚拟机启动时被标明为启动类的类</li><li><code>JDK 7</code>开始提供的动态语言支持：<code>java.lang.invoke.MethodHandle</code>实例的解析结果<code>REF_getstatic</code>、<code>REF_putstatic</code>、<code>REF_invokestatic</code>句柄对应的类没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用 Java 类的方式都被看作是对<strong>类的被动使用</strong>，都<strong>不会导致类的初始化</strong>。</p><h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p><img src="/2022/02/24/Jvm/20220213114602.png" alt="运行时数据区"></p><p><strong>线程</strong></p><ul><li>线程时一个程序里的运行单元。<code>JVM</code>允许一个应用有多个线程并行的执行。</li><li>在<code>Hotspot JVM</code>里，每个线程都与操作系统的本地线程直接映射。<ul><li>当一个<code>Java</code>线程准备好执行以后，此时一个操作系统的本地线程也同时创建。<code>Java</code>线程执行终止后，本地线程也会回收。</li></ul></li><li>操作系统负责所有线程的安排调度到任何一个可用的<code>CPU</code>上。一旦本地线程初始化成功，它就会调用<code>Java</code>线程中的<code>run()</code>方法。</li></ul><h2 id="程序计数器（PC-寄存器）"><a href="#程序计数器（PC-寄存器）" class="headerlink" title="程序计数器（PC 寄存器）"></a>程序计数器（PC 寄存器）</h2><p><code>JVM</code>中的<code>PC</code>寄存器是对物理<code>PC</code>寄存器的一种抽象模拟。</p><p><strong>作用</strong></p><p><code>PC</code>寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><code>PC</code>寄存器是唯一一个不会发生<code>OOM</code>的区域。</p><p><img src="/2022/02/24/Jvm/20220213143804.png" alt></p><p><strong>常见问题</strong></p><ol><li><p>使用<code>PC</code>寄存器存储字节码指令地址有什么用呢？为什么使用<code>PC</code>寄存器记录当前线程的执行地址呢？</p><p>因为<code>CPU</code>需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p><code>JVM</code>的字节码解释器就需要通过改变<code>PC</code>寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="/2022/02/24/Jvm/20220213152209.png" alt></p><ol><li><p><code>PC</code>寄存器为什么会被设定为线程私有？</p><p>多线程在一个特定的时间段内只会执行其中某一个线程方法，<code>CPU</code>会不停地做任务切换，这样必然导致经常终断或者恢复，为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个<code>PC</code>寄存器，这样各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于<code>CPU</code>时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p></li></ol></li></ol><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>栈是运行时的单位，而堆是存储的单位。即栈解决程序的运行问题，堆解决数据存储的问题。</p><p><strong>定义</strong></p><p><code>Java</code>虚拟机栈<code>(Java virtual Machine stack)</code>，早期也叫<code>Java</code>栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧<code>(stack Frame)</code>，对应着一次次的<code>Java</code>方法调用。是线程私有的。</p><p><strong>生命周期</strong></p><p>生命周期和线程一致。</p><p><strong>作用</strong></p><p>主管<code>Java</code>程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><p><strong>栈的特点</strong></p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li><code>JVM</code>直接对<code>Java</code>栈的操作只有两个：<ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul></li><li>对于栈来说不存在垃圾回收问题</li></ul><p><strong>栈中可能出现的异常</strong></p><p><code>Java</code>虚拟机规范允许<code>java</code>栈的大小是动态的或者是固定不变的</p><ul><li>如果采用固定大小的<code>java</code>虚拟机栈，那每一个线程的<code>java</code>虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过<code>java</code>虚拟机栈允许的最大容量，<code>java</code>虚拟机将会抛出一个<code>StackOverFlowError</code>异常</li><li>如果<code>java</code>虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那<code>java</code>虚拟机将会抛出以一个<code>OutOfMemoryError</code>异常</li></ul><h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><ul><li>每个线程都有自己的栈，栈中的数据是以栈帧<code>(Stack Frame)</code>的格式存在的。</li><li>线程上正在执行的每个方法都对应一个栈帧。</li><li>栈帧是一个内存区块，是一个而数据集，维系着方法执行过程中的各种信息。</li></ul><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另一个线程的栈帧。</p><p><strong>栈帧的内部结构</strong></p><p>每个栈帧中存储着：</p><ul><li>局部变量表<code>(Local Variables)</code></li><li>操作数栈<code>(Operand Stack)</code></li><li>动态链接<code>(Dynamic Linking)</code></li><li>方法返回地址<code>(Return Address)</code></li><li>附加信息</li></ul><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><ul><li>定义为一个数字数组，主要用于<strong>存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用 (reference)，以及 returnAddress 类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong>。</li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。</li></ul><p><strong>关于 Slot 的理解</strong></p><ul><li>局部变量表，最基本的存储单元是<code>Slot</code>（变量槽）。</li><li>在局部变量表里，32位以内的类型只占用一个<code>slot</code>（包括<code>returnAddress</code>类型），64位的类型（<code>long</code>和<code>double</code>）占用两个<code>slot</code>。</li><li><code>JVM</code>为局部变量表中的每一个<code>Slot</code>分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个<code>slot</code>上。</li><li>如果需要访问局部变量表中一个64位的局部变量值时，只需要使用前一个索引即可。</li><li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用<code>this</code>将会存放在<code>index</code>为0的<code>slot</code>处，其余的参数按照参数表顺序继续排列。</li></ul><p><strong>Slot 的重复利用</strong></p><p><strong>栈帧中的局部变量表中的槽位是可以重复利用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p><strong>静态变量与局部变量对比</strong></p><p>类变量有两次初始化的机会，一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次是在“初始化”阶段，赋予程序员在代码中定义的初始值。局部变量在使用前必须显式的赋值。</p><p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</strong></p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><ul><li>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出<code>(Last-In-First-Out)</code>的操作数栈，也可以称之为表达式栈<code>(Expression Stack)</code>。</li><li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈/出栈。</li><li>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。</li></ul><h3 id="栈顶缓存-Top-of-Stack-Cashing-技术"><a href="#栈顶缓存-Top-of-Stack-Cashing-技术" class="headerlink" title="栈顶缓存(Top-of-Stack-Cashing)技术"></a>栈顶缓存(Top-of-Stack-Cashing)技术</h3><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，也就需要更多的指令分派次数和内存读/写次数。由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。因此<code>HotSpot JVM</code>的设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理<code>CPU</code>的寄存器中，来降低对内存的读写次数，提升执行引擎的执行效率。</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中<strong>该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接<code>(Dynamic Linking)</code>。比如：<code>invokedynamic</code>指令。</p><p><img src="/2022/02/24/Jvm/20220214173916.png" alt="动态链接示意图"></p><p>常量池的作用：提供一些符号和常量，便于指令的识别。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2>]]></content>
    
    
    <categories>
      
      <category>Java后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库原理</title>
    <link href="/2021/12/03/Database/"/>
    <url>/2021/12/03/Database/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL-体系结构和存储引擎"><a href="#MySQL-体系结构和存储引擎" class="headerlink" title="MySQL 体系结构和存储引擎"></a>MySQL 体系结构和存储引擎</h1><p>MySQL 被设计成一个可移植数据库，几乎在当前所有系统上都能运行，如 Linux，Solaris，Mac 和 Windows。</p><p><strong>数据库和实例</strong></p><ul><li>数据库：物理操作系统文件或其他形式文件类型的集合。</li><li>实例：MySQL 数据库由后台线程以及一个共享内存区组成。数据库实例才是真正用于操作数据库文件的。</li></ul><p>MySQL 数据库实例在系统上的表现就是一个进程。</p><h2 id="MySQL-体系结构"><a href="#MySQL-体系结构" class="headerlink" title="MySQL 体系结构"></a>MySQL 体系结构</h2><p>MySQL 主要由以下几部分组成：</p><ul><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL 接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲（Cache）组件</li><li>插件式存储引擎</li><li>物理文件</li></ul><p><img src="/2021/12/03/Database/20211201205032.png" alt="MySQL 体系结构"></p><p>MySQL 数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎。<strong>存储引擎是基于表的，不是基于数据库的。</strong></p><h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h2><p>存储引擎的好处是，每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表。MySQL 默认使用 InnoDB 存储引擎，默认使用<strong>可重复读</strong>事务隔离级别。</p><div class="table-container"><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">MYISAM</th><th style="text-align:center">Memory</th><th style="text-align:center">InnoDB</th><th style="text-align:center">Archive</th></tr></thead><tbody><tr><td style="text-align:center">存储限制</td><td style="text-align:center">256 TB</td><td style="text-align:center">RAM</td><td style="text-align:center">64 TB</td><td style="text-align:center">None</td></tr><tr><td style="text-align:center">支持事务</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">支持全文索引</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">支持B 树索引</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">支持哈希索引</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">支持数据缓存</td><td style="text-align:center">No</td><td style="text-align:center">N/A</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">支持外键</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr></tbody></table></div><h3 id="MYISAM-和-InnoDB-的对比"><a href="#MYISAM-和-InnoDB-的对比" class="headerlink" title="MYISAM 和 InnoDB 的对比"></a>MYISAM 和 InnoDB 的对比</h3><p>比较常用的是 MYISAM 和 InnoDB，下面是两者的区别：</p><ol><li>存储结构上的区别。每个MyISAM在磁盘上存储成三个文件，分别是：表定义文件、数据文件和索引文件。而 InnoDB 所有的表都保存在同一个数据文件中；</li><li>InnoDB <strong>支持事务</strong>，MYISAM <strong>不支持事务</strong>。这也是 MySQL 将迷人存储引擎从 MYISAM 变成 InnoDB 的重要原因之一；</li><li>InnoDB <strong>支持外键</strong>，而 MYISAM <strong>不支持</strong>。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li><li>InnoDB 是<strong>聚集索引</strong>，MYISAM 是<strong>非聚集索引</strong>。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB <strong>必须要有主键</strong>，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的；</li><li>InnoDB <strong>不保存</strong>表的具体行数，执行<code>select count(*) from table</code>时需要全表扫描。而MyISAM 用一个变量<strong>保存</strong>了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。但是在加了 where 条件后， MyISAM 和 InnoDB 处理的方式都一样。</li><li>InnoDB 最小的锁粒度是<strong>行锁</strong>，MyISAM 最小的锁粒度是<strong>表锁</strong>。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一。</li><li>如果执行大量的 SELECT ，MyISAM 是更好的选择。如果你的数据执行大量的 INSERT 或 UPDATE ，出于性能方面的考虑，应该使用 InnoDB 表。</li></ol><p>InnoDB 的性能与自动崩溃恢复的特性，使得它在非事务存储需求中也很流行。除非有非常特别的原因需要使用其他的存储引擎，否则应该<strong>优先考虑 InnoDB 引擎</strong>。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ul><li>单列索引<ul><li>普通索引：MySQL 中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，只是为了查询数据更快一点。</li><li>唯一索引：索引列中的值必须是唯一的，但是允许为空值。</li><li>主键索引：是一种特殊的唯一索引，不允许有空值。一个表只能有一个主键。</li></ul></li><li>组合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的<strong>左边字段</strong>时，索引才会被使用，使用组合索引时遵循最左前缀集合。</li><li>全文索引：在大量数据中，通过其中的某个关键字，就能找到该字段所属的记录行。全文索引在开发中很少用，因为其占用很大的物理空间和降低了记录修改性。</li></ul><p>索引是一种数据结构 。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。InnoDB 存储引擎支持以下几种常见的索引：</p><ul><li><p><strong>B+ 树索引</strong></p><p>B+ 树索引就是传统意义上的索引，这是目前关系型数据库系统中查找最为常用和最为有效的索引。B+ 树索引类似于二叉树，根据键值快速找到数据，但它不是二叉树，B 代表 balance 而不是 binary。</p></li><li><p><strong>全文索引</strong></p><p>在 B 树索引中，当执行 <code>select * from blog where content like %xxxx%</code> 语句时，索引会失效。全文索引可以有效的解决这种语句查询。</p></li><li><p><strong>哈希索引</strong></p><p>InnoDB 存储引擎支持的哈希索引是自适应的，InnoDB 存储引擎会根据表的使用情况自动为表生成哈希索引，不能认为干预是否在一张表中生成哈希索引。</p></li></ul><p>【注意】B+ 树索引并不能找到一个给定键值的具体行，B+ 树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h2><p>B 树建立在二叉树和平衡二叉树的基础上。二叉树的每个节点只有一个元素而 B 树的每个节点可能包含多个元素，并且非叶子节点在元素的左右都有指向子节点的指针。</p><p>B 树的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少磁盘操作次数。B 树为系统最优化大块数据的读和写操作。</p><p>一颗 m 阶的 B 树的特性如下：</p><ol><li>每个节点最多 m 个子节点</li><li>除了根节点和叶子节点以外，每个节点最少有 m/2 个节点</li><li>如果根节点不是叶子节点，那根节点至少包含两个子节点</li><li>所有的叶子节点都位于同一层</li><li>每个节点都会包含 k 个元素（关键字），这里 <code>m/2&lt;= k &lt; m</code> </li><li>每个节点中的元素（关键字）从小到大排列</li><li>左节点元素的值小于该元素的值小于右节点元素的值</li></ol><p><img src="/2021/12/03/Database/20211202113632.png" alt="B 树"></p><p>普通的 B 树的节点中，元素就是一个个数字。上图中把元素部分拆分成了 key-data 的形式，key 就是数据的主键，data 就是具体的数据。这样查找的时候沿着根节点往下就可以了，因此效率比较高。</p><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h2><p>B+ 树是在 B 树基础上的优化，使其更适合实现外存储索引结构。</p><p>B+ 树的特性如下：</p><ol><li>所有的非叶子节点只存储关键字信息</li><li>所有具体数据存在叶子节点中</li><li>所有的叶子节点中包含了全部元素的信息</li><li>相邻叶子节点之间有一个链指针</li></ol><p><img src="/2021/12/03/Database/20211202114631.png" alt="B+ 树"></p><p><strong>B 树与 B+树的对比</strong></p><ul><li>B 树因为非叶子结点也保存具体数据，所以在查找某个关键字的时候<strong>找到即可返回</strong>。而B+Tree所有的数据都在叶子结点，每次查找都得到叶子结点。所以<strong>在同样高度的 B树 和 B+ 树中，B 树查找某个关键字的效率更高</strong>。</li><li>由于 B+ 树所有的数据都在叶子结点，并且结点之间有指针连接，在找<strong>大于某个关键字或者小于某个关键字的数据的时候，B+ 树只需要找到该关键字然后沿着链表遍历就可以了</strong>，而B 树还需要遍历该关键字结点的根结点去搜索。</li><li>由于 B 树的每个结点（这里的结点可以理解为一个数据页）都存储主键+实际数据，而 B+ 树非叶子结点只存储关键字信息，而每个页的大小有限是有限的，所以同一页能存储的 B 树的数据会比B+ 树存储的更少。这样<strong>同样总量的数据，B 树的深度会更大，增大查询时的磁盘I/O次数，进而影响查询效率。</strong></li><li>B+ 树的非叶子节点不包含数据信息，所有内存页中能存放更多的 key 。<strong>数据存放得更加紧密，具有更好的空间局部性</strong>。因此访问叶子节点上关联的数据页具有更好的缓存命中率。</li><li>B 树只适合随机检索，而 B+ 树同时支持随机检索和顺序检索。</li><li>B+ 树增删文件（节点）时，效率更高。因为 B+ 树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li></ul><p><strong>B+ 树的插入操作</strong></p><p>当节点元素数量大于 m-1 的时候，按中间元素分裂成左右两部分，<strong>中间元素</strong>分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的。</p><p><strong>B+ 树的删除操作</strong></p><p>由于叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于 m/2 ），然后更新父节点的索引；如果兄弟节点的元素不大于 m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的 key。</p><p>插入与删除操作图示可查看<a href="https://zhuanlan.zhihu.com/p/130482609">面试官问你B树和B+树，就把这篇文章丢给他 - 知乎</a></p><p>数据库中的 B+ 树索引可以分为聚集索引（clustered index）和辅助索引（secondary index），聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。</p><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>聚集索引就是按照每张表的<strong>主键</strong>构造一颗 B+ 树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。由于实际的数据页只能按照一颗 B+ 树进行排序，因此每张表只能拥有一个聚集索引。</p><h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>对于辅助索引，也称为非聚集索引，叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签（bookmark）。该书签用来告诉 InnoDB 存储引擎哪里可以找到与索引对应的行数据。由于 InnoDB 存储引擎表是索引组织表，因此 InnoDB 存储引擎的辅助索引的书签就是相应行数据的聚集索引键。每张表上可以有多个辅助索引。</p><h3 id="聚集索引与辅助索引的区别"><a href="#聚集索引与辅助索引的区别" class="headerlink" title="聚集索引与辅助索引的区别"></a>聚集索引与辅助索引的区别</h3><ul><li>一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。</li><li>聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。也将聚集索引的叶子节点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，<strong>每个数据页都通过一个双向链表来进行链接</strong>。</li><li>聚集索引的叶节点就是数据节点，而非聚集索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</li><li>MYISAM 和 InooDB 的主键索引实现方式不一样，InooDB 的叶子节点存储的<strong>完整的 data 记录（整行数据）</strong> ，而 MYISAM 的叶子节点存储的是<strong>数据的地址指针</strong>。</li><li>通过聚集索引可以一次查到需要查找的数据，而通过非聚集索引第一次只能查到记录对应的主键值 ，再使用主键的值通过聚集索引查找到需要的数据。从非聚集索引上找到对应的主键值然后到聚集索引上查找对应记录的过程为<strong>回表</strong>。</li></ul><p><strong>索引覆盖</strong>：覆盖索引指的是所查询的数据就在索引当中，无需回表重新再查一遍。</p><h2 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h2><ul><li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度</li><li>空间方面：索引需要占额外的物理空间</li></ul><h2 id="创建索引时的注意事项"><a href="#创建索引时的注意事项" class="headerlink" title="创建索引时的注意事项"></a>创建索引时的注意事项</h2><ol><li><p><strong>选择合适的字段创建索引</strong></p><ul><li><p>不为 null 的字段</p></li><li><p>被频繁查询的字段</p></li><li><p>被作为条件查询的字段</p></li><li><p>频繁需要排序的字段</p></li></ul></li><li><p><strong>被频繁更新的字段应该慎重建立索引</strong></p></li><li><p><strong>尽可能的考虑联合索引而不是单列索引</strong></p><ul><li>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的</li></ul></li><li><p><strong>注意避免冗余索引</strong></p><ul><li>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引</li></ul></li></ol><h2 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h2><ul><li>最左前缀原则，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边；</li><li>当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。</li></ul><h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><ol><li>在 where 子句中进行 null 值判断的话会导致引擎放弃索引而产生全表扫描；</li><li>在 where 子句中使用<code>!=</code>，<code>&lt; &gt;</code>这样的符号,否则会导致引擎放弃索引而产生全表扫描；</li><li>在 where 子句中使用<code>or</code>来连接条件，因为如果俩个字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描；</li><li>在 where 子句中<code>=</code>的左边使用表达式操作或者函数操作；</li><li>在 where 子句中使用<code>like</code>模糊查询；</li><li>在使用联合索引是要注意<strong>最左原则</strong>，例如如果当前联合索引是<code>index(a,b,c)</code>，那么如果 where 子句中有<code>a</code>就会用到联合索引，但是如果只用到<code>b,c</code>就会失去索引效果。</li></ol><h2 id="主键索引和唯一索引的区别"><a href="#主键索引和唯一索引的区别" class="headerlink" title="主键索引和唯一索引的区别"></a>主键索引和唯一索引的区别</h2><ol><li>对于主键/unique constraint ， oracle/sql server/mysql等都会自动建立唯一索引； </li><li>主键不一定只包含一个字段，所以在主键的其中一个字段建唯一索引还是有必要的； </li><li>主键可作外键，唯一索引不可； </li><li>主键不可为空，唯一索引可； </li><li>主键可是多个字段的组合； </li><li>主键索引一定是唯一索引， 唯一索引不是主键索引；</li><li>主键可以与外键 构成 参照完整性约束， 防止数据不一致</li></ol><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>数据库对数据的操作无非两种类型，读和写，针对这两个特点，目前有两种数据库的锁，乐观锁和悲观锁，区别在 于<strong>是否认为并发问题一定存在</strong>。</p><p><img src="/2021/12/03/Database/20211202170822.png" alt="数据库中的锁"></p><ul><li><strong>按锁的粒度划分</strong>：<ul><li>表级锁：表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。适合于有大量按索引条件并发更新少量不同数据，同时又有 并发查询的应用，如一些在线事务处理（OLTP）系统。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul></li><li><strong>按锁的级别划分</strong>：共享锁、排他锁</li><li><strong>按加锁方式分</strong>：自动锁（存储引擎自行根据需要施加的锁）、显式锁（用户手动请求的锁）</li><li><strong>按操作划分</strong>：DML 锁（对数据进行操作的锁)、DDL 锁（对表结构进行变更的锁）</li><li><strong>最后按使用方式划分</strong>：悲观锁、乐观锁</li></ul><p>MySQL 的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM 和 MEMORY 存储引擎采用的是<strong>表级锁</strong>（table-level locking）；BDB 存储引擎采用的是<strong>页面锁</strong>（page-level locking），但也支持表级锁；InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用<strong>行级锁</strong>。 </p><p><img src="/2021/12/03/Database/20211202173006.png" alt="MySQL 锁分类"></p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="共享锁-S"><a href="#共享锁-S" class="headerlink" title="共享锁 S"></a>共享锁 S</h3><p>共享锁又称为<strong>读锁</strong>，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br></code></pre></div></td></tr></table></figure><h3 id="排他锁-X"><a href="#排他锁-X" class="headerlink" title="排他锁 X"></a>排他锁 X</h3><p>排他锁又称为<strong>写锁</strong>，简称 X 锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> UPDATE; <br></code></pre></div></td></tr></table></figure><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向锁属于表锁，用于行锁和表锁共存。</p><p><strong>意向共享锁</strong>：在给一个数据行加共享锁时必须获取该表的 IS 锁。</p><p><strong>意向排他锁</strong>：在给一个数据行加共享锁时必须获取该表的 IX 锁。</p><p><img src="/2021/12/03/Database/20211202174118.png" alt="表级锁兼容性"></p><p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB 就将请求的锁授予该事务；反之，该事务就要等待锁释放。</p><p>【注意】</p><ol><li><strong>IX ，IS 是表级锁，不会和行级的 X，S 锁发生冲突。只会和表级的 X，S 锁发生冲突。</strong></li><li><strong>MySQL 行锁锁的是索引而不是实际的数据行。</strong></li></ol><p><strong>加意向锁表明某个事务正在锁定一行或者将要锁定一行</strong>。首先申请意向锁的动作是 InnoDB 完成的，怎么理解意向锁呢？</p><p>例如：事务 A 要对一行记录 r 进行上 X 锁，那么 InnoDB 会先申请表的 IX 锁，再锁定记录 r 的 X 锁。在事务 A 完成之前，事务 B 想要来个全表操作，此时直接在表级别的 IX 就告诉事务 B 需要等待而不需要在表上判断每一行是否有锁。<strong>意向排它锁存在的价值在于节约 InnoDB 对于锁的定位和处理性能。</strong></p><h3 id="InnoDB-有3种行锁的算法"><a href="#InnoDB-有3种行锁的算法" class="headerlink" title="InnoDB 有3种行锁的算法"></a>InnoDB 有3种行锁的算法</h3><ul><li><code>Record Lock</code>：单个行记录上的锁</li><li><p><code>Gap Lock</code>：间隙锁，锁定一个范围，而非记录本身，是 Innodb 在 Repeatable Read 隔离级别下为了解决幻读问题时引入的锁机制。</p></li><li><p><code>Next-Key Lock</code>：结合 Gap Lock 和 Record Lock ，锁定一个范围，并且锁定记录本身。主要解决的问题是 Repeatable Read 隔离级别下的<strong>幻读问题</strong>。</p></li></ul><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>在事务 A 执行过程中，事务 A 对数据资源进行了修改，事务B读取了事务A修改后的数据。由于某些原因，事务 A 并没有完成提交，发生了 RollBack 操作，则事务B读取的数据就是脏数据。这种读取到另一个事务未提交的数据的现象就是脏读（Dirty Read）。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>事务 B 前后两次读取同一个范围的数据，在事务 B 两次读取的过程中事务 A 新增了数据，导致事务 B 后一次<strong>读取到前一次查询没有看到的行</strong>。幻读和不可重复读有些类似，但是幻读强调的是集合的增减，而不是单条数据的更新。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>事务 B 读取了两次数据资源，在这两次读取的过程中事务 A  修改了数据，导致事务 B 在这两次读取出来的数据不一致。这种在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读（Nonrepeatable Read）。</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC，全程是<code>(Multi-Version Concurrency Control)</code>，即多版本并发控制，实际上就是保存了数据在某个时间节点的快照。</p><p>MVCC 只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作。其他两个隔离级别够和 MVCC 不兼容, 因为 <code>READ UNCOMMITTED</code> 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而SERIALIZABLE 则会对所有读取的行都加锁。</p><blockquote><p>最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，<strong>只有写写之间相互阻塞，其他三种操作都可以并行</strong>，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，<strong>通过undolog可以找回数据的历史版本</strong>。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在<strong>回滚的时候覆盖数据页上的数据</strong>。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p></blockquote><p><strong>当前读</strong>：读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p><p><strong>快照读</strong>：读取的是记录数据的可见版本（可能是过期的数据），不用加锁。像<strong>不加锁</strong>的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p><p>MVCC 就是为了实现读-写冲突不加锁，而这个读指的就是<strong>快照读</strong>，而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现。</p><h3 id="MySQL-事务日志"><a href="#MySQL-事务日志" class="headerlink" title="MySQL 事务日志"></a>MySQL 事务日志</h3><ul><li>Bin Log：是 MySQL <strong>服务层</strong>产生的日志，常用来进行数据恢复、数据库复制，常见的 MySQL 主从架构，就是采用 slave 同步 maste r的 binlog 实现的。</li><li>Redo Log：记录了数据操作在物理层面的修改，MySQL 中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生 redo log，在事务提交时进行一次 flush 操作，保存到磁盘中。当数据库或主机失效重启时，会根据 redo log 进行数据的恢复，如果 redo log 中有事务提交，则进行事务提交修改数据。</li><li>Undo Log：除了记录 redo log 外，当进行数据修改时还会记录 undo log ，undo log 用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据 undo log 回溯到某个特定的版本的数据，实现MVCC。</li></ul><h3 id="MVCC-实现"><a href="#MVCC-实现" class="headerlink" title="MVCC 实现"></a>MVCC 实现</h3><p>MVCC 模型在 MySQL 中的具体实现则是由 <code>3个隐式字段</code>，<code>undo日志</code> ，<code>Read View</code> 等去完成的。</p><p><strong>隐式字段</strong>：</p><ul><li><code>DB_TRX_ID</code>：数据库默认该行记录生成的唯一隐式主键</li><li><code>DB_ROLL_PTR</code>：回滚指针，用于配合 undo 日志，指向上一个旧版本</li><li><code>DB_ROW_ID</code>：当前操作该记录的事务 ID</li></ul><p><strong>undo日志</strong>：</p><ul><li><code>insert undo log</code>，代表事务在<code>insert</code>新纪录时产生的<code>undo log</code>，只在事务回滚时需要，并且在事务提交后可以被立即丢弃。</li><li><code>update undo log</code>，事务在<code>update</code>或<code>delete</code>时产生的<code>undo log</code>，不仅在事务回滚时需要，在快照读时也需要，所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被<code>purge</code>线程同一清除。</li></ul><p>对 MVCC 有帮助的实质是<code>update undo log</code></p><p><strong>Read View</strong>：</p><p>事务进行<strong>快照读</strong>操作的时候生产的<code>读视图(Read View)</code>，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的 ID 。ReadView 是一个包含当前已经开始但是没有提交的事务的列表，记录每个事务的事务id，记最小事务 ID 为 min_id ，最大事务 ID 为 max_id 。</p><p>版本比较规则：</p><ul><li>如果记录版本的事务 ID 小于 min_id ，说明这个记录版本是已经被提交过的，对其他事务可见；</li><li>如果记录版本的事务 ID 大于 max_id ，说明这个记录版本是 ReadView 生成之后发生的，不能访问；</li><li>如果记录版本的事务 ID 在 min_id 和 max_id 之间，判断事务 ID 是否在 ReadView 中：<ul><li>如果在 ReadView 中，说明事务还未提交，该记录版本不可访问</li><li>反之说明该事务已经提交，该记录版本可以访问</li></ul></li></ul><p>如果当前记录版本不可读，就根据回滚指针 roll_pointer 找到旧版本的记录再进行判断。</p><p>对于 RC ，每次查询都会生成一个新的 ReadView 。</p><p>对于 RR ，一个事务在第一次 SELECT 的时候生成一个 ReadView ，之后的查询复用这个 ReadView 。</p><p>MVCC 实现的简单理解可以参考文章<a href="https://www.jianshu.com/p/f692d4f8a53e">MYSQL MVCC实现原理 - 简书</a>。</p><p><strong>MVCC实现例子：</strong></p><p>假设当前有一个事务 id 为100的事务 A ，修改记录的 name 字段为 李四，产生一个版本快照，有下面的版本链：</p><p><img src="/2021/12/03/Database/20211203162457.png" alt="版本链示意图"></p><p>假设事务 A 还没有提交，此时事务 B 进行 SELECT ，事务 id 为 120，查询 id 为 1 的记录（记为第一次查询），此时生成 ReadView 为<code>[100,120]</code>，根据版本读取规则，先找到事务 id 为100的记录版本，发现不可读，于是通过回滚指针找到事务 id 为60的记录，读取成功。</p><p>当事务 A 提交之后，事务 B 再次进行 SELECT 查询 id 为1的记录（第二次查询），在 RC 和 RR 两种隔离级别下有不同的情况：</p><ul><li>如果是 RC ，则会创建一个新的ReadView为<code>[120]</code>，此时读取事务 id 为100的记录成功，也就是读取到了在事务期间提交的数据；</li><li>如果是 RR ，则会使用第一次查询时的ReadView为<code>[100,120]</code>，此时读取的是事务 id 为60的记录，从而实现了可重复读；</li></ul><h3 id="MVCC-如何在-RR-下解决幻读"><a href="#MVCC-如何在-RR-下解决幻读" class="headerlink" title="MVCC 如何在 RR 下解决幻读"></a>MVCC 如何在 RR 下解决幻读</h3><p>产生幻读的原因：<strong>行锁</strong>只能锁住一行，不能避免新插入的记录。</p><p>解决：</p><ul><li>在两行记录之间<strong>加上间隙锁</strong>，阻止新记录的插入，与间隙锁产生冲突的只有“往这个间隙插入记录”这个操作；</li><li>同时添加间隙锁与行锁称为 <strong>Next-key lock</strong> ，注意间隙锁只有在 InnoDB 的可重复读隔离级别下生效。</li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p><h2 id="四大特性（ACID）"><a href="#四大特性（ACID）" class="headerlink" title="四大特性（ACID）"></a>四大特性（ACID）</h2><ul><li><code>原子性（Atomicity）</code>：事务<strong>要么全部完成，要么全部取消</strong>。 如果事务崩溃，状态回到事务之前（事务回滚）。</li><li><code>隔离性（Isolation）</code>：如果2个事务 T1 和 T2 同时运行，事务 T1 和 T2 最终的结果是相同的，不管 T1和T2谁先结束。</li><li><code>持久性（Durability）</code>：一旦事务提交，不管发生什么（崩溃或者出错），数据要保存在数据库中。</li><li><code>一致性（Consistency）</code>：只有合法的数据（依照关系约束和函数约束）才能写入数据库。</li></ul><h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>事务的隔离性由<strong>锁</strong>来实现，原子性、一致性和持久性通过数据库的 redo log 和 undo log 来完成。redo log 称为重做日志，用来保证事务的持久性。undo log 用来保证事务的原子性。而事务的一致性是通过原子性，持久性，隔离性来实现的。</p><p>redo 恢复提交事务修改的页操作，而 undo 回滚行记录到某个特定版本。redo 通常是物理日志，记录的是页的物理修改操作。undo 是逻辑日志，根据每行记录进行记录。</p><h3 id="原子性的实现"><a href="#原子性的实现" class="headerlink" title="原子性的实现"></a>原子性的实现</h3><p>当进行插入，删除以及更新操作时生成 undo log，记录事务修改之前版本的数据信息，当系统发生错误或者执行 rollback 操作时需要根据 undo log 进行回滚。</p><p><img src="/2021/12/03/Database/20211203151812.png" alt="生成 undo log"></p><p><img src="/2021/12/03/Database/20211203151840.png" alt="回滚"></p><h3 id="持久性的实现"><a href="#持久性的实现" class="headerlink" title="持久性的实现"></a>持久性的实现</h3><p>MySQL 的表数据是存放在磁盘上的，因此想要存取的时候都要经历磁盘 IO ，然而即使是使用 SSD 磁盘 IO 也是非常消耗性能的，因此为了提升性能 InnoDB 提供了缓冲池（Buffer Pool），其中包含了含自盘数据页的映射，可以当作缓存来用。但这种机制也有新的问题，在 MySQL 系统宕机或者断电的时候可能会丢失数据。因为可能数据已经提交了但还在缓冲池中，没来得及磁盘持久化。</p><p>所以需要一种机制存一下已提交的事务，为恢复数据使用。red log 可达到这种效果，事务开始之后就产生 redo log ，redo log 的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo log 文件中。</p><h3 id="隔离性的实现"><a href="#隔离性的实现" class="headerlink" title="隔离性的实现"></a>隔离性的实现</h3><p>读写锁 + MVCC。</p><h3 id="一致性的实现"><a href="#一致性的实现" class="headerlink" title="一致性的实现"></a>一致性的实现</h3><p>通过原子性，持久性，隔离性来共同实现。</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul><li><p><code>Read Uncommited（读取未提交内容）</code></p><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p></li><li><p><code>Read Commited（读取提交内容）</code></p><p>这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。</p><p>这种隔离级别 也支持所谓的 不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理期间可能会有新的 commit ，所以同一 select 可能返回不同结果。</p></li><li><p><code>Repeatable Read（可重读）</code></p><p>这是 <strong>MySQL 的默认事务隔离级别</strong>，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。</p><p>可重复读隔离级别只允许读取已提交记录，而且在一个事务两次读取一个记录期间，其他事务不得更新该记录。</p><p>不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。InnoDB 和 Falcon 存储引擎通过多版本并发控制<code>（MVCC，Multiversion Concurrency Control）</code>机制解决幻读的问题。</p></li><li><p><code>Serializable（可串行化）</code></p><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p></li></ul><p>在 MySQL 中，实现了这四种隔离级别，分别有可能产生问题如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">Read Uncommited</td><td style="text-align:center">✔</td><td style="text-align:center">✔</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">Read Commited</td><td style="text-align:center">✘</td><td style="text-align:center">✔</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">Repeatable Read</td><td style="text-align:center">✘</td><td style="text-align:center">✘</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">Serializable</td><td style="text-align:center">✘</td><td style="text-align:center">✘</td><td style="text-align:center">✘</td></tr></tbody></table></div><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>将主数据库中的 DDL 和 DML 操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p><h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ol><li>主数据库出现问题，可以切换到从数据库。</li><li>可以进行数据库层面的读写分离。</li><li>可以在从数据库上进行日常备份。</li></ol><h3 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a>大表数据查询，怎么优化</h3><ol><li>优化 shema、sql 语句+索引；</li><li>加缓存，memcached，redis；</li><li>主从复制，读写分离；</li><li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li><li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的 sharding key , 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql 中尽量带 sharding key ，将数据定位到限定的表上去查，而不是扫描全部的表。</li></ol><h2 id="MySQL-慢查询"><a href="#MySQL-慢查询" class="headerlink" title="MySQL 慢查询"></a>MySQL 慢查询</h2><p>原因：</p><ol><li><strong>没有索引或者没有用到索引（这是查询慢最常见的问题，是程序设计的缺陷，面试最核心的问答点）</strong>；</li><li><strong>IO吞吐量小，形成了瓶颈</strong>；</li><li><strong>没有 创建计算列导致查询不优化</strong>；</li><li><strong>内存不足</strong>；</li><li><strong>网络速度慢</strong>；</li><li><strong>一次查询的数量过大</strong>；</li><li><strong>锁或者死锁（这是查询慢最常见的问题，是程序设计的缺陷)</strong>。</li></ol><p>MySQL 慢查询就是在日志中记录运行比较慢的SQL语句，下面是慢查询的<strong>优化步骤</strong>：</p><ol><li>查看运行效果，是否真的很慢，主要设置 SQL_NO_CACHE；</li><li>WHERE 条件单表查询，锁定最小返回记录表。这句话的意思是，把查询语句的 WHERE 都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高；</li><li>EXPLAIN 查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）；</li><li>ORDER BY LIMIT 形式的 SQL 语句，让排序的表优先查；</li><li>多去了解业务的使用场景；</li><li>加索引时，要参照建立索引的几大原则；</li><li>观察结果，不符合预期，则重新从1开始分析。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《MySQL 技术内幕 InnoDB 存储引擎 第2版》</li><li><a href="https://www.zhihu.com/question/20596402/answer/211492971">Mysql 中 MyISAM 和 InnoDB 的区别有哪些？- 知乎</a></li><li><a href="https://www.jianshu.com/p/5e0818b7c1ea">B、B+树的理解（数据库索引预热）- 简书</a></li><li><a href="https://www.cnblogs.com/wwxzdl/p/11089358.html">什么是B+树 - 博客园</a></li><li><a href="https://zhuanlan.zhihu.com/p/130482609">面试官问你B树和B+树，就把这篇文章丢给他 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/83011307">详解 BAT 面试中常考的数据库「锁」问题 - 知乎</a></li><li><a href="https://www.cnblogs.com/xuwc/p/13873611.html">MVCC详解 - xuwc - 博客园</a></li><li><a href="https://zhuanlan.zhihu.com/p/352470916">关于MVCC，我之前写错了，这次我改好了！- 知乎</a></li><li><a href="https://www.jianshu.com/p/f692d4f8a53e">MYSQL MVCC实现原理 - 简书</a></li><li><a href="https://zhuanlan.zhihu.com/p/408075372">你说熟悉MySQL事务，那来谈谈事务的实现原理吧！-  知乎</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁</title>
    <link href="/2021/11/28/DistributedLock/"/>
    <url>/2021/11/28/DistributedLock/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 与分布式锁相对应的是<strong>单机锁</strong>，我们在写多线程程序时，避免同时操作一个共享变量产生数据问题，通常会使用一把锁来<strong>互斥</strong>，以保证共享变量的正确性，其适用范围是在<strong>同一个进程中</strong>。</p><p>那么换做是多个进程同时操作一个共享资源，这些资源已经不是在<strong>线程</strong>之间共享了，而是属于<strong>进程</strong>之间共享的资源。比如一个应用部署到几台机器上做负载均衡，如下图：</p><p><img src="/2021/11/28/DistributedLock/20211126093842.png" alt="多个进程操作一个变量"></p><p>如上图所示，变量 A 存在三个服务器的内存中（这个变量 A 主要体现是在一个类中的一个成员变量，是一个有状态的对象），如果不加任何控制的话，变量 A 同时会再分配一块内存，三个请求发过来同时对这个变量操作，显然结果是不对的。即使不是同时发送过来，单个请求分别操作三个不同内存区域的数据，变量 A 之间不存在共享，也不具有可见性，处理的结果也是不对的。</p><p>由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的应用并不能提供分布式锁的能力。为了解决这个问题就需要一种跨机器的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。</p><h1 id="分布式锁应该具备的条件"><a href="#分布式锁应该具备的条件" class="headerlink" title="分布式锁应该具备的条件"></a>分布式锁应该具备的条件</h1><p>分布式锁：是指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。</p><ol><li>在分布式系统环境下，一个方法在同一时间段只能被一个机器的一个线程执行</li><li>高可用和的获取锁和释放锁</li><li>高性能的获取锁和释放锁</li><li>具备可重入特性</li><li>具备锁失效机制，防止死锁</li><li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</li></ol><h1 id="分布式锁的三种实现方式"><a href="#分布式锁的三种实现方式" class="headerlink" title="分布式锁的三种实现方式"></a>分布式锁的三种实现方式</h1><p>分布式场景中的数据一致性问题一直是一个比较重要的话题。</p><blockquote><p>分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性<code>(Consistency)</code>、可用性<code>(Availability)</code>和分区容错性<code>(Partition tolerance)</code>，最多只能同时满足<strong>两项</strong>。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要<strong>牺牲强一致性来换取系统的高可用性</strong>，系统往往只需要保证“<strong>最终一致性</strong>”，只要这个最终时间是在用户可以接受的范围内即可。</p></blockquote><p>目前主流的实现方式有三种从实现的复杂度上来看，从上往下难度依次增加：</p><ol><li>基于数据库实现</li><li>基于 Redis 实现</li><li>基于 ZooKeeper 实现</li></ol><h2 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h2><p>基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含<strong>方法名</strong>等字段，并在<strong>方法名字段上创建唯一索引</strong>，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p><ol><li>创建一个表</li></ol><p><img src="/2021/11/28/DistributedLock/20211126102503.png" alt="数据库表"></p><ol><li><p>若要执行某个方法，就使用这个方法名向表中插入数据</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> method_lock (method_name, <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;methodName&#x27;</span>, <span class="hljs-string">&#x27;测试的methodName&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>因为对<code>method_name</code>做了<strong>唯一性约束</strong>，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p></li><li><p>成功插入则获取锁，执行完成后删除对应的行数据释放锁</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> method_lock <span class="hljs-keyword">where</span> method_name <span class="hljs-operator">=</span><span class="hljs-string">&#x27;methodName&#x27;</span>;<br></code></pre></div></td></tr></table></figure></li></ol><p><strong>缺点</strong>：</p><ul><li>数据库的可用性和性能将直接影响分布式锁的可用性和性能，所以数据库需要双机部署、数据同步、主备切换。</li><li>不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁。</li><li>没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据。</li><li>不具备阻塞锁特性，获取不到锁直接返回失败</li></ul><h2 id="基于-ZooKeeper-的实现方式"><a href="#基于-ZooKeeper-的实现方式" class="headerlink" title="基于 ZooKeeper 的实现方式"></a>基于 ZooKeeper 的实现方式</h2><p>ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：</p><ol><li>创建一个目录<code>mylock</code></li><li>线程 A 想获取锁就在 <code>mylock</code>目录下创建临时顺序节点</li><li>获取<code>mylock</code>目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁</li><li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点</li><li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁</li></ol><p><strong>优点</strong>：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。</p><p><strong>缺点</strong>：因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p><h2 id="基于-Redis-的实现方式"><a href="#基于-Redis-的实现方式" class="headerlink" title="基于 Redis 的实现方式"></a>基于 Redis 的实现方式</h2><p>选用 Redis 实现分布式锁的原因：</p><ul><li>Redis 性能比较高</li><li>Redis 命令对此支持较好，实现起来比较方便</li></ul><p>【分析】</p><ol><li><p><strong>实现分布式锁</strong></p><p>使用<code>SETNX</code>命令，表示<code>SET if Not eXists</code>，即如果 key 不存在，才会设置它的值，否则不做操作。返回1表示加锁成功，0表示加锁失败。</p><p>加锁成功的客户端就可以去操作<strong>共享资源</strong>，操作完成后及时释放锁，使用<code>DEL</code>命令删除这个 key 即可释放锁。</p><p><img src="/2021/11/28/DistributedLock/20211126110029.png" alt="整体流程"></p><p><strong>缺陷</strong>：出现死锁。</p><p>原因：客户端1拿到锁后，业务处理异常没有及时释放锁或者进程挂了没有释放锁，那么其他客户端就会一直拿不到这个锁了</p></li><li><p><strong>如何避免死锁</strong></p><p>给这个 key 设置一个<strong>过期时间</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">SETNX lock 1    // 加锁<br>EXPIRE lock 10  // 10s后自动过期<br></code></pre></div></td></tr></table></figure><p><strong>缺陷</strong>：依旧可能发生死锁</p><p>原因：加锁和过期是2条命令，可能出现只执行了第一条，发生异常情况第2条来不及执行的情况，所以过期时间设置失败</p><p>在 Redis 2.6.12 之后，Redis 扩展了 SET 命令的参数</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">SET lock 1 EX 10 NX  // 一条命令保证原子性执行<br></code></pre></div></td></tr></table></figure><p>这样可以解决死锁问题，但是还存在两个严重的问题：</p><ol><li><strong>锁过期</strong>：客户端 1 操作共享资源耗时太久，导致锁被自动释放，之后被客户端 2 持有</li><li><strong>释放别人的锁</strong>：客户端 1 操作共享资源完成后，却又释放了客户端 2 的锁</li></ol><p>锁被别人释放的解决办法是客户端在加锁时，设置一个<strong>唯一标识</strong>进去，然后在释放锁时，先判断这把锁是否是自己的，伪代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-comment">// 锁是自己的，才释放</span><br><span class="hljs-keyword">if</span> redis<span class="hljs-selector-class">.get</span>(<span class="hljs-string">&quot;lock&quot;</span>) == <span class="hljs-variable">$uuid</span>:<br>    redis<span class="hljs-selector-class">.del</span>(<span class="hljs-string">&quot;lock&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>这里释放锁使用的是<code>GET + DEL</code>两条命令，因此又会出现前面的原子性问题，当客户端1执行<code>GET</code>判断锁是自己的后，客户端2执行了<code>SET</code>命令强制获取到锁，此时客户端1执行<code>DEL</code>却释放了客户端2的锁。</p><p><code>Lua</code>脚本可以解决这个问题。</p><p>Redis 处理请求是<strong>单线程</strong>执行的，因此执行一个<code>Lua</code>脚本时，其他请求必须等待，这样一来，<code>GET + DEL</code>就不会插入其他命令了。</p><p>安全释放锁的 Lua 脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">// 判断锁是自己的，才释放<br><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;GET&quot;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;DEL&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>【小结】</p><p>目前为止，基于 Redis 实现的分布式锁的流程如下：</p><ul><li>加锁：</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">SET $lock_key $unique_id EX $expire_time NX<br></code></pre></div></td></tr></table></figure><ul><li>操作共享资源</li><li>释放锁：<code>Lua</code>脚本，先判断锁是否是自己的，再释放</li></ul><p><img src="/2021/11/28/DistributedLock/20211126112534.png" alt="流程图"></p></li><li><p><strong>锁过期时间不好评估怎么办？</strong></p><p>解决方案：加锁时，先设置一个<strong>过期时间</strong>，然后开启一个<strong>守护进程</strong>，定时去检测这个锁的失效时间，如果锁要过期了，操作共享资源还没有完成， 那么就对锁进程<strong>续期</strong>，重新设置过期时间。</p><p>若使用<code>Java</code>技术栈，那么可以使用<code>Redisson</code>。<code>Redisson</code>是一个 <code>Java</code>实现的 <code>Redis SDK</code>客户端，在使用分布式锁时，它就采用了<strong>自动续期</strong>的方案来避免锁过期，这个守护进程我们一般也把它叫做<strong>看门狗</strong>线程。</p><p><a href="https://github.com/redisson/redisson">Redisson-Redis Java客户端</a></p><p>【小结】</p><p>前面的问题及解决方案如下：</p><ul><li>死锁：设置过期时间</li><li>过期时间评估不好，锁提前过期：守护进程， 自动续期</li><li>锁被别人释放：锁写入唯一标识，释放锁线检查标识，再释放</li></ul></li><li><p><strong>Redis 集群模式发生主从切换时，这个分布式锁安全吗？</strong></p><p>之前分析的场景都是锁在<strong>单个</strong> Redis 实例中可能产生的问题，并没有涉及到 Redis 的部署架构细节，但在使用 Redis 时，一般会采用<strong>主从集群 + 哨兵</strong>的模式部署。</p><p>下面有一个场景：</p><ol><li>客户端 1 在主库上执行 SET 命令，加锁成功</li><li>此时，主库异常宕机，SET 命令还未同步到从库上（主从复制是异步的）</li><li>从库被哨兵提升为新主库，这个锁在新的主库上，丢失了</li></ol><p><img src="/2021/11/28/DistributedLock/20211126115458.png" alt="场景示意图"></p><p>解决方案：<strong>Redlock （红锁）</strong>。</p></li><li><p><strong>Redlock</strong></p><p>Redlock 的方案基于2个前提：</p><ol><li>不再需要部署<strong>从库</strong>和<strong>哨兵</strong>实例，只部署<strong>主库</strong>，他们之间没有任何关系，都是孤立的实例</li><li>但主库要部署多个，官方推荐至少5个</li></ol><p><img src="/2021/11/28/DistributedLock/20211126121327.png" alt="部署5个简单的Redis实例"></p><p>Redlock 的具体使用：</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 &gt;=3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol></li></ol><h1 id="基于-Redis-的分布式锁的实现"><a href="#基于-Redis-的分布式锁的实现" class="headerlink" title="基于 Redis 的分布式锁的实现"></a>基于 Redis 的分布式锁的实现</h1><ol><li><p><code>Redisson</code><strong>实现简单分布式锁</strong></p></li><li><p><code>Redis</code><strong>自定义注解实现分布式锁</strong>：<code>SpringBoot</code> + <code>Jedis</code> + <code>AOP</code></p></li></ol><p>源码地址：<a href="https://gitee.com/acacac13/redis-lock">redis-lock</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/liuqingzheng/p/11080501.html">什么是分布式锁？实现分布式锁的三种方式 - 刘清政的博客</a></li><li><a href="https://www.zhihu.com/question/452803310/answer/1933678024">使用Redis实现分布式锁和ZK实现分布式锁有什么区别，分别有哪些场景? - 知乎</a></li><li><a href="https://juejin.cn/post/6844903830442737671#heading-16">基于Redis的分布式锁实现 - 掘金</a></li><li><a href="https://www.cnblogs.com/xiaoxiongcanguan/p/10718202.html">基于redis的分布式锁实现 - 博客园</a></li><li><a href="https://www.cnblogs.com/carrychan/p/9431137.html">Springboot分布式锁实践（redis）- 博客园</a></li><li><a href="https://blog.csdn.net/litterfrog/article/details/83377589">实现基于redis的分布式锁并集成spring-boot-starter - CSDN</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网学习笔记</title>
    <link href="/2021/11/13/ComputerNetwork/"/>
    <url>/2021/11/13/ComputerNetwork/</url>
    
    <content type="html"><![CDATA[<h1 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h1><ul><li>网络（Network）由若干<strong>结点</strong>（Node）和连接这些结点的<strong>链路</strong>（Link）组成。</li><li>多个网络还可以通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网。</li><li>因特网（Internet）是世界上最大的互联网络（用户数以亿计，互连的网络数以百万计）。</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211101192730.png" alt="因特网发展的三个阶段"></p><blockquote><p>ISP（Internet Service Provider）因特网服务提供者，普通用户接入因特网的过程就是通过ISP。</p><p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等连网设备。任何机构或个人只要向ISP缴纳费用，就可以从ISP得到所需要的IP地址。（因特网上的主机必须有IP地址才能通信）</p></blockquote><p><img src="/2021/11/13/ComputerNetwork/20211101193403.png" alt="基于ISP的三层结构的因特网示意图"></p><p><strong>因特网组成：</strong></p><ul><li>边缘部分<ul><li>由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</li></ul></li><li>核心部分<ul><li>由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。</li></ul></li></ul><p><img src="/2021/11/13/ComputerNetwork/20211101194132.png" alt="因特网的组成"></p><h1 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h1><h2 id="电路交换（Circuit-Switching）"><a href="#电路交换（Circuit-Switching）" class="headerlink" title="电路交换（Circuit Switching）"></a>电路交换（Circuit Switching）</h2><ul><li>电话交换机接通电话线的方式称为电路交换</li><li>从通信资源的分配角度来看，交换就是按照某种方式动态地分配传输线路的资源</li><li>电路交换的三个步骤：<ul><li>建立连接（分配通信资源）</li><li>通话（一直占用通信资源）</li><li>释放连接（归还通信资源）</li></ul></li></ul><p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p><h2 id="分组交换（Packet-Switching）"><a href="#分组交换（Packet-Switching）" class="headerlink" title="分组交换（Packet Switching）"></a>分组交换（Packet Switching）</h2><ul><li>发送方：构造分组，发送分组</li><li>路由器：缓存分组，转发分组（存储转发）</li><li>接收方：接收分组，还原报文</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211101194820.png" alt="分组交换"></p><h2 id="报文交换（Message-Switching）"><a href="#报文交换（Message-Switching）" class="headerlink" title="报文交换（Message Switching）"></a>报文交换（Message Switching）</h2><p>也采用存储转发的方式</p><p><img src="/2021/11/13/ComputerNetwork/20211101195225.png" alt="三种交换的对比"></p><p><strong>三种交换的对比：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:center">电路交换</td><td style="text-align:left">1. 通信时延小<br>2. 有序传输<br>3. 没有冲突<br>4. 适用范围广<br>5. 实时性强<br>6. 控制简单</td><td style="text-align:left">1. 建立连接时间长<br>2. 线路独占，使用效率低<br>3. 灵活性差<br>4. 难以规格化</td></tr><tr><td style="text-align:center">报文交换</td><td style="text-align:left">1. 无需建立连接<br>2. 动态分配线路<br>3. 提高线路可靠性<br>4. 提高线路利用率<br>5. 提供多目标服务</td><td style="text-align:left">1. 引起了转发时延<br>2. 需要较大的存储缓存空间<br>3. 需要传输额外的信息量</td></tr><tr><td style="text-align:center">分组交换</td><td style="text-align:left">1. 无需建立连接<br>2. 线路利用率高<br>3. 简化了存储管理<br>4. 加速传输<br>5. 减少出错概率和重发数据量</td><td style="text-align:left">1. 引起了转发时延<br>2. 需要传输额外的信息量<br>3. 对于数据报服务，存在失序、丢失或虫回复分组的问题；<br>    对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程</td></tr></tbody></table></div><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>最简单的定义：一些<strong>互连</strong>、<strong>自治</strong>的计算机的集合。</p><p>计算机网络较好的定义是：计算机网络主要是由一些<strong>通用的、可编程的硬件</strong>互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用</strong>。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>按交换技术分：电路交换网络、报文交换网络、分组交换网络</li><li>按使用者分：公用网、专用网</li><li>按传输介质分：有线网络、无线网络</li><li>按覆盖范围分：广域网<code>WAN</code>、城域网<code>MAN</code>、局域网<code>LAN</code>、个域网<code>PAN</code></li><li>按拓扑结构分：总线型网络、星型网络、环型网络、网状型网络</li></ul><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><ul><li>速率</li><li>带宽</li><li>吞吐量</li><li>时延<ul><li>发送时延 = 分组长度（b）/ 发送速率（b/s）</li><li>传播时延 = 信道长度（m）/ 电磁波传播速率（m/s）</li><li>处理时延：一般不便于计算，忽略</li></ul></li><li>时延带宽积<ul><li>时延带宽积  = 传播时延 x 带宽</li></ul></li><li>往返时间</li><li>利用率<ul><li>信道利用率：用来表示某信道有百分之几的时间是被利用的（有数据通过）</li><li>网络利用率：全网络的信道利用率的加权平均</li></ul></li><li>丢包率</li></ul><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="/2021/11/13/ComputerNetwork/20211101202615.png" alt="计算机网络体系结构"></p><p><img src="/2021/11/13/ComputerNetwork/20211101202742.png" alt="常见的加算计网络体系结构"></p><h2 id="计算机网络体系结构分层的必要性"><a href="#计算机网络体系结构分层的必要性" class="headerlink" title="计算机网络体系结构分层的必要性"></a>计算机网络体系结构分层的必要性</h2><ul><li>应用层：解决通过应用进程的交互来实现特定网络应用的问题</li><li>运输层：解决进程之间基于网络发通信问题</li><li>网络层：解决分组在多个网络上传输（路由）的问题</li><li>数据链路层：解决分组在一个网络（或一段链路）上传输的问题</li><li>物理层：解决使用何种信号来传输比特的问题</li></ul><h2 id="计算机网络中的专用术语"><a href="#计算机网络中的专用术语" class="headerlink" title="计算机网络中的专用术语"></a>计算机网络中的专用术语</h2><ul><li><p>实体：任何可发送或接收信息的硬件或软件进程</p><ul><li>对等实体：收发双方相同层次中的实体</li></ul></li><li><p>协议：控制两个对等实体进行逻辑通信的规则的集合</p><ul><li>三要素：语法、语义、同步</li></ul><p>语法：定义所交换信息的格式</p><p>语义：定义收发双方所要完成的操作</p><p>同步：定义收发双方的时序关系</p></li><li><p>服务：在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务</p></li><li><p>服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型</p><ul><li>数据链路层的服务访问点为帧的“类型”字段。</li><li>网络层的服务访问点为IP数据报首部中的“协议字段”。</li><li>运输层的服务访问点为“端口号”。</li></ul></li><li><p>服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。</p></li><li><p>协议数据单元<code>PDU</code>：对等层次之间传送的数据包称为该层的协议数据单元。</p></li><li><p>服务数据单元<code>SDU</code>：同一系统内，层与层之间交换的数据包称为服务数据单元。</p></li><li><p>多个<code>SDU</code>可以合成为一个<code>PDU</code>；一个<code>SDU</code>也可划分为几个<code>PDU</code>。</p></li></ul><p>==协议是”水平的“，服务是”垂直的“。==</p><p><img src="/2021/11/13/ComputerNetwork/20211101205703.png" alt="上述专业术语示意图"></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</p><h2 id="物理层协议的主要任务"><a href="#物理层协议的主要任务" class="headerlink" title="物理层协议的主要任务"></a>物理层协议的主要任务</h2><ul><li>机械特性：指明接口所用接线器的<strong>形状</strong>和<strong>尺寸</strong>、<strong>引脚数目</strong>和<strong>排列</strong>、<strong>固定</strong>和<strong>锁定</strong>装置。</li><li>电气特性：指明在接口电缆的各条线上出现的<strong>电压的范围</strong>。</li><li>功能特性：指明某条线上出现的某一电平的<strong>电压表示何种意义</strong>。</li><li>过程特性：指明对于不同功能的各种可能<strong>事件的出现顺序</strong>。</li></ul><h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><p> 导引型传输媒体：同轴电缆、双绞线、光纤、电力线</p><p>非导引型传输媒体：无线电波、微波、红外线、可见光</p><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><ul><li><p>串行传输</p></li><li><p>并行传输</p></li></ul><ul><li><p>同步传输</p><p>收发双方时钟同步的方法</p><ul><li>外同步：在收发双方之间添加一条单独的时钟信号线</li><li>内同步：发送端将时钟同步信号编码到发送数据中一起传输（例如曼彻斯特编码）</li></ul></li><li><p>异步传输</p><ul><li>字节之间异步（字节之间的时间间隔不固定）</li><li>字节中的每个比特仍然要同步（各比特的持续时间是相同的）</li></ul></li></ul><ul><li>单向通信（单工）</li><li>双向交替通信（半双工）</li><li>双向同时通信（全双工）</li></ul><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><p>奈氏准则：在假定的理想条件下，为了避免码间串扰，码元传输速率是有上限的    （W指带宽）</p><p><img src="/2021/11/13/ComputerNetwork/20211101213359.png" alt="奈氏准则"></p><p>香农公式：</p><p><img src="/2021/11/13/ComputerNetwork/20211101213026.png" alt="香农公式"></p><p>在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用<strong>多元制</strong>（更好的调制方法）和努力<strong>提高信道中的信噪比</strong>。</p><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p><img src="/2021/11/13/ComputerNetwork/20211103091136.png" alt="常用编码"></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p><img src="/2021/11/13/ComputerNetwork/20211103091459.png" alt="数据链路层在网络体系结构中所处的地位"></p><p><strong>链路（Link）</strong>就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。</p><p><strong>数据链路（Data Link）</strong>是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。</p><p>数据链路层以<strong>帧</strong>为单位传输和处理数据。</p><p><img src="/2021/11/13/ComputerNetwork/20211103091608.png" alt="数据链路层"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用点对点信道的数据链路层的三个重要问题</p><ul><li>封装成帧</li><li>差错检测</li><li>可靠传输</li></ul><p>尽管误码是不能完全避免的，但若能实现发送方发送什么，接收方就能收到什么，就称为可靠传输。</p><p>使用广播信道的数据链路层</p><ul><li>共享式以太网的媒体接入控制协议<code>CSMA/CD</code></li><li>802.11局域网的媒体接入控制协议<code>CSMA/CA</code></li></ul><p>数据链路层的互连设备</p><ul><li>网桥和交换机的工作原理</li><li>集线器（物理层互连设备）与交换机的区别</li></ul><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之称为帧。</p><ul><li>帧头和帧尾中包含有重要的控制信息</li><li>帧头和帧尾的作用之一就是<strong>帧定界</strong></li></ul><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，就好像数据链路层不存在一样。</p><p>（即数据部分含有与帧首尾相同的字符或比特，此时应该加上转义字符）</p><ul><li>面向字节的物理链路使用字节填充（或称字符填充）的方法实现透明传输</li><li>面向比特的物理链路使用比特填充的方法实现透明传输</li></ul><p>为了提高帧的传输效率，应当使<strong>帧的数据部分的长度尽可能大些</strong>。</p><p>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即<strong>最大传送单元MTU</strong>（Maximum Transfer Unit）。</p><p><img src="/2021/11/13/ComputerNetwork/20211103095110.png" alt="帧"></p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1。这称为<strong>比特差错</strong>。</p><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率BER</strong>（Bit Error Rate）。</p><p>使用<strong>差错检测码</strong>来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</p><p><strong>奇偶校验</strong></p><ul><li>在待发送的数据后面<strong>添加1位奇偶校验位</strong>，使整个数据（包括所添加的校验位在内）中<strong>“1”的个数</strong>为奇数（奇校验）或偶数（偶校验）。</li><li>如果有<strong>奇数个位发生误码</strong>，则奇偶性发生变化，<strong>可以检查出误码</strong>；</li><li>如果有<strong>偶数个位发生误码</strong>，则奇偶性发生变化，<strong>不能检查出误码（漏检）</strong>；</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211103100000.png" alt="奇校验和偶校验"></p><p><strong>循环冗余校验CRC（Cyclic Redundancy Check）</strong></p><ul><li>收发双方约定好一个<strong>生成多项式G(x)</strong>；</li><li>发送方基于待发送的数据和生成多项式计算出差错检测码（<strong>冗余码</strong>），将其添加到待传输数据的后面一起传输；</li><li>接收方通过生成多项式来计算收到的数据是否产生了误码；</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211103100811.png" alt="循环冗余校验CRC"></p><p><strong>检错码</strong>只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此无法<strong>纠正错误</strong>。</p><p>要想纠正传输中的差错，可以使用冗余信息更多的<strong>纠错码</strong>进行<strong>前向纠错</strong>。但纠错码的开销比较大，在<strong>计算机网络中较少使用</strong>。</p><p>循环冗余校验<strong>CRC</strong>有很好的检错能力（<strong>漏检率非常低</strong>），虽然计算比较复杂，但非常<strong>易于用硬件实现</strong>，因此被<strong>广泛应用于数据链路层</strong>。</p><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><ul><li><p>使用<strong>差错检测技术</strong>（例如循环冗余校验CRC），接收方的数据链路层就可检测出帧在传输过程中是否产生了<strong>误码</strong>（比特错误）。</p></li><li><p>数据链路层向上提供的服务类型</p><ul><li><strong>不可靠传输服务</strong>：<strong>仅仅丢弃有误码的帧</strong>，其他什么也不做；</li><li><strong>可靠传输服务</strong>：想办法实现<strong>发送端发送什么</strong>，<strong>接收端就收到什么</strong>。</li></ul></li><li><p>一般情况下，<strong>有线链路</strong>的误码率比较低，为了减小开销，并<strong>不要求数据链路层</strong>向上提供可靠传输服务。即使出现了误码，<strong>可靠</strong>传输的问题由其上层处理。</p></li><li><p><strong>无线链路</strong>易受干扰，误码率比较高，因此<strong>要求数据链路层</strong>必须向上层提供<strong>可靠</strong>传输服务。</p></li><li><p><strong>比特差错</strong>只是传输差错中的一种。</p></li><li><p>从整个计算机网络体系结构来看，传输差错还包括<strong>分组丢失</strong>、<strong>分组失序</strong>以及<strong>分组重复</strong>。</p></li><li><p>分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。</p></li><li><p><strong>可靠传输服务并不仅局限于数据链路层</strong>，其他各层均可选择实现可靠传输。</p><p><img src="/2021/11/13/ComputerNetwork/20211103104455.png" alt="可靠传输"></p></li><li><p>可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用要求。</p></li></ul><h3 id="可靠传输的实现机制-—-停止-等待协议SW"><a href="#可靠传输的实现机制-—-停止-等待协议SW" class="headerlink" title="可靠传输的实现机制 — 停止-等待协议SW"></a>可靠传输的实现机制 — 停止-等待协议SW</h3><p><img src="/2021/11/13/ComputerNetwork/20211103203228.png" alt="停止-等待协议SW"></p><p>【注意事项】</p><ul><li>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方<strong>尽早重传</strong>，也可<strong>给发送方发送NAK分组</strong>。</li><li>为了让接收方能够判断所收到的数据分组是否是重复的，需要给<strong>数据分组编号</strong>。由于停止-等待协议的停等特性，<strong>只需1个比特编号</strong>就够了，即编号0和1。</li><li>为了让发送方能够判断所收到的ACK分组是否是重复的，需要给<strong>ACK分组编号</strong>，所用比特数量<strong>与数据分组编号所用比特数量一样</strong>。数据链路层一般不会出现ACK分组迟到的情况，因此在<strong>数据链路层实现停止-等待协议可以不用给ACK分组编号</strong>。</li><li>超时计时器设置的<strong>重传时间</strong>应仔细选择。一般可将重传时间选为<strong>略大于“从发送方到接收方的平均往返时间”</strong>。<ul><li>在数据链路层点对点的往返时间比较确定，重传时间比较好设定。</li><li>然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。</li></ul></li><li>当往返时延<code>RTT</code>远大于数据帧发送时延<code>TD</code>时（例如使用卫星链路)，信道利用率非常低。</li></ul><p>停止-等待协议的信道利用率如下（一般<code>TA</code>远小于<code>TD</code>）</p><script type="math/tex; mode=display">U = \frac{T_D}{T_D + RTT + T_A} \approx \frac{T_D}{T_D + RTT}</script><p><img src="/2021/11/13/ComputerNetwork/20211103204247.png" alt="信息传输示意图"></p><h3 id="可靠传输的实现机制-—-回退N帧协议GBN（Go-Back-N）"><a href="#可靠传输的实现机制-—-回退N帧协议GBN（Go-Back-N）" class="headerlink" title="可靠传输的实现机制 — 回退N帧协议GBN（Go-Back-N）"></a>可靠传输的实现机制 — 回退N帧协议GBN（Go-Back-N）</h3><p><img src="/2021/11/13/ComputerNetwork/20211104091957.png" alt="无差错情况"></p><p><img src="/2021/11/13/ComputerNetwork/20211104093038.png" alt="累积确认（ACK1丢失）"></p><p><img src="/2021/11/13/ComputerNetwork/20211104093428.png" alt="有差错情况"></p><p>在有差错情况中，尽管序号为6，7，0，1的数据分组正确到达接受方，但由于5号数据分组误码不被接受，它们也“受到牵连”而不被接受，发送方还要重传这些数据分组，这就是所谓的<code>Go-back-N</code>（回退N帧）。</p><p>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议。</p><p>可见，当通信线路质量不好的时候，回退N帧协议的信道利用率并不比停止-等待协议高。</p><p><img src="/2021/11/13/ComputerNetwork/20211104094207.png" alt="WT超过取值范围时"></p><p>【小结】</p><p><strong>发送方</strong></p><ul><li>发送窗口尺寸<code>WT = 1</code>时，为停止-等待协议，<code>WT &gt; 2^n - 1</code>时，接收方会无法分辨新旧数组。</li><li>发送方只有收到对已发送数据分组的确认时，发送窗口才能向前相应滑动。</li><li>发送方收到多个重复确认时，可在重传计时器超时前尽早开始重传，由具体实现决定。</li></ul><p><strong>接收方</strong></p><ul><li>接收方的接收窗口尺寸<code>WR</code>的取值范围是<code>WR = 1</code>，因此接收方只能按序接收数据分组。</li><li>接收方可以连续收到好几个按序到达且无误码的数据分组后，才针对最后一个数据分组发送确认分组，称为累积确认。</li><li>接收方收到未按序到达的数据分组，除丢弃外，还要对最近按序接收的数据分组进行确认。</li></ul><h3 id="可靠传输的实现机制-—-选择重传协议SR"><a href="#可靠传输的实现机制-—-选择重传协议SR" class="headerlink" title="可靠传输的实现机制 — 选择重传协议SR"></a>可靠传输的实现机制 — 选择重传协议SR</h3><p><strong>回退N帧协议</strong>的接收窗口尺寸<strong><code>WR</code>只能等于1</strong>，一个数据分组的误码会导致后续多个数据分组不能被接收而丢弃，会造成对通信资源的浪费。为了提高性能，可以设法只重传出现误码的数据分组。因此，接收窗口的尺寸<strong><code>WR</code>应大于1</strong>，以便<strong>接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组</strong>，等到所缺分组收齐后再一并送交上层。这就是<strong>选择重传协议</strong>。</p><p>窗口尺寸要求：</p><ul><li>发送方的发送窗口尺寸<code>WT</code>必须满足 <code>1 &lt; WT &lt; 2^(n-1)</code>，其中<code>n</code>是构成分组序号的比特数量<ul><li>若<code>WT = 1</code> ：与停止-等待协议相同</li><li>若<code>WT &gt; 2^(n-1)</code>：造成接收方无法分辨新、旧数据分组的问题</li></ul></li><li>接收方的接收窗口尺寸<code>WR</code>必须满足<code>1 &lt; WR &lt;= WT</code><ul><li>若<code>WR = 1</code>：与回退<code>N</code>帧协议相同</li><li>若<code>WR &gt; WT</code>：无意义</li></ul></li></ul><p>【小结】</p><p><strong>发送方</strong></p><ul><li>发送窗口尺寸<code>WT = 1</code>时，为停止-等待协议，<code>WT &gt; 2^(n-1)</code>时，接收方会无法分辨新旧数组。</li><li>发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去。</li><li>发送方只有按序收到对已发送数据分组的确认时，发送窗口才能向前相应滑动。</li></ul><p><strong>接收方</strong></p><ul><li>接收方的接收窗口尺寸<code>WR</code>必须满足<code>1 &lt; WR &lt;= WT</code></li><li><strong>选择重传协议</strong>为了使发送方仅重传出现差错的分组，接收方<strong>不能再采用累积确认</strong>，而需要对每个正确接受到的数据分组进行<strong>逐一确认</strong>。</li><li>接收方只有在按序接收数据分组后，接收窗口才能向前相应滑动。</li></ul><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><p>点对点协议<code>PPP（Point-to-Point Protocol）</code>是目前使用最广泛的点对点数据链路层协议。</p><p><img src="/2021/11/13/ComputerNetwork/20211104104920.png" alt="用户接入因特网"></p><p><code>PPP</code>协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分组成：</p><ul><li>对各种协议数据包的封装方法（封装成帧）</li><li>链路控制协议<code>LCP</code>                用于建立、配置以及测试数据链路的连接</li><li>一套网络控制协议<code>NCPs</code>      其中的每一个协议支持不同的网络层协议</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211104105817.png" alt="帧格式"></p><p>实现透明传输：</p><ul><li>面向字节的异步链路：字节填充法，插入“转义字符”</li><li>面向比特的同步链路：比特填充法，插入“比特0”</li></ul><p>实现差错检测：接收方每收到一个<code>PPP</code>帧，就进行<code>CRC</code>检验。若<code>CRC</code>检验正确，就收下这个帧；反之丢弃。使用<code>PPP</code>的数据链路层<strong>向上不提供可靠传输服务</strong>。</p><p><img src="/2021/11/13/ComputerNetwork/20211104110637.png" alt="工作状态"></p><h2 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h2><p>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即<strong>媒体接入控制MAC</strong>（Medium Access Control）。</p><p><img src="/2021/11/13/ComputerNetwork/20211104111034.png" alt="分类"></p><p>随机接入</p><ul><li>总线局域网使用的协议：<code>CSMA/CD</code></li><li>无线局域网使用的协议：<code>CSMA/CA</code></li></ul><h2 id="MAC地址、IP地址以及ARP协议"><a href="#MAC地址、IP地址以及ARP协议" class="headerlink" title="MAC地址、IP地址以及ARP协议"></a>MAC地址、IP地址以及ARP协议</h2><ul><li><code>MAC</code>地址是以太网的<code>MAC</code>子层所使用的地址；（数据链路层）</li><li><code>IP</code>地址是<code>TCP/IP</code>体系结构网际层所使用的地址； （网际层）</li><li><code>ARP</code>协议属于<code>TCP/IP</code>体系结构的网际层，其作用是，已知设备所分配到的<code>lP</code>地址使用<code>ARP</code>协议可以通过该<code>IP</code>地址获取到设备的<code>MAC</code>地址； （网际层）</li></ul><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><ul><li>多个主机连接在同一广播信道上时，实现通信每个主机必须有一个唯一的标识，即一个数据链路层地址。</li><li>每个主机发送的<strong>帧中必须携带标识发送主机和接收主机的地址</strong>。由于这类地址是用于媒体接入控制<code>MAC(Media Access Control)</code>，因此被称为<code>MAC</code>地址。<ul><li><code>MAC</code>地址一般被固化在网卡（网络适配器）的电可擦可编程只读存储器<code>EEPROM</code>中，因此<code>MAC</code>地址也被称为<strong>硬件地址</strong></li><li><code>MAC</code>地址也被称为<strong>物理地址</strong>。但是不表示<code>MAC</code>地址属于物理层！</li></ul></li><li>一般主机会有两个网络适配器：有线局域网适配器（有线网卡）和无限局域网适配器（无线网卡）。每个网络适配器有一个全球唯一的<code>MAC</code>地址。而交换机和路由器有更多的网络接口，所以会有更多的<code>MAC</code>地址。所以严格来说，<strong><code>MAC</code>地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识</strong>。</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211104114750.png" alt="IEEE 802局域网的MAC地址格式"></p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p><code>IP</code>地址是因特网上的主机和路由器使用的地址，用于标识两部分信息：</p><ul><li>网络编号：标识因特网上数以百万计的网络</li><li>主机编号：标识同一网络上不同主机（或路由器各接口）</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211104115843.png" alt="IP地址示意图"></p><p>显然<code>MAC</code>地址是没有区分不同网络的功能的</p><ul><li>如果只是一个单独的网络，不接入因特网，可以只使用<code>MAC</code>地址</li><li>如果主机要接入因特网，则<code>IP</code>地址和<code>MAC</code>地址都需要使用</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211104120553.png" alt="数据包转发过程中IP地址与MAC地址的变化情况"></p><p>由上图可得数据包转发过程中源<code>IP</code>地址和目的<code>IP</code>地址保持<strong>不变</strong>，源<code>MAC</code>地址和目的<code>MAC</code>地址逐个链路（或逐个网络）<strong>改变</strong>。</p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><ul><li>源主机在自己的<strong><code>ARP</code>高速缓存表</strong>中查找目的主机的<code>IP</code>地址所对应的<code>MAC</code>地址，若找到了，则可以封装<code>MAC</code>帧进行发送；若找不到，则<strong>发送<code>ARP</code>请求</strong>（封装在广播<code>MAC</code>帧中）；</li><li>目的主机收到<code>ARP</code>请求后，将源主机的<code>IP</code>地址与<code>MAC</code>地址记录到自己的<code>ARP</code>高速缓存表中，然后给源主机发送<strong><code>ARP</code>响应（封装在单播<code>MAC</code>帧中）</strong>，<code>ARP</code>响应中包含有目的主机的<code>IP</code>地址和<code>MAC</code>地址；</li><li><code>ARP</code>的作用范围：<strong>逐段链路</strong>或<strong>逐个网络</strong>使用；</li><li>除<code>ARP</code>请求和响应外，<code>ARP</code>还有其他类型的报文（例如用于检查<code>IP</code>地址冲突的“无故<code>ARP</code>、免费<code>ARP(Gratuitous ARP)</code>”）;</li><li><code>ARP</code>没有安全验证机制，<strong>存在<code>ARP</code>欺骗（攻击）问题</strong>。</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211104145654.png" alt="ARP请求报文传递过程"></p><p><img src="/2021/11/13/ComputerNetwork/20211104145829.png" alt="ARP响应报文传递过程"></p><p><code>ARP</code>高速缓存表中的地址有两种类型：</p><ul><li>动态：自动获取，生命周期默认为2分钟</li><li>静态：手工设置，不同操作系统下的生命周期不同，例如系统重启后不存在或者系统重启后依然有效</li></ul><h2 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h2><div class="table-container"><table><thead><tr><th style="text-align:left">集线器HUB（淘汰）</th><th style="text-align:left">交换机SWITCH</th></tr></thead><tbody><tr><td style="text-align:left">1. 早期以太网的互连设备<br>2. 工作在<code>OSI</code>体系结构的物理层<br>3. 对接收到的信号进行放大、转发<br>4. 使用集线器作为互连设备的以太网仍然术语共享总线式以太网。集线器互连起来的所有主机共享总线带宽，属于同一个碰撞域和广播域</td><td style="text-align:left">1. 目前以太网中使用最广泛的互连设备<br>2. 工作在<code>OSI</code>体系结构的数据链路层（也包括物理层）<br>3. 根据<code>MAC</code>地址对帧进行转发<br>4. 使用交换机作为互连设备的以太网，称为交换式以太网。交换机可以根据<code>MAC</code>地址过滤帧，即隔离碰撞域<br>5. 交换机的每个接口是一个独立的碰撞域<br>6. 交换机隔离碰撞域但不隔离广播域（<code>VLAN</code>除外）</td></tr></tbody></table></div><h2 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h2><ol><li>收到帧后进行<strong>登记</strong>。登记的内容为<strong>帧的源<code>MAC</code>地址</strong>及进入交换机的<strong>接口号</strong></li><li>根据<strong>帧的目的<code>MAC</code>地址</strong>和交换机的<strong>帧交换表</strong>对帧进行<strong>转发</strong>，有以下三种情况：<ol><li><strong>明确转发</strong>：交换机知道应该从哪个（或哪些）接口转发该帧（单播，多播，广播）</li><li><strong>盲目转发</strong>：交换机不知道应该从哪个端口转发帧，只能将其通过除进入交换机的接口外的其他所有接口转发（也称为泛洪）</li><li><strong>明确丢弃</strong>：交换机知道不应该转发该帧，将其丢弃</li></ol></li></ol><p><img src="/2021/11/13/ComputerNetwork/20211104153532.png" alt="A-&gt;B"></p><p><img src="/2021/11/13/ComputerNetwork/20211104153630.png" alt="B-&gt;A"></p><p><img src="/2021/11/13/ComputerNetwork/20211104153742.png" alt="E-&gt;A"></p><p><img src="/2021/11/13/ComputerNetwork/20211104153920.png" alt="G-&gt;A"></p><p>【注意】</p><p>帧交换表中的每一条记录都有自己的<strong>有效时间</strong>，到期自动删除！这是因为<strong><code>MAC</code>地址与交换机接口的关系并不是永久性的</strong>！</p><p>原因如下：</p><ul><li>交换机的接口改接了另一台主机</li><li>主机更换了网卡</li></ul><h2 id="以太网交换机的生成树协议STP"><a href="#以太网交换机的生成树协议STP" class="headerlink" title="以太网交换机的生成树协议STP"></a>以太网交换机的生成树协议STP</h2><p>如何提高以太网的可靠性？</p><p>添加<strong>冗余链路</strong>可以，但会带来负面效应——形成<strong>网络环路</strong>，网络环路会带来以下问题：</p><ul><li><p>广播风暴（重复转发套娃）</p><p>大量消耗网络资源，使得网络无法正常转发其他数据帧</p></li><li><p>主机收到重复的广播帧</p><p>大量消耗主机资源</p></li><li><p>交换机的帧交换表震荡（漂移）</p></li></ul><p>以太网交换机使用<strong>生成树协议</strong><code>STP(Spanning Tree Protocol)</code>，可以在增加冗余链路来提高网络可靠性的同时又<strong>避免网络环路带来的各种问题</strong>。</p><ul><li>不论交换机之间采用怎样的物理连接，交换机都能<strong>自动计算并构建一个逻辑上没有环路的网络</strong>，其逻辑拓扑结构必须是树型的（无逻辑环路）</li><li>最终生成的树型逻辑拓扑要<strong>确保连通整个网络</strong></li><li>当首次连接交换机或网络<strong>物理拓扑发生变化</strong>时（有可能是人为改变或故障），交换机都将进行<strong>生成树的重新计算</strong></li></ul><h2 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>网络中会频繁出现广播信息</p><ul><li><code>TCP/IP</code>协议栈中的很多协议都会使用广播：<ul><li>地址解析协议<code>ARP</code>（已知<code>IP</code>地址，找出其相应的<code>MAC</code>地址）</li><li>路由信息协议<code>RIP</code>（一种小型的内部路由协议）</li><li>动态主机配置协议<code>DHCP</code>（用于自动配置<code>IP</code>地址）</li></ul></li><li><code>NetBEUI</code>：<code>Windows</code>下使用的广播型协议</li><li><code>IPX/SPX</code>：<code>Novell</code>网络的协议栈</li><li><code>Apple Talk</code>：<code>Apple</code>公司的网络协议栈</li></ul><p>分割广播域的方法</p><ul><li>使用路由器，但成本较高</li><li>虚拟局域网<code>VLAN</code>技术</li></ul><p>虚拟局域网<code>VLAN(Virtual Local Area Network)</code>是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。</p><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><ol><li><strong><code>IEEE 802.1Q</code>帧</strong></li></ol><p><code>IEEE 802.1Q</code>帧（也称<code>Dot One Q</code>帧）对以太网的<code>MAC</code>帧格式进行了扩展，插入了<strong>4字节的<code>VLAN</code>标记</strong>。</p><p><img src="/2021/11/13/ComputerNetwork/20211104162859.png" alt="普通MAC帧与插入标记后的MAC帧"></p><p><code>VLAN</code>标记的<strong>最后 12 比特</strong>称为<strong><code>VLAN</code>标识符<code>VID</code></strong>，它唯一地标志了以太网帧术语哪一个<code>VLAN</code>。</p><ul><li><code>VID</code>的取值范围是 0 ~ 4095（0 ~ 2^12 - 1）</li><li>0 和 4095 都不用来表示<code>VLAN</code>，因此用于表示<code>VLAN</code>的<strong><code>VID</code>的有效取值范围是 1 ~ 4094</strong></li></ul><p><strong><code>802.1Q</code>帧是由交换机来处理的，而不是用户主机来处理的</strong>。</p><ul><li>当交换机<strong>收到普通的以太网帧</strong>时，会将其插入 4 字节的<code>VLAN</code>标记转变为<code>802.1Q</code>帧，简称“<strong>打标签</strong>”</li><li>当交换机<strong>转发<code>802.1Q</code>帧</strong>时，<strong>可能</strong>会删除其 4 字节<code>VLAN</code>标记转变为普通以太网帧，简称“<strong>去标签</strong>”</li></ul><ol><li>交换机的端口类型</li></ol><p>交换机的端口类型有以下三种：</p><ul><li><p><code>Access</code></p><p>一般用于<strong>连接用户计算机</strong>，只能属于一个<code>VLAN</code>，端口的<code>PVID</code>值与端口所属<code>VLAN</code>的<code>ID</code>值相同（默认为1）。</p><p><img src="/2021/11/13/ComputerNetwork/20211104165120.png" alt="Access端口发送与接收处理方法"></p></li><li><p><code>Trunk</code></p><p>一般用于<strong>交换机之间或交换机与路由器之间的互连</strong>，可以属于多个<code>VLAN</code>，用户可以设置端口的<code>PVID</code>值（默认为1）。</p><p><img src="/2021/11/13/ComputerNetwork/20211104165037.png" alt="Trunk端口发送与接收处理方法"></p></li><li><p><code>Hybrid</code></p><p>华为交换机私有，既可用于连接用户计算机也能连接交换机和路由器，可以属于多个<code>VLAN</code>，<code>PVID</code>可设置（默认为1）。</p><p><img src="/2021/11/13/ComputerNetwork/20211104165508.png" alt="Hybrid端口发送与接收处理方法"></p></li></ul><p>交换机个端口的缺省<code>VLAN ID</code></p><ul><li>在思科交换机上称为<code>Native VLAN</code>，即本征<code>VLAN</code></li><li>在华为交换机上称为<code>Port VLAN ID</code>，即端口<code>VLAN ID</code>，简记为<code>PVID</code></li></ul><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong>。</p><p>要实现网络层任务，需要解决以下主要问题：</p><ul><li>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</li><li>网络层寻址问题</li><li>路由选择问题</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211105162949.png" alt="示意图"></p><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><h3 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h3><ul><li><strong>可靠通信由网络来保证</strong></li><li>必须建立<strong>网络层的连接——虚电路<code>VC(Virtual Circuit)</code></strong></li><li>通信双方<strong>沿着已建立的虚电路发送数组</strong></li><li>目的主机的地址仅在连接建立阶段使用，之后每个<strong>分组的首部只需携带一条虚电路的编号</strong>（构成虚电路的每一段链路都有一个虚电路编号）</li><li>这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方（无差错按序到达、不丢失、不重复)。</li><li><strong>通信结束后，需要释放之前所建立的虚电路</strong></li></ul><p><img src="/2021/11/13/ComputerNetwork/20211105165251.png" alt="面向连接的虚电路服务"></p><h3 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h3><ul><li><strong>可靠通信由用户主机来保证</strong></li><li><strong>不需要建立网络层连接</strong></li><li><strong>每个分组可走不同的路径</strong></li><li>每个分组的<strong>首部必须携带目的主机的完整地址</strong></li><li>这种通信方式所传送的分组可能误码、丢失、重复和失序</li><li>由于<strong>网络本身不提供端到端的可靠传输服务</strong>，所以网络中路由器可以做的比较简单</li><li>因特网采用了这种设计思想，<strong>将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层）</strong>，而将相对简单的尽最大努力的分组交付功能置于因特网核心</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211105165419.png" alt="无连接的数据报服务"></p><h2 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><code>IPv4</code>地址就是给因特网上的<strong>每一台主机（或路由器）的每一个接口</strong>分配一个在全世界范围内是<strong>唯一的32比特的标识符</strong>。</p><p><code>IPv4</code>地址的编址方法经理了下面3个历史阶段</p><ul><li>分类编址</li><li>划分子网</li><li>无分类编址</li></ul><p>32比特的<code>IPv4</code>地址不方便阅读、记录以及输入等，因此采用<strong>点分十进制表示方法</strong>以便用户使用。</p><p><img src="/2021/11/13/ComputerNetwork/20211105170641.png" alt="举例"></p><h3 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h3><p><img src="/2021/11/13/ComputerNetwork/20211105170848.png" alt="分类编址的IPv4地址"></p><p>【注意事项】</p><ul><li>只有 A 类、B 类和 C 类地址可分配给网络中的主机或路由器的各接口</li><li>主机号为“全0”的地址是网络地址，不能分配给主机或路由器的各接口</li><li>主机号为“全1”的地址是广播地址，不能分配给主机或路由器的各接口</li></ul><p>判断网络地址类型：</p><ul><li>根据地址左起第一个十进制数的值，可以判断出网络类别（小于127的为A类，128~191的为B类，192~223的为C类）</li><li>根据网络类别，就可找出地址中的网络号部分和主机号部分（A类地址网络号为左起第一个字节，B类地址网络号为左起前两个字节，C类地址网络号为左起前三个字节）</li><li>以下三种情况的地址不能指派给主机或路由器接口<ul><li>A 类网络号 0 和 127</li><li>主机号为“全 0”，这是网络地址</li><li>主机号为“全 1”，这是广播地址</li></ul></li></ul><p>特殊的<code>IP</code>地址</p><ul><li><code>0.0.0.0</code>：本网络上的本主机，只能作为源<code>IP</code>地址，不能作为目的<code>IP</code>地址</li><li><code>127.0.0.1</code>：常用的环回测试地址</li><li><code>255.255.255.255</code>：只能作为目的地址使用，表示“只在本网络上进行广播（各路由器均不转发）”</li></ul><h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><p><strong>32比特的子网掩码可以表明分类<code>IP</code>地址的主机号部分被借用了几个比特作为子网号</strong></p><ul><li>子网掩码使用<strong>连续的比特1来对应网络号和子网号</strong></li><li>子网掩码使用<strong>连续的比特0来对应主机号</strong></li><li>将划分子网的<strong><code>IPv4</code>地址</strong>与其对应的<strong>子网掩码</strong>进行<strong>逻辑与运算</strong>就可得到<code>IPv4</code>地址<strong>所在子网的网络地址</strong></li></ul><p>给定一个分类的<code>IP</code>地址和其相应的子网掩码，就可以得到子网划分的细节：</p><ul><li>划分出的子网数量</li><li>每个子网可分配的<code>IP</code>地址数量</li><li>每个子网的网络地址（起始）和广播地址（结尾）</li><li>每个子网可分配的最小和最大地址</li></ul><p>默认的子网掩码是指在未划分子网的情况下使用的子网掩码</p><p><img src="/2021/11/13/ComputerNetwork/20211105174723.png" alt="默认子网掩码"></p><h3 id="无分类编址"><a href="#无分类编址" class="headerlink" title="无分类编址"></a>无分类编址</h3><p>划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是<strong>数量巨大的 C 类网</strong>因为其<strong>地址空间太小</strong>并<strong>没有得到充分利用</strong>。为此，提出了采用<strong>无分类编址</strong>的方法来解决<code>IP</code>地址紧张的问题。</p><p>1993 年发布了无分类域间路由选择<code>CIDR(Classles Inter-Domain Routing)</code>：</p><ul><li><code>CIDR</code>消除了传统的 A 类、B 类和 C 类地址，以及划分子网的概念</li><li><code>CIDR</code>可以更加有效地分配<code>IPv4</code>的地址空间，并且可以在新的<code>IPv6</code>使用之前允许因特网的规模继续增长</li></ul><p><code>CIDR</code>使用“<strong>斜线记法</strong>”，或称<code>CIDR</code>记法。即在<code>IPv4</code>地址后面加上斜线“/”，在<strong>斜线后面写上网络前缀所占的比特数量</strong></p><p><img src="/2021/11/13/ComputerNetwork/20211105180252.png" alt="举例"></p><p><code>CIDR</code>实际上是将网络前缀都相同的连续的IP地址组成一个“CIDR地址块”，我们只要知道<code>CIDR</code>地址块中的任何一个地址，就可以知道该地址块的全部细节。</p><p><strong>路由聚合</strong>（构造超网）</p><p><img src="/2021/11/13/ComputerNetwork/20211105195535.png" alt="举例"></p><ul><li><strong>网络前缀越长，地址块越小，路由越具体</strong></li><li>若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为<strong>最长前缀匹配</strong>，因为这样的路由更具体</li></ul><h3 id="应用规划"><a href="#应用规划" class="headerlink" title="应用规划"></a>应用规划</h3><p>有两种方法，分别是<strong>定长的子网掩码</strong><code>FLSM(Fixed Length Subnet Mask)</code>和<strong>变长的子网掩码</strong><code>VLSM(Variable Length Subnet Mask)</code>。</p><p>定长的子网掩码<code>FLSM</code></p><ul><li>使用同一个子网掩码来划分子网</li><li>每个子网多分配的<code>IP</code>地址数量相同，造成<code>IP</code>地址的浪费</li></ul><p>变长的子网掩码<code>VLSM</code></p><ul><li>使用不同的子网掩码来划分子网</li><li>每个子网所分配的<code>IP</code>地址数量可以不同，尽可能减少对<code>IP</code>地址的浪费</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211105201305.png" alt="FLSM举例"></p><p><img src="/2021/11/13/ComputerNetwork/20211105201759.png" alt="VLSM举例"></p><h2 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h2><p>包含以下两部分：</p><ul><li>主机发送<code>IP</code>数据报</li><li>路由器转发<code>IP</code>数据报</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211108093525.png" alt="间接交付--C向F发送数据报"></p><p>当本网络中的主机要和其他网络中的主机进行通信时，会将<code>IP</code>数据报传输给默认网关，由默认网关即路由器帮主机将<code>IP</code>数据报转发出去。</p><p><img src="/2021/11/13/ComputerNetwork/20211108093941.png" alt="默认网关"></p><p>路由器收到<code>IP</code>数据报后的转发过程：</p><ul><li>检查<code>IP</code>数据报首部是否出错，若出错，则直接丢弃该<code>IP</code>数据报并通告源主机；若没有出错，则进行转发</li><li>根据<code>IP</code>数据报的目的地址在路由表中查找匹配的条目，若找到，则按条目转发；若找不到，则丢弃该<code>IP</code>数据报并通告源主机</li></ul><h2 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h2><p>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器<strong>人工配置路由表</strong>。</p><ul><li>这种人工配置方式简单、开销小。但不能及时适应网络状态（流量、拓扑等）的变化</li><li>一般只在小规模网络中采用</li></ul><p>路由条目的类型</p><ul><li>直连网络</li><li>静态路由（人工配置）</li><li>动态路由（路由选择协议）</li></ul><p>特殊的静态路由条目</p><ul><li>默认路由（目的网络为<code>0.0.0.0</code>，地址掩码为<code>0.0.0.0</code>）</li><li>特定主机路由（目的网络为特定主机的<code>IP</code>地址，地址掩码为<code>255.255.255.255</code>）</li><li>黑洞路由（下一跳为<code>null0</code>）</li></ul><p>使用静态路由配置可能出现以下<strong>导致</strong>产生<strong>路由环路</strong>的错误</p><ul><li>配置错误</li><li>聚合了不存在的网络</li><li>网络故障</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211108111831.png" alt="特定主机路由与默认路由"></p><p><img src="/2021/11/13/ComputerNetwork/20211108112019.png" alt="路由环路举例1"></p><p>为了防止<code>IP</code>数据报在路由环路中永久兜圈，在<code>IP</code>数据报首部设有生存时间<code>TTL</code>字段。<code>IP</code>数据报进入路由器后，<code>TTL</code>字段的值减1。若<code>TTL</code>的值不等于0，则被路由器转发，否则被丢弃。</p><p><img src="/2021/11/13/ComputerNetwork/20211108112857.png" alt="路由环路举例2"></p><p>解决办法是在路由表中添加黑洞路由：</p><p><img src="/2021/11/13/ComputerNetwork/20211108112953.png" alt="添加黑洞路由"></p><p><img src="/2021/11/13/ComputerNetwork/20211108113246.png" alt="路由环路举例3"></p><p>解决办法也是在路由表中添加黑洞路由：</p><p><img src="/2021/11/13/ComputerNetwork/20211108113337.png" alt="添加黑洞路由"></p><h2 id="路由选择协议概述"><a href="#路由选择协议概述" class="headerlink" title="路由选择协议概述"></a>路由选择协议概述</h2><div class="table-container"><table><thead><tr><th style="text-align:left">静态路由选择</th><th style="text-align:left">动态路由选择</th></tr></thead><tbody><tr><td style="text-align:left">1. 由<strong>人工配置</strong>的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由<br>2. 人工配置方式简单、开销小。但不<strong>能及时适应网络状态（流量、拓扑等）的变化</strong><br>3. 一般只在<strong>小规模网络</strong>中采用</td><td style="text-align:left">1. 路由器通过路由选择协议<strong>自动获取路由信息</strong><br>2. 比较复杂、开销比较大。<strong>能较好地适应网络状态的变化</strong><br>3. 适用于<strong>大规模网络</strong></td></tr></tbody></table></div><p>路由选择协议的主要特点：</p><ul><li>自适应：动态路由选择，能较好地适应网络状态的变化</li><li>分布式：路由器之间交换路由信息</li><li>分层次：将整个因特网划分为许多较小的自治系统<code>AS(Atonomous System)</code></li></ul><p><img src="/2021/11/13/ComputerNetwork/20211108114958.png" alt="常见的路由选择协议"></p><p><img src="/2021/11/13/ComputerNetwork/20211108115519.png" alt="路由器的基本结构"></p><h2 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h2><p><img src="/2021/11/13/ComputerNetwork/20211108150845.png" alt="IPv4数据报的首部格式"></p><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><p>为了更有效地转发<code>IP</code>数据报和提高交付成功的机会，在网际层使用了网际控制报文协议<code>ICMP(Internet Control Message Protocol)</code>。</p><p>主机或路由i去使用<code>ICMP</code>来发送<strong>差错报告报文</strong>和<strong>询问报文</strong>。 </p><p><strong><code>ICMP</code>报文被封装在<code>IP</code>数据报</strong>中发送。</p><p><code>ICMP</code>差错报文共有五种： </p><ul><li><p>终点不可达</p><p>路由器或主机不能交付数据报时，就向源点发送终点不可达报文。</p></li><li><p>源点抑制</p><p>路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文。</p></li><li><p>时间超过</p><p>路由器收到一个目的<code>IP</code>地址不是自己的<code>IP</code>数据报，会将其生存时间<code>TTL</code>字段的值减1。若结果不为0，则将该<code>IP</code>数据报转发出去；若结果为0，除丢弃该<code>IP</code>数据报后，还要向源点发送时间超过报文。</p><p>另外，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点发送时间超过报文。</p></li><li><p>参数问题</p><p>路由器或目的主机收到<code>IP</code>数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文。</p></li><li><p>改变路由（重定向）</p><p>路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</p></li></ul><p>不应发送<code>ICMP</code>差错报告报文的情况：</p><ul><li>对<code>ICMP</code>差错报告报文不再发送<code>ICMP</code>差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送<code>ICMP</code>差错报告报文</li><li>对具有多播地址的数据报都不发送<code>ICMP</code>差错报告报文</li><li>对具有特殊地址（如<code>127.0.0.1</code>或<code>0.0.0.0</code>）的数据报不发送<code>ICMP</code>差错报告报文</li></ul><p>常用的<code>ICMP</code>询问报文：</p><ul><li><p>回送请求报文</p><p><code>ICMP</code>回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或者路由器发送<code>ICMP</code>回送回答报文。<strong>用来测试目的站是否可达</strong>。</p></li><li><p>时间戳请求和回答</p><p><code>ICMP</code>时间戳请求报文是请某个主机或路由器回答当前的日期和时间。<strong>用来进行时钟同步和测量时间</strong>。</p></li></ul><p><code>ICMP</code>应用举例</p><ul><li><p>分组网间探测<code>PING(Packet InterNet Groper)</code></p><ul><li>用来测试主机或路由器间的连通性</li><li>应用层直接使用网际层的<code>ICMP</code>（没有通过运输层的<code>TCP</code>或<code>UDP</code>）</li><li>使用<code>ICMP</code>回送请求和回答报文</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211108161305.png" alt="ping示例"></p></li><li><p>跟踪路由<code>traceroute</code></p><ul><li>用来测试<code>IP</code>数据报从源主机到达目的主机要经过哪些路由器</li><li>Windows<ul><li>tracert命令</li><li>应用层直接使用网际层<code>ICMP</code></li><li>使用了<code>ICMP</code>回送请求报文和回答报文以及差错报告报文</li></ul></li><li>Unix<ul><li>traceroute命令</li><li>在运输层使用<code>UDP</code>协议</li><li>仅使用<code>ICMP</code>差错报告报文</li></ul></li></ul><p><img src="/2021/11/13/ComputerNetwork/20211108161204.png" alt="跟踪示例"></p></li></ul><h2 id="虚拟专用网-VPN-与网络地址转换-NAT"><a href="#虚拟专用网-VPN-与网络地址转换-NAT" class="headerlink" title="虚拟专用网 VPN 与网络地址转换 NAT"></a>虚拟专用网 VPN 与网络地址转换 NAT</h2><p>虚拟专用网<code>VPN(Virtual Private Network)</code></p><ul><li><p>内联网<code>VPN</code></p><p>同一机构内不同部门的内部网络所构成的虚拟专用网<code>VPN</code>。 </p></li><li><p>外联网<code>VPN</code></p><p>一个机构的<code>VPN</code>需要有某些外部机构参加进来。</p></li><li><p>远程接入<code>VPN</code></p><p>在外网环境下运行<code>VPN</code>软件来与公司的主机建立<code>VPN</code>隧道，即可访问专用网络即内网中的资源。</p></li></ul><p><img src="/2021/11/13/ComputerNetwork/20211108162215.png" alt="内联网VPN"></p><p><img src="/2021/11/13/ComputerNetwork/20211108163115.png" alt="专用网络地址即本地地址"></p><p>网络地址转换<code>NAT(Network Address Translation)</code></p><p><code>NAT</code>能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源。</p><p><img src="/2021/11/13/ComputerNetwork/20211108163741.png" alt="网络地址转换NAT"></p><p>这种转换方法会由于NAT路由器中的全球<code>IP</code>地址有限而受限，至多只能有对应数量的内网主机能够和因特网上的主机通信。</p><p>由于绝大多数的网络应用都是使用运输层协议<code>TCP</code>或<code>UDP</code>来传送数据，因此可以利用运输层的端口号和<code>IP</code>地址一起进行转换。这样用<strong>一个全球<code>IP</code>地址</strong>就可以使<strong>多个本地主机</strong>同时和因特网上的主机痛惜。这种将端口号和<code>IP</code>地址一起进行转换的技术叫做<strong>网络地址与端口号转换<code>NAPT(Network Address and Port Translation)</code></strong>。</p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><ul><li>物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，<strong>实现了主机到主机的通信</strong>。</li><li>实际上在计算机网络中进行<strong>通信的真正实体是位于通信两端主机中的进程</strong>。</li><li><strong>如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务</strong>，运输层协议又称为端到端协议。</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211110103624.png" alt="示意图"></p><p><img src="/2021/11/13/ComputerNetwork/20211110103941.png" alt="不同主机上的应用进程通信"></p><p>运输层直接为应用进程间的逻辑通信提供服务。</p><p>根据应用需求的不同，<strong>因特网的运输层</strong>为应用层提供了两种不同的运输协议，即面向连接的<code>TCP</code>和无连接的<code>UDP</code>。</p><h2 id="运输层端口号、复用与分用"><a href="#运输层端口号、复用与分用" class="headerlink" title="运输层端口号、复用与分用"></a>运输层端口号、复用与分用</h2><ul><li>运行在计算机上的进程使用<strong>进程标识符</strong><code>PID</code>来标志。</li><li>不同的操作系统使用<strong>不同格式的进程标识符</strong>。</li><li>为了使不同操作系统的计算机的应用进程之间能够通信，就必须<strong>使用统一的方法对<code>TCP\IP</code>体系的应用进程进行标识</strong>。</li><li><code>TCP\IP</code>体系的运输层使用<strong>端口号</strong>来区分应用层的不同应用进程。<ul><li>端口号使用<strong>16比特表示</strong>，取值范围 <strong>0~65535</strong>；<ul><li>熟知端口号：0~1023，<code>TCP\IP</code>中最重要的一些应用协议，如：<code>FTP</code>使用 21/20，<code>HTTP</code>使用 80，<code>DNS</code>使用 53。</li><li>登记端口号：1024~49151，为没有熟知端口号的应用程序使用。按规定手续登记，防止重复。如：<code>Microsoft RDP</code>微软远程桌面使用的端口是3389。</li><li>短暂端口号：49252~65535，苦于给客户进程选择暂时使用。通信结束后可供其他客户进程使用。</li></ul></li><li><strong>端口号只具有本地意义</strong>，即端口号只是为了<strong>标识本计算机应用层中的各进程</strong>，在因特网中，<strong>不同计算机中的相同端口号是没有联系的</strong>。</li></ul></li></ul><p>发送方的复用和接收方的分用</p><p><img src="/2021/11/13/ComputerNetwork/20211110110441.png" alt="发送方的复用和接收方的分用"></p><p><img src="/2021/11/13/ComputerNetwork/20211110110533.png" alt="TCP/IP体系的应用层常用协议所使用的运输层熟知端口号"></p><h2 id="UDP-与-TCP-的对比"><a href="#UDP-与-TCP-的对比" class="headerlink" title="UDP 与 TCP 的对比"></a>UDP 与 TCP 的对比</h2><div class="table-container"><table><thead><tr><th style="text-align:left">用户数据报协议UDP(User Datagram Protocol)</th><th style="text-align:left">传输控制协议TCP(Transmission Control Protocol)</th></tr></thead><tbody><tr><td style="text-align:left">1. 可随时发送数据，无连接的<code>UDP</code><br>2. 支持单播、多播以及广播，即支持一对一，一对多，一对全的通信<br>3. <code>UDP</code>是面向应用报文的<br>4. <code>UDP</code>向上层提供无连接<strong>不可靠的传输</strong>服务（适用于<code>IP</code>电话、视频会议等实时应用）<br>5. <code>UDP</code>用户数据报首部仅8字节</td><td style="text-align:left">1. 数据传输之前必须通过“三报文握手”建立连接，数据传输完成后必须通过“四报文挥手”释放连接，<strong>面向连接的<code>TCP</code></strong><br>2. 仅支持单播，即一对一通信，因为数据传输前需要建立连接<br>3. <code>TCP</code>是面向字节流的<br>4. <code>TCP</code>向上层提供面向连接的<strong>可靠传输</strong>服务（适用于要求可靠传输的应用，例如文件传输）<br>5. <code>TCP</code>报文段首部最小20字节，最大60字节</td></tr></tbody></table></div><p><img src="/2021/11/13/ComputerNetwork/20211110112746.png" alt="UDP用户数据报与TCP报文段的首部对比"></p><h2 id="TCP-的流量控制"><a href="#TCP-的流量控制" class="headerlink" title="TCP 的流量控制"></a>TCP 的流量控制</h2><p>所谓流量控制<code>(flow control)</code>就是<strong>让发送方的发送速率不要太快，要让接收方来得及接收</strong>。</p><p>利用<strong>滑动窗口</strong>机制可以很方便地在<code>TCP</code>连接上实现对发送方的流量控制。</p><p><img src="/2021/11/13/ComputerNetwork/20211110114215.png" alt="举例"></p><p><img src="/2021/11/13/ComputerNetwork/20211110114340.png" alt="TCP死锁"></p><p><strong>解决<code>TCP</code>死锁问题：</strong></p><p><code>TCP</code>为每一个连接设有一个持续计时器。只要<code>TCP</code>连接的一方收到对方的零窗口通知，就启动持续计时器。若计时器超时，就发送一个零窗口探测报文，仅携带 1 字节的数据，对方在确认这个探测报文段时，给出自己现在的接收窗口值。如果仍然是0，那么收到这个报文段的一方就重新启动持续计时器，若不为0，死锁的局面就可以打破了。</p><p>若零窗口探测报文段丢失，也能打破死锁的局面，因为零窗口探测报文段也有重传计时器。当超时后，零窗口探测报文段会被重传。</p><h2 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h2><p>对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做<strong>拥塞</strong><code>(congestion)</code>。</p><p>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。</p><p><img src="/2021/11/13/ComputerNetwork/20211110115714.png" alt="输入负载与吞吐量的关系"></p><p><code>TCP</code>的拥塞控制算法</p><ul><li>慢开始<code>(slow-start)</code></li><li>拥塞避免<code>(congestion avoidance)</code></li><li>快重传<code>(fast retransmit)</code></li><li>快恢复<code>(fast recovery)</code></li></ul><p><img src="/2021/11/13/ComputerNetwork/20211110120517.png" alt="慢开始和拥塞避免"></p><ul><li><p>“慢开始”是指一开始向网络注入的报文段少，并不是指拥塞窗口<code>cwnd</code>增长速度慢</p></li><li><p>“拥塞避免”并非是指完全能够避免拥塞， 而是指拥塞避免阶段将拥塞窗口控制为按线性规律增长，比较不容易出现拥塞</p></li><li><p>所谓快重传就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。</p><ul><li>接收方<strong>立即发送确认</strong></li><li>即使收到失序的报文段也要立即发出对已收到报文段的<strong>重复确认</strong></li><li>发送方一旦收到 3 个连续的重复确认，就将相应报文段<strong>立即重传</strong>，而不是等到超时重传</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211110121356.png" alt="示意图"></p></li><li><p>发送方一旦收到 3 个重复确认，就可以知道只是丢失了个别报文段。故不启动慢开始算法，而<strong>执行快恢复算法</strong></p><ul><li>发送方将慢开始门限<code>ssthresh</code>值和拥塞窗口<code>cwnd</code>值调整为当前窗口的一半；开始执行拥塞避免算法。</li><li>也有的快恢复实现是把快恢复开始时的拥塞窗口<code>cwnd</code>值再增大一些，即等于新的<code>ssthresh + 3</code><ul><li>接收到 3 个重复的确认表明有 3 个数据报文段已经离开了网络，因此可以适当扩大拥塞窗口</li></ul></li></ul></li></ul><p><img src="/2021/11/13/ComputerNetwork/20211110122059.png" alt="4种算法"></p><h2 id="TCP-超时重传时间的选择"><a href="#TCP-超时重传时间的选择" class="headerlink" title="TCP 超时重传时间的选择"></a>TCP 超时重传时间的选择</h2><p><img src="/2021/11/13/ComputerNetwork/20211110151246.png" alt="示意图"></p><ul><li><p>不能直接使用某次测量得到的<code>RTT</code>样本来计算超时重传时间<code>RTO</code></p></li><li><p>利用每次测量得到的<code>RTT</code>样本，计算加权平均往返时间<code>RTTs</code>（又称为平滑的往返时间）</p></li><li><p>超时重传时间<code>RTO</code>应略大于加权平均往返时间<code>RTTs</code></p></li></ul><ul><li><p>针对<strong>出现超时重传时无法测准往返时间</strong><code>RTT</code>的问题，<code>Karn</code>提出了一个算法：在计算加权平均往返时间<code>RTTs</code>时，只要报文段重传了，就不采用其往返时间<code>RTT</code>样本。但这样会引起新的问题，如果报文段的时延突然增大了很多并且保持很长一段时间，那么在原有的重传时间内是收不到确认报文的，那么会反复重传报文。</p></li><li><p>因此对<code>Karn</code>算法进行修正：报文段每重传一次，就把超时重传时间<code>RTO</code>增大一些。典型做法是增大到原来的 2 倍。</p></li></ul><h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><p><code>TCP</code>基于<strong>以字节为单位的滑动窗口</strong>来实现可靠传输。</p><p><img src="/2021/11/13/ComputerNetwork/20211112113930.png" alt="示意图"></p><ul><li>虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，<strong>发送方的发送窗口并不总是和接收方的接收窗口</strong>一样大<ul><li>网络传送窗口值需要经历一定时间的滞后</li><li>发生拥塞发送方需减小发送窗口尺寸</li></ul></li><li>对于<strong>不按序到达的数据应如何处理</strong>，<code>TCP</code>无明确规定<ul><li>若一律丢弃，那么接收窗口的管理会比较简单，但这样对网络资源的利用不利，因为发送方会重复传送较多的数据</li><li>通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再<strong>按序交付上层的应用进程</strong></li></ul></li><li><code>TCP</code>要求接收方必须有<strong>累计确认和捎带确认机制</strong>，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。<ul><li><strong>接收方不应过分推迟发送确认</strong>，否则会导致发送方不必要的超时重传，这反而会浪费网络资源。<code>TCP</code>标准规定，确认推迟的时间不应超过 0.5 秒</li><li>捎带确认实际上很少发生，因为大多数应用程序很少同时在两个方向上发送数据</li></ul></li><li><strong><code>TCP</code>的通信是全双工通信</strong>。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口</li></ul><h2 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h2><h3 id="TCP-的连接建立"><a href="#TCP-的连接建立" class="headerlink" title="TCP 的连接建立"></a>TCP 的连接建立</h3><ul><li><p><code>TCP</code>是面向连接的协议，它基于运输连接来传送<code>TCP</code>报文段</p></li><li><p><code>TCP</code>运输连接的建立和释放是每一次面向连接的通信中必不可少的过程</p></li><li><p><code>TCP</code>运输连接有三个阶段，建立<code>TCP</code>连接、数据传送和释放<code>TCP</code>连接</p><p><img src="/2021/11/13/ComputerNetwork/20211112115950.png" alt="TCP连接的三个阶段"></p></li><li><p><code>TCP</code>的运输连接管理就是使运输连接的建立和释放都能正常地进行</p></li></ul><p><img src="/2021/11/13/ComputerNetwork/20211112120425.png" alt="TCP使用“三报文握手”建立连接"></p><p>【注意】</p><ul><li><code>TCP</code>标准规定<code>SYN = 1</code>的报文段不能携带数据，但要消耗掉一个序号</li><li><code>TCP</code>标准规定普通的确认报文段如果不携带数据，则不消耗序号</li></ul><p><code>TCP</code>客户进程最后发送一个普通的<code>TCP</code>确认报文段是否多余即是否可以使用两报文握手？</p><p>不多余，这是为了防止已失效的连接请求报文段突然又传送到了<code>TCP</code>服务器，因而导致错误。</p><p><img src="/2021/11/13/ComputerNetwork/20211112120832.png" alt="原因"></p><h3 id="TCP-的连接释放"><a href="#TCP-的连接释放" class="headerlink" title="TCP 的连接释放"></a>TCP 的连接释放</h3><p><img src="/2021/11/13/ComputerNetwork/20211112121839.png" alt="TCP通过”四报文挥手“来释放连接"></p><p><strong><code>TCP</code>客户进程在发送完最后一个确认报文段后，进入时间等待状态是否有必要？</strong></p><p>有必要，因为发送的最后一个确认报文段可能会丢失，导致<code>TCP</code>服务器没有接收到进行超时重传，而此时若<code>TCP</code>客户端已进入关闭状态，则会收不到导致<code>TCP</code>服务器无法进入关闭状态。另外，<code>TCP</code>客户进程在发送完最后一个确认报文段后，再经过<code>2MSL</code>时长，就可以使本次连接持续时间内多产生的所有报文段都从网络中消失，这样就会使下一个<code>TCP</code>连接中不会出现就链接中的报文段。</p><p><img src="/2021/11/13/ComputerNetwork/20211112122144.png" alt="原因"></p><p><strong>当<code>TCP</code>客户端出现故障时，<code>TCP</code>服务器如何发现？</strong></p><p>TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动<strong>保活计时器</strong>（2小时定时）。</p><p>若保活计时器定时周期内未收到<code>TCP</code>客户进程发来的数据，则<strong>当保活计时器到时后，<code>TCP</code>服务器进程就向<code>TCP</code>客户进程发送一个探测报文段</strong>，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无<code>TCP</code>客户进程的响应，<code>TCP</code>服务器进程就认为<code>TCP</code>客户进程所在主机出了故障，接着就关闭这个连接。</p><h2 id="TCP-报文段的首部格式"><a href="#TCP-报文段的首部格式" class="headerlink" title="TCP 报文段的首部格式"></a>TCP 报文段的首部格式</h2><p><img src="/2021/11/13/ComputerNetwork/20211112200056.png" alt="TCP 报文段的首部格式"></p><ul><li><strong>源端口</strong>：占16比特，写入源端口号，用来<strong>标识发送该<code>TCP</code>报文段的应用进程</strong>。</li><li><strong>目的端口</strong>：占16比特，写入目的端口号，用来<strong>标识接收该<code>TCP</code>报文段的应用进程</strong>。</li><li><strong>序号</strong>：占32比特，取值范围<code>[0, 2^32 - 1]</code>，序号增加到最后一个后，下一个序号就又回到0。<strong>指出本<code>TCP</code>报文段数据载荷的第一个字节的序号</strong>。</li><li><strong>确认号</strong>：占32比特，取值范围<code>[0, 2^32 - 1]</code>，确认号增加到最后一个后，下一个确认号就又回到0。<strong>指出期望收到对方下一个<code>TCP</code>报文段的数据载荷的第一个字节的序号</strong>，同时也是对之前收到的所有数据的确认。若确认号为 n ，则表明到序号<code>n - 1</code>为止的所有数据都已正确接收，期望接收序号为 n 的数据。</li><li><strong>确认标志位<code>ACK</code></strong>：取值为1时确认号字段才有效；取值为0时确认号字段无效。<code>TCP</code>规定，在连接建立后所有传送的<code>TCP</code>报文段都必须把<code>ACK</code>置1。</li><li><img src="/2021/11/13/ComputerNetwork/20211112201509.png" alt="示意图"></li><li><strong>数据偏移</strong>：占4比特，并以4字节为单位。用来<strong>指出<code>TCP</code>报文段的数据载荷部分的起始处距离<code>TCP</code>报文段的起始处有多远</strong>。这个字段实际上是指出了<code>TCP</code>报文段的首部长度。故数据偏移字段的最小值为<code>0101</code>（20 / 4），最大值为<code>1111</code>（60 / 4）。</li><li><strong>保留</strong>：占6比特，保留为今后使用，但目前应置为0。</li><li><strong>窗口</strong>：占16比特，以字节为单位。<strong>指出发送本报文段的一方的接收窗口</strong>。窗口值作为接收方让发送方设置其发送窗口的依据。这是以接收方的接收能力来控制发送方的发送能力，称为流量控制。</li><li><strong>校验和</strong>：占16比特，检查范围包括<code>TCP</code>报文段的首部和数据载荷两部分。在计算校验和时，要在<code>TCP</code>报文段的前面加上12字节的伪首部。</li><li><strong>同步标志位<code>SYN</code></strong>：在<code>TCP</code>连接建立时用来同步序号。</li><li><strong>终止标志位<code>FIN</code></strong>：用来释放<code>TCP</code>连接。</li><li><strong>复位标志位<code>RST</code></strong>：用来复位<code>TCP</code>连接。当<code>RST = 1</code>时，标识<code>TCP</code>连接出现了异常，必须释放连接，然后再重新建立连接。<code>RST</code>置1还用来拒绝一个非法的报文段或拒绝打开一个<code>TCP</code>连接。</li><li><strong>推送标志位<code>PSH</code></strong>：接受方的<code>TCP</code>收到该标志位为1的报文段会<strong>尽快上交应用进程</strong>，而不必等到接收缓存都填满后再向上交付。</li><li><strong>紧急标志位<code>URG</code></strong>：取值为1时紧急指针字段有效；取值为0时紧急指针字段无效。</li><li><strong>紧急指针</strong>：占16比特，以字节为单位，用来指明紧急数据的长度。当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个<code>TCP</code>报文段中进行发送。</li><li><strong>选项</strong>：<ul><li>最大报文段长度<code>MSS</code>选项</li><li>窗口扩大选项</li><li>时间戳选项</li><li>选择确认选项</li></ul></li><li><strong>填充</strong>：由于选项的长度可变，因此使用填充来<strong>确保报文段首部能被4整除</strong>（因为数据偏移字段，也就是首部长度字段，是以4字节为单位的）。</li></ul><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>应用层是计算机网络体系结构的<strong>最顶层</strong>，是<strong>设计和建立计算机网络的最终目的</strong>，也是计算机网络中发展最快的部分。</p><h2 id="客户-服务器方式（C-S）和对等方式（P2P）"><a href="#客户-服务器方式（C-S）和对等方式（P2P）" class="headerlink" title="客户/服务器方式（C / S）和对等方式（P2P）"></a>客户/服务器方式（C / S）和对等方式（P2P）</h2><p><strong>客户/服务器（Client/Server）方式</strong></p><ul><li>客户和服务器是指通信中所设计的两个应用进程。</li><li>客户/服务器方式所描述的是进程之间服务和被服务的关系。</li><li>客户是服务请求方，服务器是服务提供方。</li><li>服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号（例如<code>HTTP</code>服务器的默认端口号为80），而运行服务器的主机也具有固定的<code>IP</code>地址。</li></ul><p><strong>对等（Peer-to-Peer）方式</strong></p><ul><li>再<code>P2P</code>方式中，<strong>没有固定的服务请求者和服务提供者</strong>，分布在网络边缘各端系统中的应用进程是对等的，被称为<strong>对等方</strong>。<strong>对等方相互之间直接通信</strong>，每个对等方既是服务的请求者，又是服务的提供者。</li><li>目前流行的<code>P2P</code>应用主要包括<code>P2P</code>文件共享、即时通信、<code>P2P</code>流媒体、分布式存储等。</li><li>基于<code>P2P</code>的应用是<strong>服务分散型</strong>的。</li><li><code>P2P</code>方式的最突出特性之一就是它的<strong>可扩展性</strong>。因为每增加一个对等方，不仅增加了服务请求者，也增加了提供者，系统性能不会因规模的增大而降低。</li></ul><h2 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h2><ul><li>动态主机配置协议<code>DHCP(Dynamic Host Configuration Protocol)</code>提供了一种机制，称为即插即用连网。这种机制<strong>允许一台计算机加入新网络时可自动获取<code>IP</code>地址等网络配置信息而不用手工参与</strong>。</li><li><code>DHCP</code>报文<strong>在运输层使用<code>UDP</code>协议封装</strong>。</li><li><code>DHCP</code>客户在未获取到<code>IP</code>地址时使用地址<code>0.0.0.0</code>。</li><li>在每一个网络上都设置一个<code>DHCP</code>服务器会使<code>DHCP</code>服务器的数量太多。因此现在是使每一个网络至少有一个<code>DHCP</code>中继代理（通常是一台路由器），它配置了<code>DHCP</code>服务器的<code>IP</code>地址信息，作为各网络中计算机与<code>DHCP</code>服务器的桥梁。</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211112211406.png" alt="DHCP的作用"></p><h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h2><ul><li>因特网采用<strong>层次树状结构的域名结构</strong>。</li><li>域名的结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名。<ul><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母</li><li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边</li><li>完整的域名不超过255个字符</li></ul></li></ul><p>顶级域名<code>TLD(Top Level Domain)</code>分为三类：</p><ul><li><p>国家顶级域名<code>nTLD</code></p><p>如<code>cn</code>、<code>us</code>、<code>uk</code>等。</p></li><li><p>通用顶级域名<code>gTLD</code></p><p>最常见的7个：<code>com</code>、<code>net</code> 、<code>org</code>、<code>int</code>、<code>edu</code>、<code>gov</code>、<code>mil</code>。</p></li><li><p>反向域<code>arpa</code></p><p>用于反向域名解析，即<code>IP</code>地址反向解析为域名。</p></li></ul><p><img src="/2021/11/13/ComputerNetwork/20211112213954.png" alt="域名空间"></p><p>域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用<strong>分布在各地的域名服务器</strong>来实现域名到IP地址的转换。</p><p>域名服务器可以划分为以下四种不同的类型：</p><ul><li><p><strong>根域名服务器</strong></p><p>根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的<code>IP</code>地址。</p></li><li><p><strong>顶级域名服务器</strong></p><p>管理在该顶级域名服务器注册的所有二级域名。</p></li><li><p><strong>权限域名服务器</strong></p><p>管理某个区的域名。</p></li><li><p><strong>本地域名服务器</strong></p><p>本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中。</p></li></ul><p>域名解析过程有<strong>递归查询</strong>和<strong>迭代查询</strong>。</p><p><img src="/2021/11/13/ComputerNetwork/20211112214558.png" alt="递归查询"></p><p><img src="/2021/11/13/ComputerNetwork/20211112214621.png" alt="递归 + 迭代查询（常用）"></p><p>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了<strong>高速缓存</strong>。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p><p>由于域名到IP地址的映射关系并不是永久不变，为保持高速缓存中的内容正确，域名服务器<strong>应为每项内容设置计时器并删除超过合理时间的项</strong>（例如，每个项目只存放两天）。</p><p>不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。</p><p><code>DNS</code>报文使用运输层的<code>UDP</code>协议进行封装，运输层<strong>端口号为53</strong>。</p><h2 id="文件传送协议-FTP"><a href="#文件传送协议-FTP" class="headerlink" title="文件传送协议 FTP"></a>文件传送协议 FTP</h2><p>文件传送协议<code>FTP(File Transfer Protocol)</code>是因特网上使用的最广泛的文件传送协议。</p><ul><li><code>FTP</code><strong>提供交互式的访问</strong>，允许客户<strong>指明文件的类型与格式</strong>（如指明是否使用<code>ASCII</code>码），并允许文件具有存取权限（如访问文件的用户必须经过授权）。</li><li><code>FTP</code>屏蔽了各计算机系统的细节，因而适合在异构网络中任意计算机之间传送文件。</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211112215837.png" alt="主动模式与被动模式"></p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>电子邮件发送过程：</p><ol><li>发件人将邮件发送到自己的<strong>邮件服务器</strong></li><li>邮件服务器按1其目的地址转发</li><li>收件人随时可获取收到的电子邮件</li></ol><p>电子邮件系统采用 C/S 方式，有3个主要组成构件：用户代理，邮件服务器以及电子邮件所需要的协议。</p><ul><li><strong>用户代理</strong>是用户与电子邮件系统的接口，又称为<strong>电子邮件客户端软件</strong>。</li><li><strong>邮件服务器</strong>是电子邮件系统的基础设施，其功能是<strong>发送和接收邮件</strong>，同时还要负责维护用户的邮箱。</li><li>协议包括邮件发送协议（例如<code>SMTP</code>）和邮件读取协议（例如<code>POP3</code>，<code>IMAP</code>）。</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211112220644.png" alt="邮件发送过程"></p><p><code>SMTP(Simple Mail Transfer Protocol)</code>协议只能传送<code>ASCII</code>码文本数据，不能传送可执行文件或其他的二进制对象。不能满足传送多媒体邮件的需要，为解决<code>SMTP</code>传送非<code>ASCII</code>码文本的问题，提出了多用途因特网邮件扩展<code>MIME(Multipurpose Internet MailExtensions)</code>。</p><h2 id="万维网-WWW"><a href="#万维网-WWW" class="headerlink" title="万维网 WWW"></a>万维网 WWW</h2><p>万维网<code>WWW(World Wide Web)</code><strong>并非某种特殊的计算机网络</strong>。它是一个大规模的、联机式的信息储藏所，<strong>是运行在因特网上的一个分布式应用</strong>。</p><ul><li><p>万维网利用网页之间的<strong>超链接</strong>将不同网站的网页链接成一张逻辑上的信息网。</p></li><li><p>万维网使用<strong>统一资源定位符<code>URL</code></strong>来指明因特网上任何种类“资源”的位置。</p></li><li><code>URL</code>的一般形式由以下四个部分组成：<code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code></li></ul><p><strong>超文本传输协议<code>HTTP(HyperText Transfer Protocol)</code></strong></p><p><code>HTTP</code>定义了浏览器怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器。</p><ul><li><p><code>HTTP/1.0</code>采用<strong>非持续连接</strong>方式。在该方式下，每次浏览器要请求一个文件都要与服务器建立<code>TCP</code>连接，当收到响应后就立即关闭连接。</p><ul><li><strong>每请求一个文档就要有两倍的<code>RTT</code>的开销</strong>。若一个网页上有很多引用对象（例如图片等)，那么请求每一个对象都需要花费<code>2RTT</code>    的时间。</li><li>为了减小时延，<strong>浏览器通常会建立多个并行的<code>TCP</code>连接同时请求多个对象</strong>。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。</li></ul><p><img src="/2021/11/13/ComputerNetwork/20211113094310.png" alt="请求文档过程"></p></li><li><p><code>HTTP/1.1</code>采用<strong>持续连接</strong>方式。在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的<code>HTTP</code>请求报文和响应报文。这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行。</p><ul><li>为了进一步提高效率，<code>HTTP/1.1</code>的持续连接还可以使用<strong>流水线</strong>方式工作，即浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文。</li></ul></li></ul><p><code>HTTP</code>的报文格式</p><p><code>HTTP</code>是<strong>面向文本</strong>的，其报文中的每一个<strong>字段</strong>都是一些<strong><code>ASCII</code>码串</strong>，并且每个字段的<strong>长度</strong>都是<strong>不确定</strong>的。</p><p><img src="/2021/11/13/ComputerNetwork/20211113094654.png" alt="HTTP请求报文格式"></p><p><img src="/2021/11/13/ComputerNetwork/20211113094744.png" alt="HTTP响应报文格式"></p><p><code>Cookie</code>是一种对无状态的<code>HTTP</code>进行状态化的技术，使得万维网服务器能够记住用户。</p><p><img src="/2021/11/13/ComputerNetwork/20211113095102.png" alt="Cookie原理"></p><p>万维网缓存与代理服务器</p><ul><li>利用缓存机制可以提高万维网效率</li><li>万维网缓存又称为<code>Web缓存(Web Cache)</code>，可位于客户机，也可位于中间系统上，位于中间系统上的<code>Web</code>缓存又称为<strong>代理服务器</strong><code>(Proxy Server)</code>。</li><li><code>Web</code>缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按<code>URL</code>的地址再次去因特网访问资源。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.bilibili.com/video/BV1c4411d7jb">计算机网络微课堂-湖科大教书匠</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring的IOC</title>
    <link href="/2021/10/12/SpringIOC/"/>
    <url>/2021/10/12/SpringIOC/</url>
    
    <content type="html"><![CDATA[<h1 id="IOC-是什么"><a href="#IOC-是什么" class="headerlink" title="IOC 是什么"></a>IOC 是什么</h1><p><code>IOC(Inversion Of Control)</code>，即控制反转</p><blockquote><p>什么是控制反转？</p><p>控制反转是一种将组件依赖关系的创建和管理置于程序外部的技术。</p><p>由容器控制程序之间的关系，而不是由代码直接控制。</p><p>由于控制权由代码转向了容器，所以称为反转。</p></blockquote><h1 id="对-IOC-的理解"><a href="#对-IOC-的理解" class="headerlink" title="对 IOC 的理解"></a>对 IOC 的理解</h1><p>IOC 是面向对象中的一种编程思想或原则。在传统方式中，当依赖一个对象时，需要主动去创建它并进行属性赋值，然后才能去使用这个对象。对于 IOC 来说，它使得对象或者组件的创建更为透明，你不需要过多地关注细节，如创建对象、属性赋值，这些工作交都由 IOC 容器来完成，已达到解耦的目的。</p><h1 id="举例说明-IOC"><a href="#举例说明-IOC" class="headerlink" title="举例说明 IOC"></a>举例说明 IOC</h1><p>通过借鉴知乎博主 <code>Jackpop</code> 的回答，假设目前有3个角色，卖家，买家，商品。</p><ol><li><p>写一个商品接口</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Goods</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>写实现3种商品的类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Drink</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Goods</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;get an drink&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Goods</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;get an food&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Goods</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;get an fruit&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>实现一个业务层</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Goods goods = <span class="hljs-keyword">new</span> Drink();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getGoods</span><span class="hljs-params">()</span></span>&#123;<br>        goods.get();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>再实现一个用户类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        UserService userService = <span class="hljs-keyword">new</span> Userservice();<br>        user.getGoods();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><p>上面为实现一个程序惯用的方式，如果需要修改获取的商品，则需要改动业务层代码</p><p><img src="/2021/10/12/SpringIOC/20211012204218.png" alt="业务层代码修改"></p><p>通过思考发现，目前的<strong>控制权</strong>在业务层，因此每次用户的需求发生变化时，业务层也需要跟着发生变化，所以便有了把控制权交给用户的做法，也就是控制权的反转。</p><p>可以通过在业务层的代码中增加一个 <strong>set </strong>方法，使得用户层可以<strong>注入</strong>不同的对象（传入哪个便获取哪个），来实现控制权的转换</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Goods goods = <span class="hljs-keyword">new</span> Drink();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGoods</span><span class="hljs-params">(Goods goods)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.goods = goods;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getGoods</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.goods.get();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面实现用户类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        UserService userService = <span class="hljs-keyword">new</span> Userservice();<br>        user.setGoods(<span class="hljs-keyword">new</span> Food());<br>        user.getGoods();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        UserService userService = <span class="hljs-keyword">new</span> Userservice();<br>        user.setGoods(<span class="hljs-keyword">new</span> Fruit());<br>        user.getGoods();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>总结：</strong>可以通过下面的图解来直观看到业务层加入 <strong>set</strong> 方法前后的变化，这就是 IOC 控制反转的核心思想。</p><p><img src="/2021/10/12/SpringIOC/20211012210021.png" alt="前后变化"></p><p>因此可以得出一些 IOC 的优点：</p><ol><li>降低组件之间的耦合度</li><li>实现软件各层之间的解耦</li><li>在不改变源码的情况下，实现外部对象动态注入到组件中</li><li>…</li></ol><blockquote><p>ioc的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。</p></blockquote><h1 id="IOC-与-DI-的关系与区别"><a href="#IOC-与-DI-的关系与区别" class="headerlink" title="IOC 与 DI 的关系与区别"></a>IOC 与 DI 的关系与区别</h1><p><code>DI(Dependency Injection)</code>，即依赖注入。DI 不完全等同于 IOC ，更应该说 DI 是 IOC 的一种实现方式或策略。</p><p>关系：依赖注入不能单独存在，需要在 IOC 基础之上完成操作</p><blockquote><p><strong>依赖查找DL(Dependency Lookup)</strong>和<strong>依赖注入</strong>都是 IOC 的实现策略。</p><p><strong>依赖查找</strong>就是在应用程序里面主动调用 IOC 容器提供的接口去获取对应的 Bean 对象，而<strong>依赖注入</strong>是在 IOC 容器启动或者初始化的时候，通过构造器、字段、setter 方法或者接口等方式注入依赖。<strong>依赖查找</strong>相比于<strong>依赖注入</strong>对于开发者而言更加繁琐，具有一定的代码入侵性，需要借助 IOC 容器提供的接口，所以我们总是强调后者。<strong>依赖注入</strong>在 IOC 容器中的实现也是调用相关的接口获取 Bean 对象，只不过这些工作都是在 IOC 容器启动时由容器帮你实现了，在应用程序中我们通常很少主动去调用接口获取 Bean 对象。</p></blockquote><h1 id="BeanFactory-和-ApplicationContext-谁才是-SpringIOC-容器？"><a href="#BeanFactory-和-ApplicationContext-谁才是-SpringIOC-容器？" class="headerlink" title="BeanFactory 和 ApplicationContext 谁才是 SpringIOC 容器？"></a>BeanFactory 和 ApplicationContext 谁才是 SpringIOC 容器？</h1><blockquote><p>BeanFactory 是 Spring 底层 IoC 容器，ApplicationContext 是 BeanFactory 的子接口，是 BeanFactory 的一个超集，提供 IoC 容器以外更多的功能。ApplicationContext 除了扮演 IoC 容器角色，还提供了这些企业特性：面向切面（AOP）、配置元信息、资源管理、事件机制、国际化、注解、Environment 抽象等。我们一般称 ApplicationContext 是 Spring 应用上下文，BeanFactory 为 Spring 底层 IoC 容器。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.zhihu.com/question/23277575/answer/1073420019">Spring IoC有什么好处呢？- 知乎</a></li><li><a href="http://www.manongjc.com/detail/22-intjsrbawbubggz.html">死磕Spring之IoC篇 - 深入了解Spring IoC（面试题）- 博客园</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
      <tag>DI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2021/10/11/BagProblem/"/>
    <url>/2021/10/11/BagProblem/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是背包问题"><a href="#什么是背包问题" class="headerlink" title="什么是背包问题"></a>什么是背包问题</h1><p><img src="/2021/10/11/BagProblem/20211011104935-16507891206031.png" alt="各类背包问题"></p><h1 id="01背包（重点）"><a href="#01背包（重点）" class="headerlink" title="01背包（重点）"></a>01背包（重点）</h1><blockquote><p>有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p></blockquote><p>以上就是一个经典的01背包问题。</p><p><img src="/2021/10/11/BagProblem/20211011102602.png" alt="背包问题"></p><h2 id="二维dp数组01背包"><a href="#二维dp数组01背包" class="headerlink" title="二维dp数组01背包"></a>二维dp数组01背包</h2><p>假设背包最大重量为4，物品为：</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">重量</th><th style="text-align:center">价值</th></tr></thead><tbody><tr><td style="text-align:center">物品0</td><td style="text-align:center">1</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">物品1</td><td style="text-align:center">3</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">物品2</td><td style="text-align:center">4</td><td style="text-align:center">30</td></tr></tbody></table></div><p>问背包能背的物品最大价值是多少？</p><ol><li><p>dp[i, j]表示从下表i为0-i的物品中任意取，放进容量为j的背包，价值总和最大是多少</p></li><li><p><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code> </p></li><li><p><code>dp[i][0] = 0</code>, <code>dp[0][j] = 15</code></p></li><li><p>确定遍历顺序，先遍历物品再遍历背包重量（均可，但先遍历物品更好理解）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagWeight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>推导一遍dp数组</p><p>|     | 0   | 1   | 2   | 3   | 4   |<br>|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|<br>| 物品0 | 0   | 15  | 15  | 15  | 15  |<br>| 物品1 | 0   | 15  | 15  | 20  | 35  |<br>| 物品2 | 0   | 15  | 15  | 20  | 35  |</p></li></ol><p><strong>难点：初始化和遍历顺序</strong></p><h2 id="一维dp数组（滚动数组）"><a href="#一维dp数组（滚动数组）" class="headerlink" title="一维dp数组（滚动数组）"></a>一维dp数组（滚动数组）</h2><p>原递推公式为：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i] + value[i]])</code>，<code>dp[i][j]</code>的值只与上一层的值有关，所以可以只用一个一维数组</p><ol><li><p>dp[j] 表示容量为j的背包，所背的物品价值可以最大为dp[j]</p></li><li><p><code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code></p></li><li><p>初始为0</p></li><li><p>遍历顺序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>[注意]：二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。<strong>倒叙遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p></li><li><p>推导一遍</p><p>物品0：</p><p>| 0   | 15  | 15  | 15  | 15  |<br>|:—-:|:—-:|:—-:|:—-:|:—-:|</p><p>物品1：</p><p>| 0   | 15  | 15  | 20  | 35  |<br>|:—-:|:—-:|:—-:|:—-:|:—-:|</p><p>物品2：</p><p>| 0   | 15  | 15  | 20  | 35  |<br>|:—-:|:—-:|:—-:|:—-:|:—-:|</p></li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">leetcode-416. 分割等和子集</a></li><li><a href="https://leetcode-cn.com/problems/target-sum/">leetcode-494. 目标和</a></li><li><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">leetcode-474. 一和零</a></li></ol><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><blockquote><p>有 N 件物品和一个最多能背重量为 W 的背包。第 i 件物品的重量是 weight[i] ，得到的价值是 value[i]。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p></blockquote><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。</strong></p><p>举例：背包最大重量为4。</p><p>每件物品都有无限个，物品为：</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">重量</th><th style="text-align:center">价值</th></tr></thead><tbody><tr><td style="text-align:center">物品0</td><td style="text-align:center">1</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">物品1</td><td style="text-align:center">3</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">物品2</td><td style="text-align:center">4</td><td style="text-align:center">30</td></tr></tbody></table></div><p>回顾01背包的遍历顺序，因为要保证每个物品只被添加一次，所以遍历背包容量时是倒序的。而完全背包的物品是可以添加多次的，所以可以直接正序遍历。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//先遍历物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++)&#123;<br>    <span class="hljs-comment">//再遍历背包</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = weight[i]; j &lt; bagWeight; j++)&#123;<br>        dp[j] = max(dp[j], dp[i - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。</p><p><strong>在完全背包中，对于有一维dp数组来说，其实两个for循环嵌套顺序同样无所谓</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 先遍历背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagWeight; j++) &#123;<br>    <span class="hljs-comment">//再遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (j - weight[i] &gt;= <span class="hljs-number">0</span>) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>以上所描述的都是对于纯完全背包问题，其 for 循环的先后循环是可以颠倒的！</strong></p><p><img src="/2021/10/11/BagProblem/20211020203125.png" alt="实际问题"></p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><ol><li><a href="https://leetcode-cn.com/problems/coin-change-2/">leetcode-518. 零钱兑换II</a></li><li><a href="https://leetcode-cn.com/problems/combination-sum-iv/">leetcode-377. 组合总和IV</a></li><li><a href="https://leetcode-cn.com/problems/climbing-stairs/">leetcode-70. 爬楼梯</a></li><li><a href="https://leetcode-cn.com/problems/coin-change/">leetcode-322. 零钱兑换</a></li><li><a href="https://leetcode-cn.com/problems/perfect-squares/">leetcode-279. 完全平方数</a></li><li><a href="https://leetcode-cn.com/problems/word-break/">leetcode-139. 单词拆分</a></li></ol><p><img src="/2021/10/11/BagProblem/picture/20211020202924.png" alt="背包递推公式"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://programmercarl.com/">代码随想录</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法</title>
    <link href="/2021/09/28/Backtrack/"/>
    <url>/2021/09/28/Backtrack/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是回溯法"><a href="#什么是回溯法" class="headerlink" title="什么是回溯法"></a>什么是回溯法</h1><p>回溯法是一种搜索方式，只要有递归就会有回溯</p><p>回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案。对回溯进行优化可以加一些剪枝的操作，但是也不会改变回溯法就是穷举的本质</p><p><strong>剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了</strong></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>组合无序，排列有序</p><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>回溯法可以理解为<strong>树形结构</strong>，因为回溯法解决的问题都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</p><p>递归是需要有终止条件的，所以一定是一颗高度有限的树</p><h1 id="模板-—（重要）"><a href="#模板-—（重要）" class="headerlink" title="模板 —（重要）"></a>模板 —（重要）</h1><ul><li>回溯函数模板返回值和参数</li></ul><p><strong>返回值</strong>：回溯算法中函数返回值一般为void</p><p><strong>参数</strong>：一般先写逻辑，然后需要什么参数，就填什么参数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(参数)</span></span><br></code></pre></div></td></tr></table></figure><ul><li>回溯函数终止条件</li></ul><p>因为回溯法可以理解为树形结构，所以一般来说，搜索到叶子节点时，也就是找到了满足条件的一条答案，把这个答案存起来，并结束本层递归</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (终止条件)&#123;<br>    存放结果;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>回溯搜索的遍历过程</li></ul><p>回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成了树的深度</p><p><img src="/2021/09/28/Backtrack/20210927202307.png" alt="回溯搜索的遍历过程"></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (选择 : 本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>    处理节点;<br>    backtrack(路径, 选择列表);  <span class="hljs-comment">//递归</span><br>    回溯，撤销处理结果<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>for循环是横向遍历，backtrack是纵向遍历</strong>，这样就把这棵树全遍历完了。一般来说，搜索叶子节点就是找的其中一个结果</p><p>故回溯法模板如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (选择 : 本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtrack(路径, 选择列表);   <span class="hljs-comment">//递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><p>下面的题目主要包括排列和组合</p><ol><li><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">leetcode-17. 电话号码的字母组合</a></li><li><a href="https://leetcode-cn.com/problems/generate-parentheses/">leetcode-22. 括号生成</a></li><li><a href="https://leetcode-cn.com/problems/combination-sum/">leetcode-39. 组合总和</a></li><li><a href="https://leetcode-cn.com/problems/combination-sum-ii/">leetcode-40. 组合总和2</a></li><li><a href="https://leetcode-cn.com/problems/permutations/">leetcode-46. 全排列</a></li><li><a href="https://leetcode-cn.com/problems/permutations-ii/">leetcode-47. 全排列2</a></li><li><a href="https://leetcode-cn.com/problems/combinations/">leetcode-77. 组合</a></li><li><a href="https://leetcode-cn.com/problems/subsets/">leetcode-78. 子集</a></li></ol><h1 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h1><p>通过上述题目，可以知道回溯算法的难点在于回溯函数参数的选择以及纵向遍历时递归到下一层时参数的变化，尤其注意区分排列和组合</p><p><img src="/2021/09/28/Backtrack/20210927205650.png" alt="17. 电话号码的字母组合"></p><p><img src="/2021/09/28/Backtrack/20210927205905.png" alt="22. 括号生成"></p><p><img src="/2021/09/28/Backtrack/20210927205954.png" alt="39. 组合总和"></p><p><img src="/2021/09/28/Backtrack/20210927210041.png" alt="40. 组合总和2"></p><p><img src="/2021/09/28/Backtrack/20210927210116.png" alt="46. 全排列"></p><p><img src="/2021/09/28/Backtrack/20210927210152.png" alt="47. 全排列2"></p><p><img src="/2021/09/28/Backtrack/20210927210345.png" alt="77. 组合"></p><p><img src="/2021/09/28/Backtrack/20210927210421-16507901069191.png" alt="78. 子集"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录-回溯算法理论基础</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2021/08/23/RBTree/"/>
    <url>/2021/08/23/RBTree/</url>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树又叫二叉排序树，也叫二叉搜索树，左节点小于根节点，右节点大于根节点。没有键值相等的结点。</p><p>示例图：</p><p><img src="/2021/08/23/RBTree/20210819160450.png" alt="示例图"></p><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    T data;<br>    BinarySearchTree&lt;T&gt; left;<br>    BinarySearchTree&lt;T&gt; right;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinarySearchTree</span><span class="hljs-params">(T data)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(data, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinarySearchTree</span><span class="hljs-params">(T data, BinarySearchTree&lt;T&gt; left, BinarySearchTree&lt;T&gt; right)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>        <span class="hljs-keyword">this</span>.left = left;<br>        <span class="hljs-keyword">this</span>.right = right;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>每一个结点的左子树和右子树的高度差最多为1的二叉查找树。因此查找、插入和删除的时间复杂度都变成了O(logn)</p><blockquote><p>为了反映每个结点的高度差，在二叉查找树的结点中应该增加一个新的域——被称为平衡因子(BF)，它的值是某个根结点的左子树深度减右子树深度的值。易知，<strong>对于一棵平衡二叉树，每个结点的平衡因子只可能是-1、0、1三种可能</strong></p></blockquote><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>含有红黑结点并能自平衡的二叉查找树，时间复杂度为O(logn)</p><p><strong>一颗含有n个结点的红黑树的高度最多为2log(n+1)</strong></p><p>性质：</p><ol><li>每个结点要么是黑色，要么是红色</li><li>根结点是黑色</li><li>每个叶子结点是黑色</li><li>每个红色结点的两个子结点一定都是黑色，可以出现连续的黑色结点</li><li><strong>任意一结点到每个叶子结点的路径都包含数量相同的黑结点</strong><ul><li>如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li></ul></li></ol><p>下图为一颗红黑树，其中的红色结点H和M同样存在叶子结点，并且是黑色的</p><p><img src="/2021/08/23/RBTree/202108221555291.png" alt="红黑树"></p><blockquote><p>红黑树并不是一个完美平衡二叉查找树，根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，这种平衡叫做<strong>黑色完美平衡</strong></p></blockquote><p>红黑树实现代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RBTree</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">D</span>&gt;</span>&#123;<br><br>    <span class="hljs-comment">//根节点</span><br>    <span class="hljs-keyword">private</span> RBNode&lt;T, D&gt; root;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 结点的颜色</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Boolean RED = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Boolean BLACK = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RBNode</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">D</span>&gt;</span>&#123;<br>        <span class="hljs-comment">//结点颜色</span><br>        <span class="hljs-keyword">private</span> Boolean color;<br>        <span class="hljs-comment">//键值</span><br>        <span class="hljs-keyword">private</span> T key;<br>        <span class="hljs-comment">//具体的数据</span><br>        <span class="hljs-keyword">private</span> D data;<br>        <span class="hljs-keyword">private</span> RBNode&lt;T, D&gt; parent;<br>        <span class="hljs-keyword">private</span> RBNode leftChild;<br>        <span class="hljs-keyword">private</span> RBNode rightChild;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RBNode</span><span class="hljs-params">(Boolean color, T key, D data, RBNode&lt;T, D&gt; parent, RBNode leftChild, RBNode rightChild)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.color = color;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.data = data;<br>            <span class="hljs-keyword">this</span>.parent = parent;<br>            <span class="hljs-keyword">this</span>.leftChild = leftChild;<br>            <span class="hljs-keyword">this</span>.rightChild = rightChild;<br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>红黑树能够自平衡靠的是三种操作，分别是左旋，右旋和变色</p><ul><li><strong>左旋</strong>：以某个结点为支点，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变</li><li><strong>右旋</strong>：以某个结点为支点，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变</li><li><strong>变色</strong>：结点的颜色由红变黑或由黑变红</li></ul><p><img src="/2021/08/23/RBTree/202108221613922.png" alt="左旋"></p><p><img src="/2021/08/23/RBTree/202108221614211.png" alt="右旋"></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对某个节点进行左旋</span><br><span class="hljs-comment"> * （当前节点就是父亲节点，整体过程就是 父亲下沉，右孩子上升，然后右孩子的左节点变成了原父亲的右节点）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftRotate</span><span class="hljs-params">(RBNode&lt;T, D&gt; x)</span> </span>&#123;<br><br>    <span class="hljs-comment">//右孩子</span><br>    RBNode&lt;T, D&gt; y = x.rightChild;<br><br>    <span class="hljs-keyword">if</span> (y.leftChild != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//当前结点变成了右孩子的左孩子节点的父亲</span><br>        y.leftChild.parent = x;<br>    &#125;<br>    <span class="hljs-comment">//右孩子的左孩子结点变成了当前结点的右孩子结点</span><br>    x.rightChild = y.leftChild;<br>    <span class="hljs-comment">//当前结点变成了原右孩子的左孩子结点</span><br>    y.leftChild = x;<br>    <span class="hljs-comment">//当前的父亲变成了右孩子的父亲</span><br>    y.parent = x.parent;<br><br>    <span class="hljs-keyword">if</span> (x.parent != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (x.parent.leftChild == x) &#123;<br>            x.parent.leftChild = y;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            x.parent.rightChild = y;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.root = y;<br>    &#125;<br>    x.parent = y;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 对某个节点进行右旋</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightRotate</span><span class="hljs-params">(RBNode&lt;T, D&gt; x)</span> </span>&#123;<br>    <br>    <span class="hljs-comment">//左孩子</span><br>    RBNode&lt;T, D&gt; y = x.leftChild;<br><br>    <span class="hljs-keyword">if</span> (y.rightChild != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//当前结点变成了左孩子的右孩子节点的父亲</span><br>        y.rightChild.parent = x;<br>    &#125;<br><br>    <span class="hljs-comment">//当前结点的父亲变成了左孩子的父亲</span><br>    y.parent = x.parent;<br>    <span class="hljs-comment">//左孩子的右孩子变成了当前结点的左孩子</span><br>    x.leftChild = y.rightChild;<br>    <span class="hljs-comment">//当前结点变成了原左孩子的右孩子结点</span><br>    y.rightChild = x;<br><br>    <span class="hljs-keyword">if</span> (x.parent != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (x.parent.leftChild == x) &#123;<br>            x.parent.leftChild = y;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            x.parent.rightChild = y;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.root = y;<br><br>    &#125;<br>    x.parent = y;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>小结：</p><ul><li>左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树移了</li><li>右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树移了</li></ul><h2 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h2><p>等同于二叉查找树的查找，下图为查找的流程图</p><p><img src="/2021/08/23/RBTree/202108221646758.png" alt="红黑树查找流程图"></p><p>由于红黑树黑色完美平衡的特性，所以查找的最坏时间复杂度为O(2logn)</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 红黑树的查找</span><br><span class="hljs-comment"> * 寻找为key值的节点（递归实现）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RBNode&lt;T, D&gt; <span class="hljs-title">search</span><span class="hljs-params">(T key, RBNode&lt;T, D&gt; node)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//查找的过程，就是一直递归比较到叶子为止</span><br>        <span class="hljs-keyword">int</span> com = key.compareTo(node.key);<br>        <span class="hljs-keyword">if</span> (com &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//目标key值小于当前key值</span><br>            <span class="hljs-keyword">return</span> search(key, node.leftChild);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (com &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//目标key值大于当前key值</span><br>            <span class="hljs-keyword">return</span> search(key, node.rightChild);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 红黑树的查找</span><br><span class="hljs-comment"> * 寻找为key值的节点（非递归实现）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RBNode&lt;T, D&gt; <span class="hljs-title">iterativeSearch</span><span class="hljs-params">(T key, RBNode&lt;T, D&gt; node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">int</span> com = key.compareTo(node.key);<br>        <span class="hljs-keyword">if</span> (com &lt; <span class="hljs-number">0</span>)&#123;<br>            node = node.leftChild;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (com &gt; <span class="hljs-number">0</span>)&#123;<br>            node = node.rightChild;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h2><p>红黑树的插入主要分为两部分：</p><ol><li>查找插入的位置即寻找插入的父结点</li><li>插入后自平衡</li></ol><p>下图为查找插入位置的流程图：</p><p><img src="/2021/08/23/RBTree/202108222047439.png" alt="红黑树查找插入位置流程图"></p><p>红黑树的插入场景有很多种，分别如下图所示：</p><p><img src="/2021/08/23/RBTree/202108222059381.png" alt="红黑树的8种插入场景"></p><p><strong>注</strong>：I表示插入结点，P表示插入结点的父结点，S表示插入结点的叔叔结点，PP表示插入结点的祖父结点</p><p>插入示例：</p><p><img src="/2021/08/23/RBTree/202108222122352.png" alt="红黑树插入示例"></p><p>代码（略）</p><h2 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h2><p>红黑树的删除也包含两部分：</p><ol><li>查找目标结点</li><li>删除后自平衡</li></ol><p>二叉树删除结点找替代结点有3种情情景：</p><ul><li>情景1：若删除结点无子结点，直接删除</li><li>情景2：若删除结点只有一个子结点，用子结点替换删除结点</li><li>情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点</li></ul><p><strong>把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点</strong></p><p><img src="/2021/08/23/RBTree/202108222145172.png" alt="image-20210822214523037"></p><p>思路：<strong>删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点</strong></p><p><img src="/2021/08/23/RBTree/202108222146105.png" alt="image-20210822214622908"></p><p>因此3种删除情景均可转换为情景1：</p><ul><li>情景2：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为情景3，一直自顶向下转换，总是能转换为情景1</li><li>情景3：删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景2，否则转为为情景1</li></ul><p>小结：<strong>删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末，所以只用考虑删除树末结点的情景</strong></p><p>红黑树删除操作的所有情景如下图：</p><p><img src="/2021/08/23/RBTree/202108222147197.png" alt="红黑树删除情景"></p><p><strong>注</strong>：R表示替代结点，P表示替代结点的父结点，S表示替代结点的兄弟结点，SL表示兄弟结点的左子结点，SR表示兄弟结点的右子结点。灰色结点表示它可以是红色也可以是黑色</p><p>删除示例：</p><p><img src="/2021/08/23/RBTree/202108222157255.png" alt="红黑树删除示例"></p><p>代码（略）</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.jianshu.com/p/ff4b93b088eb">数据结构(二):二叉搜索树(Binary Search Tree) - 简书</a></li><li><a href="https://www.jianshu.com/p/3a6650269d39">数据结构与算法—从平衡二叉树(AVL)到红黑树 - 简书</a></li><li><a href="https://www.jianshu.com/p/e136ec79235c">30张图带你彻底理解红黑树 - 简书</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉查找树</tag>
      
      <tag>平衡二叉树</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2021/08/19/BinaryTree/"/>
    <url>/2021/08/19/BinaryTree/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>二叉树的特点是每个结点最多只能有两颗子树，且有左右之分。</p><blockquote><p>定义：</p><p>二叉树（binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。</p></blockquote><p>一些类型：</p><ul><li>满二叉树：只有度为0的结点和度为2的结点，并且度为0的结点在同一层上</li><li>完全二叉树：深度为k，有n个结点的二叉树当且仅当其每一个结点都与深度为k的满二叉树中编号从1到n的结点一一对应。</li></ul><p>完全二叉树的特点：</p><ol><li>叶子结点只可能出现在层序最大的两层上</li><li>某个结点的左分支下子孙的最大层序与右分支下子孙的最大层序相等或大1</li></ol><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>二叉树有深度遍历和广度遍历，深度遍历有前序遍历，中序遍历，后序遍历三种遍历方法，广度遍历即层次遍历</p><blockquote><p><em>注：二叉树的先序遍历才是严格按图的深度优先的算法，但是中序和后序也是深度优先，只是访问根结点的时机不同</em></p></blockquote><ul><li>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</li><li>中序遍历：左子树 —&gt; 根结点 —&gt; 右子树</li><li>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</li><li>层序遍历：按层从左至右</li></ul><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 前序遍历递归版本</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse1</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>)&#123;<br>        System.out.print(root.val + <span class="hljs-string">&quot; &quot;</span>);<br>        preOrderTraverse1(root.left);<br>        preOrderTraverse1(root.right);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><p>思路：</p><ol><li>先访问头结点，并把头节点入栈，当前节点置为左孩子</li><li>判断节点是否为空，若为空，则取出栈顶结点并出栈，将右孩子置为当前结点；若不为空，则重复1直到当前结点为空或栈为空</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 前序遍历非递归版本</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse2</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>    LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    TreeNode pNode = root;<br>    <span class="hljs-keyword">while</span> (pNode != <span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;<br>        <span class="hljs-keyword">if</span> (pNode != <span class="hljs-keyword">null</span>)&#123;<br>            System.out.print(pNode.val + <span class="hljs-string">&quot; &quot;</span>);<br>            stack.push(pNode);<br>            pNode = pNode.left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            TreeNode node = stack.pop();<br>            pNode = node.right;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 前序遍历非递归版本2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse3</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    stack.push(root);<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>        TreeNode node = stack.pop();<br>        System.out.print(node.val + <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;<br>            stack.push(node.right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;<br>            stack.push(node.left);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 中序遍历递归版本</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse1</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>)&#123;<br>        inOrderTraverse1(root.left);<br>        System.out.print(root.val + <span class="hljs-string">&quot; &quot;</span>);<br>        inOrderTraverse1(root.right);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 中序遍历非递归版本</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse2</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>    LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    TreeNode pNode = root;<br>    <span class="hljs-keyword">while</span> (pNode != <span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;<br>        <span class="hljs-keyword">if</span> (pNode != <span class="hljs-keyword">null</span>)&#123;<br>            stack.push(pNode);<br>            pNode = pNode.left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            TreeNode node = stack.pop();<br>            System.out.print(node.val + <span class="hljs-string">&quot; &quot;</span>);<br>            pNode = node.right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 后序遍历递归版本</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse1</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>)&#123;<br>        postOrderTraverse1(root.left);<br>        postOrderTraverse1(root.right);<br>        System.out.print(root.val + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h3><p>思路：需要用到两个栈，在节点不为空的情况下，依次将根节点、右儿子、左儿子压入一个栈stack2中，最后一起打印栈中的元素</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 后序遍历非递归版本</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse2</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>    LinkedList&lt;TreeNode&gt; stack1 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    LinkedList&lt;TreeNode&gt; stack2 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    TreeNode pNode = root;<br>    <span class="hljs-keyword">while</span> (pNode != <span class="hljs-keyword">null</span> || !stack1.isEmpty())&#123;<br>        <span class="hljs-keyword">while</span> (pNode != <span class="hljs-keyword">null</span>)&#123;<br>            stack1.push(pNode);<br>            stack2.push(pNode);<br>            pNode = pNode.right;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!stack1.isEmpty())&#123;<br>            pNode = stack1.pop();<br>            pNode = pNode.left;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!stack2.isEmpty())&#123;<br>        TreeNode node = stack2.pop();<br>        System.out.print(node.val + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>思路：先在队列中加入根节点，之后对于任意一个节点来说，在其出队列的时候，访问之，同时如果左孩子和右孩子有不为空的，入队列</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 层序遍历</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">levelTraverse</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    queue.offer(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        TreeNode node = queue.poll();<br>        System.out.print(node.val + <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>            queue.offer(node.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>            queue.offer(node.right);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历 DFS"></a>深度优先遍历 DFS</h2><p>等同于前序遍历</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 深度优先遍历  DFS</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depthOrderTraverse</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    stack.push(root);<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>        TreeNode node = stack.pop();<br>        System.out.print(node.val + <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>            stack.push(node.right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>            stack.push(node.left);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历 BFS"></a>广度优先遍历 BFS</h2><p>等同于层序遍历</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 广度优先遍历 BFS </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">widthOrderTraverse</span><span class="hljs-params">(TreeNode root)</span></span>&#123;    <br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;        <br>        <span class="hljs-keyword">return</span>;    <br>    &#125;    <br>    LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <br>    queue.offer(root);    <br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;        <br>        TreeNode node = queue.poll();        <br>        System.out.print(node.val + <span class="hljs-string">&quot; &quot;</span>);        <br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;            <br>            queue.offer(node.left);        <br>        &#125;        <br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;            <br>            queue.offer(node.right);        <br>        &#125;    <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/My_Jobs/article/details/43451187">二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）My_Jobs的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/dabusiGin/article/details/102736180">二叉树后序遍历（递归+非递归）Java_dabusiGin的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十大经典排序算法</title>
    <link href="/2021/08/14/Sort/"/>
    <url>/2021/08/14/Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><p>十种常见的排序算法可以分为两大类：</p><ul><li>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序</li><li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序</li></ul><p><img src="/2021/08/14/Sort/20210813112159.png" alt="排序算法"></p><div class="table-container"><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(logn)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">计数排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(k)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center">O(n+k)</td><td style="text-align:center">O(n+k)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center">O(n*k)</td><td style="text-align:center">O(n+k)</td><td style="text-align:center">稳定</td></tr></tbody></table></div><p>注：</p><ul><li>稳定：如果a原本在b的前面，而a = b，排序之后a仍然在b的前面。不稳定则表示a也可能出现在b的后面</li></ul><h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h1><p>比较相邻的元素，若前者大于后者则交换位置，从头到尾遍历整个数组。</p><blockquote><p>特点：<strong>当输入的数据已经是正序时最快O(n)，当输入的数据是反序时最慢</strong></p></blockquote><p>当数据较大时，冒泡排序算法的时间代价最高。</p><p>动图演示：</p><p><img src="/2021/08/14/Sort/20210813113619.gif" alt="冒泡排序"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] bubbleSort(<span class="hljs-keyword">int</span>[] arr)&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j + <span class="hljs-number">1</span>] &lt; arr[j])&#123;<br>                <span class="hljs-comment">//交换元素位置</span><br>                swap(arr, j + <span class="hljs-number">1</span>, j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h1><p>在未排序序列中找到最小元素，存放到排序序列的起始位置，再从剩余的未排序元素中继续寻找最小元素，存放到已排序序列的末尾。直到所有元素排序完毕。</p><blockquote><p>特点：表现稳定，无论什么数据进去都是O(n)的时间复杂度，所以适合小规模数据排序</p></blockquote><p>动图演示：</p><p><img src="/2021/08/14/Sort/20210813152845.gif" alt="选择排序"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] selectionSort(<span class="hljs-keyword">int</span>[] arr)&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">int</span> minIndex;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        minIndex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex])&#123;<br>                <span class="hljs-comment">//将最小的数的索引保存</span><br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//交换元素位置</span><br>        swap(arr, i, minIndex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h1><p>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置插入。将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><blockquote><p><strong>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入</strong></p></blockquote><p>动图演示：</p><p><img src="/2021/08/14/Sort/20210813155215.gif" alt="插入排序"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] insertionSort(<span class="hljs-keyword">int</span>[] arr)&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">int</span> preIndex, cur;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-comment">//已排序序列的末尾索引</span><br>        preIndex = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//当前索引</span><br>        cur = arr[i];<br>        <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; cur) &#123;<br>            arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>            preIndex--;<br>        &#125;<br>        arr[preIndex + <span class="hljs-number">1</span>] = cur;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h1><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。一般最初步长选择为数组长度的一半，直到最终的步长为1。</p><blockquote><p> 简单插入排序的改进版，非稳定排序算法，优先比较距离较远的元素。又叫<strong>递减增量排序</strong>。</p></blockquote><p>图解：</p><p><img src="/2021/08/14/Sort/20210813161210.png" alt="希尔排序"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] shellSort(<span class="hljs-keyword">int</span>[] arr)&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> step = arr.length / <span class="hljs-number">2</span>; step &gt;= <span class="hljs-number">1</span>; step /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = step; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">int</span> cur = arr[i];<br>            <span class="hljs-keyword">int</span> j = i - step;<br>            <span class="hljs-comment">//比较同一组内的元素</span><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; cur)&#123;<br>                arr[j + step] = arr[j];<br>                j -= step;<br>            &#125;<br>            arr[j + step] = cur;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h1><p>将一个无序数组分成两个，然后对这两个数组分别进行排序，之后在把这两个数组合并成一个有序的数组。通过递归的方式将大的数组一直分割，直到数组的大小为 1，此时只有一个元素，那么该数组就是有序的了，之后再把两个数组大小为1的合并成一个大小为2的，再把两个大小为2的合并成4的 ….. 直到全部小的数组合并起来。</p><blockquote><p>归并排序是采用分治法的一个非常典型的应用。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p></blockquote><p>图解：</p><p><img src="/2021/08/14/Sort/20210813170535.png" alt="归并排序"></p><p>动图演示：</p><p><img src="/2021/08/14/Sort/20210813165945.gif" alt="归并排序"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 归并排序</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] mergeSort(<span class="hljs-keyword">int</span>[] arr)&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">int</span> middle = (<span class="hljs-keyword">int</span>) Math.floor(arr.length / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">int</span>[] left = Arrays.copyOfRange(arr, <span class="hljs-number">0</span>, middle);<br>    <span class="hljs-keyword">int</span>[] right = Arrays.copyOfRange(arr, middle, arr.length);<br>    <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 合并函数，把两个有序的数组合并起来</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] merge(<span class="hljs-keyword">int</span>[] left, <span class="hljs-keyword">int</span>[] right)&#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[left.length + right.length];<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left.length &gt; <span class="hljs-number">0</span> &amp;&amp; right.length &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span> (left[<span class="hljs-number">0</span>] &lt; right[<span class="hljs-number">0</span>])&#123;<br>            res[i++] = left[<span class="hljs-number">0</span>];<br>            left = Arrays.copyOfRange(left, <span class="hljs-number">1</span>, left.length);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[i++] = right[<span class="hljs-number">0</span>];<br>            right = Arrays.copyOfRange(right, <span class="hljs-number">1</span>, right.length);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (left.length &gt; <span class="hljs-number">0</span>)&#123;<br>        res[i++] = left[<span class="hljs-number">0</span>];<br>        left = Arrays.copyOfRange(left, <span class="hljs-number">1</span>, left.length);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (right.length &gt; <span class="hljs-number">0</span>)&#123;<br>        res[i++] = right[<span class="hljs-number">0</span>];<br>        right = Arrays.copyOfRange(right, <span class="hljs-number">1</span>, right.length);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h1><p>从数组中跳出一个基准元素pivot，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边），再把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><blockquote><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p><em>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</em></p></blockquote><p>动图演示：</p><p><img src="/2021/08/14/Sort/20210813194135.gif" alt="快速排序"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] quickSort(<span class="hljs-keyword">int</span>[] arr)&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">return</span> quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] quickSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)&#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> partitionIndex = partition(arr, left, right);<br>        quickSort(arr, left, partitionIndex - <span class="hljs-number">1</span>);<br>        quickSort(arr, partitionIndex + <span class="hljs-number">1</span>, right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分区操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-comment">// 设定基准值（pivot）</span><br>    <span class="hljs-keyword">int</span> pivot = left;<br>    <span class="hljs-keyword">int</span> index = pivot + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt;= right; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;<br>            swap(arr, i, index);<br>            index++;<br>        &#125;<br>    &#125;<br>    swap(arr, pivot, index - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> index - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h1><p>利用堆的概念来排序的选择排序。创建堆，把堆首和堆尾的元素互换，然后把堆的长度减1，再进行调整，直到长度为1。</p><blockquote><p> 可以分为两种：</p><ul><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列</li></ul></blockquote><p>堆排序在数据量很大时效果明显（堆排序适合处理大数据）</p><p>动画演示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="堆排序"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] heapSort(<span class="hljs-keyword">int</span>[] arr)&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-comment">//创建大根堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        heapInsert(arr, i);<br>    &#125;<br>    <span class="hljs-keyword">int</span> size = arr.length;<br>    <span class="hljs-comment">//交换堆顶和堆的最后一个元素，并把堆的长度减1</span><br>    swap(arr, <span class="hljs-number">0</span>, --size);<br>    <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//调整堆</span><br>        heapAdjust(arr, <span class="hljs-number">0</span>, size);<br>        <span class="hljs-comment">//交换堆顶和堆的最后一个元素，并把堆的长度减1</span><br>        swap(arr, <span class="hljs-number">0</span>, --size);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h1><p>使用一个辅助数组，遍历待排序的数据，<strong>待排序数据的值</strong>就是<strong>辅助数组的索引</strong>，辅助数组索引对应的位置保存这个待排序数据出现的次数。最后从辅助数组中取出待排序的数据，放到排序后的数组中。</p><p>动画演示：</p><p><img src="/2021/08/14/Sort/20210813204703.gif" alt="计数"></p><blockquote><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是<strong>有确定范围的整数</strong>。计数排序<strong>不是比较排序</strong>，排序的速度快于任何比较排序算法。</p></blockquote><p><strong>计数排序适用于数据量很大，但是数据的范围比较小的情况，且只能用于非负整数</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] countSort(<span class="hljs-keyword">int</span>[] arr)&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//寻找最大值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;<br>        <span class="hljs-keyword">if</span> (max &lt; num) &#123;<br>            max = num;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//创建大小为max的辅助数组</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//统计元素i出现的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;<br>        temp[num]++;<br>    &#125;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//把辅助数组统计好的数据汇总到原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= max; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = temp[i]; j &gt; <span class="hljs-number">0</span>; j--) &#123;<br>            arr[index++] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码是可以进行优化的</p><p>**优化：对任意指定范围内的数字进行排序，创建的临时数组大小 (max - min + 1)就可以了。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计数排序优化1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] countSort2(<span class="hljs-keyword">int</span>[] arr)&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> min = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//寻找最值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;<br>        <span class="hljs-keyword">if</span> (max &lt; num) &#123;<br>            max = num;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (min &gt; num) &#123;<br>            min = num;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//创建大小为max - min + 1的辅助数组</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max - min + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//统计元素i出现的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;<br>        temp[num - min]++;<br>    &#125;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//把辅助数组统计好的数据汇总到原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= max - min; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = temp[i]; j &gt; <span class="hljs-number">0</span>; j--) &#123;<br>            arr[index++] = i + min;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h1><blockquote><p>桶排序是计数排序的升级版</p></blockquote><p>桶排序就是把最大值和最小值之间的数进行瓜分，例如分成  10 个区间，10个区间对应10个桶，我们把各元素放到对应区间的桶中去，再对每个桶中的数进行排序，可以采用归并排序，也可以采用快速排序之类的。</p><p>当输入的数据可以均匀分配到每一个桶中是最快，时间复杂度为O(n)，输入的数据被分配到了同一个桶中时最慢，时间复杂度为O(n^2)。</p><p>图解：</p><p><img src="/2021/08/14/Sort/20210813212053.png" alt="桶排序"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] BucketSort(<span class="hljs-keyword">int</span>[] arr)&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> min = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//寻找数组的最值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;<br>        <span class="hljs-keyword">if</span> (max &lt; num) &#123;<br>            max = num;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (min &gt; num) &#123;<br>            min = num;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//和优化版本的计数排序一样，弄一个大小为 min 的偏移值</span><br>    <span class="hljs-keyword">int</span> offset = max - min;<br>    <span class="hljs-comment">//设桶的默认大小为5</span><br>    <span class="hljs-keyword">int</span> bucketSize = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">//创建 d / 5 + 1 个桶，第 i 桶存放  5*i ~ 5*i+5-1范围的数</span><br>    <span class="hljs-keyword">int</span> bucketNum = offset / <span class="hljs-number">5</span> + <span class="hljs-number">1</span>;<br>    ArrayList&lt;LinkedList&lt;Integer&gt;&gt; bucketList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(bucketNum);<br>    <span class="hljs-comment">//初始化桶</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketNum; i++) &#123;<br>        bucketList.add(<span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;());<br>    &#125;<br>    <span class="hljs-comment">//遍历原数组，将每个元素放入桶中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;<br>        bucketList.get((num - min) / offset).add(num - min);<br>    &#125;<br>    <span class="hljs-comment">//对桶内元素进行排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketNum; i++) &#123;<br>        Collections.sort(bucketList.get(i));<br>    &#125;<br>    <span class="hljs-comment">//把每个桶排序好的数据进行合并汇总放回原数组</span><br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketNum; i++) &#123;<br>        <span class="hljs-keyword">for</span> (Integer val : bucketList.get(i)) &#123;<br>            arr[index++] = val + min;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h1><p>先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小……，对某位数排序时是用桶来排序的。</p><blockquote><p>基数排序与基数排序与桶排序都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul></blockquote><p><img src="/2021/08/14/Sort/20210813214249.gif" alt="基数排序"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] radixSort(<span class="hljs-keyword">int</span>[] arr)&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//找出最大值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : arr)&#123;<br>        <span class="hljs-keyword">if</span> (max &lt; val)&#123;<br>            max = val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//计算最大值是几位数</span><br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (max / <span class="hljs-number">10</span> &gt; <span class="hljs-number">0</span>)&#123;<br>        num++;<br>        max /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">//创建10个桶</span><br>    ArrayList&lt;LinkedList&lt;Integer&gt;&gt; bucketList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//初始化桶</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        bucketList.add(<span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;());<br>    &#125;<br>    <span class="hljs-comment">//进行每一趟的排序，从个位数开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-comment">//数组中元素的每一位</span><br>            <span class="hljs-keyword">int</span> radix = (arr[j] / (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>, i - <span class="hljs-number">1</span>)) % <span class="hljs-number">10</span>;<br>            <span class="hljs-comment">//放进对应的桶里</span><br>            bucketList.get(radix).add(arr[j]);<br>        &#125;<br>        <span class="hljs-comment">//合并放回原数组</span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>            <span class="hljs-keyword">for</span> (Integer val : bucketList.get(j)) &#123;<br>                arr[index++] = val;<br>            &#125;<br>            <span class="hljs-comment">//取出合并后清空桶的数据</span><br>            bucketList.get(j).clear();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>适合顺序结构的是：插入排序、希尔排序、快速排序、堆排序</li><li>适合链式结构的是：直接插入排序、归并排序</li><li>不稳定：快速排序、希尔排序、堆排序/选择排序</li><li>稳定：冒泡排序、插入排序、归并排序、基数排序</li></ul><ul><li>n较大时：<ol><li>分布随机，稳定性不做要求，则采用<strong>快速排序</strong></li><li>内存允许，要求排序稳定，则采用<strong>归并排序</strong></li><li>可能出现正序或倒序，稳定性不做要求，则采用<strong>堆排序</strong>或<strong>归并排序</strong></li></ol></li><li>n较小时：<ol><li>基本有序，要求稳定，则采用<strong>插入排序</strong></li><li>分布随机，稳定性不做要求，则采用<strong>选择排序</strong></li></ol></li></ul><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://www.cnblogs.com/onepixel/p/7674659.html">十大经典排序算法（动图演示）- 博客园</a></li><li><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序算法 - 菜鸟教程</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">图解排序算法(二)之希尔排序 - dreamcatcher-cx - 博客园</a></li><li><a href="https://www.cnblogs.com/itsharehome/p/11058010.html">十大经典排序算法 - 冰狼爱魔 - 博客园</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">图解排序算法(四)之归并排序 - dreamcatcher-cx - 博客园</a></li><li><a href="https://blog.csdn.net/donghuabianc/article/details/105252344">动画：一篇文章快速学会计数排序_donghuabianc的博客 - CSDN</a></li></ol><h1 id="参考：-1"><a href="#参考：-1" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://www.cnblogs.com/onepixel/p/7674659.html">十大经典排序算法（动图演示）- 博客园</a></li><li><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序算法 - 菜鸟教程</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">图解排序算法(二)之希尔排序 - dreamcatcher-cx - 博客园</a></li><li><a href="https://www.cnblogs.com/itsharehome/p/11058010.html">十大经典排序算法 - 冰狼爱魔 - 博客园</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">图解排序算法(四)之归并排序 - dreamcatcher-cx - 博客园</a></li><li><a href="https://blog.csdn.net/donghuabianc/article/details/105252344">动画：一篇文章快速学会计数排序_donghuabianc的博客 - CSDN</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2021/08/12/Heap/"/>
    <url>/2021/08/12/Heap/</url>
    
    <content type="html"><![CDATA[<h1 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h1><p>大根堆就是根节点是整颗树的最大值（根节点大于等于左右子树的最大值），对于他的任意子树，根节点也是最大值。小根堆则相反</p><p><img src="/2021/08/12/Heap/20210812162138.png" alt="大根堆与小根堆"></p><p>要求：</p><ul><li><p>根节点的关键字既大于或等于左子树的关键字值，又大于或等于右子树的关键字值</p></li><li><p>为<strong>完全二叉树</strong>，所以可以用数组来存储。<strong>i</strong>结点的父结点下标就为 <code>(i – 1) / 2</code></p><p>它的左右子结点下标分别为<code>2 * i + 1</code>和<code>2 * i + 2</code></p></li></ul><h1 id="创建大根堆"><a href="#创建大根堆" class="headerlink" title="创建大根堆"></a>创建大根堆</h1><p>比如一棵树有 N 个元素，存放在数组里分别对应<code>0 ~ N-1</code>，假设数组中从0到 i - 1 位置的元素是一个大根堆，然后把第 i 个位置的元素插入大根堆里，构造一个新的大根堆，就需要从第i个位置的元素开始，依次看它的父节点是否小于它，如果小于就进行交换，直到它的父节点不小于它，或者到了该大根堆的最顶端的根节点。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建大根堆</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>    <span class="hljs-comment">//当前节点是否大于父节点</span><br>    <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])&#123;<br>        swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>        index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 交换两个不同位置的元素</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">43</span>,-<span class="hljs-number">54</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">13</span>,<span class="hljs-number">10</span>,<span class="hljs-number">36</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        heapInsert(arr, i);<br>    &#125;<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="调整大根堆"><a href="#调整大根堆" class="headerlink" title="调整大根堆"></a>调整大根堆</h1><p>设数组中对应的大根堆的长度为 heapSize 。当数组中下标为 index 的元素的值发生了变化，就要对这个堆进行调整，保证它还是大根堆。</p><p>具体过程是：将 index 对应的元素和它的左右子节点的值进行比较，如果比它小的话，就把 index 对应的元素和它的左右子节点中最大的值进行交换，交换后对他的子节点也执行这个过程。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调整堆</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapAdjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> heapSize)</span></span>&#123;<br>    <span class="hljs-comment">//左子节点</span><br>    <span class="hljs-keyword">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//右子节点</span><br>    <span class="hljs-keyword">int</span> right = left + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; heapSize)&#123;<br>        <span class="hljs-comment">//求左右子节点的最大值索引</span><br>        <span class="hljs-keyword">int</span> max = right &lt; heapSize &amp;&amp; arr[right] &gt; arr[left] ? right : left;<br>        <span class="hljs-comment">//与父节点比较判断是否交换</span><br>        max = arr[max] &gt; arr[index] ? max : index;<br>        <span class="hljs-keyword">if</span> (max == index)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        swap(arr, max, index);<br>        index = max;<br>        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>利用<strong>创建大根堆</strong>和<strong>调整大根堆</strong>来进行排序。</p><p>创建完大根堆以后，每一次都把<strong>堆顶</strong>的元素和<strong>堆的最后一个</strong>元素进行交换，并且把堆的长度<strong>heapSize</strong>减小1，然后对新的堆进行调整，重新调整为大根堆，然后再取堆顶的元素和堆的最后一个节点进行交换，大根堆的长度<strong>heapSize</strong>减小1，然后再调整，重复这个过程，直到堆里面剩余的元素个数为1。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 堆排序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-comment">//判断数组是否为空或是否长度为1</span><br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//创建大根堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        heapInsert(arr, i);<br>    &#125;<br>    <span class="hljs-keyword">int</span> size = arr.length;<br>    <span class="hljs-comment">//交换堆顶和堆的最后一个元素，并把堆的长度减1</span><br>    swap(arr, <span class="hljs-number">0</span>, --size);<br>    <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//调整堆</span><br>        heapAdjust(arr, <span class="hljs-number">0</span>, size);<br>        <span class="hljs-comment">//交换堆顶和堆的最后一个元素，并把堆的长度减1</span><br>        swap(arr, <span class="hljs-number">0</span>, --size);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序执行结果：</p><p><img src="/2021/08/12/Heap/20210812171543.png" alt="结果图"></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof">leetcode剑指offer第40题</a></p><p><img src="/2021/08/12/Heap/20210812180206.png" alt="题目"></p><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/zui-xiao-de-kge-shu-by-leetcode-solution/">参考答案</a></p><p>用一个大根堆实时维护数组的前 k 小值。首先将前 k 个数插入大根堆中，随后从第 k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 堆        O(nlogk)   O(k)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> : int[]</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr : 输入数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k : 数值k</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> AoCan</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/8/11 16:27</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getLeastNumbers2(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)&#123;<br>    <span class="hljs-keyword">int</span>[] vec = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>    <span class="hljs-comment">// 排除 0 的情况</span><br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> vec;<br>    &#125;<br>    <span class="hljs-comment">//num1是待插元素，num2是最后一个非叶子节点，当compare()返回的值&lt;0时入队，&gt;0时不入队</span><br>    PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((num1, num2) -&gt; num2 - num1);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>        queue.offer(arr[i]);<br>    &#125;<br>    <span class="hljs-comment">//第k+1个数开始入队</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; arr.length; ++i) &#123;<br>        <span class="hljs-comment">//如果遍历到的元素小于堆顶元素则将堆顶的元素弹出，并插入遍历到的元素</span><br>        <span class="hljs-keyword">if</span> (queue.peek() &gt; arr[i]) &#123;<br>            queue.poll();<br>            queue.offer(arr[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//将大根堆的元素存入数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>        vec[i] = queue.poll();<br>    &#125;<br>    <span class="hljs-keyword">return</span> vec;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="PriorityQueue优先级队列"><a href="#PriorityQueue优先级队列" class="headerlink" title="PriorityQueue优先级队列"></a>PriorityQueue优先级队列</h2><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;()&#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer num1, Integer num2)</span></span>&#123;  <br> <span class="hljs-keyword">return</span> num2 - num1;   <span class="hljs-comment">// 最大优先队列，return num2.compareTo(num1);</span><br>                            <span class="hljs-comment">// 最小优先队列，return num1.compareTo(num2);</span><br> &#125;<br>&#125;);<br><br><span class="hljs-comment">//lambda表达式</span><br>PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((num1, num2) -&gt; num2 - num1);<br></code></pre></div></td></tr></table></figure><p>Compare含义：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// num1是待插元素，num2是最后一个非叶子节点</span><br>compare(Integer num1, Integer num2)<br></code></pre></div></td></tr></table></figure><h3 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h3><p><strong>TopK </strong> 问题：</p><ul><li><p>数组中最大的 K 个<br>构造小根堆，堆顶为最小数，不断入队，当队列数大于 K 时，将最小的堆顶弹出，最后剩下的就是 K 个最大数</p></li><li><p>数组中最小的 K 个<br>构造最大堆，堆顶为最大数，不断入队，当队列数小于 K 时，将最大的堆顶弹出，最后剩下的就是 K 个最小数</p></li></ul><p>该题就是第二种</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%A0%86/4633143?fromtitle=%E5%A4%A7%E6%A0%B9%E5%A0%86&amp;fromid=4633235&amp;fr=aladdin">百度百科</a></li><li><a href="https://blog.csdn.net/dream_follower/article/details/105202811">图解大根堆的堆排序</a></li><li><a href="https://blog.csdn.net/zhizhengguan/article/details/106826270">如何构建一个大根堆</a></li><li><a href="https://blog.csdn.net/l577217/article/details/80516654">堆排序</a></li><li><a href="https://www.cnblogs.com/wangchaowei/p/8288216.html">数据结构—堆、大根堆、小根堆</a></li><li><a href="https://www.cnblogs.com/wangchaowei/p/8288216.html">PriorityQueue优先级队列用法</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>大根堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习</title>
    <link href="/2021/06/08/Redis/"/>
    <url>/2021/06/08/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="NoSQL概述"><a href="#NoSQL概述" class="headerlink" title="NoSQL概述"></a>NoSQL概述</h1><h2 id="为什么要用NoSQL"><a href="#为什么要用NoSQL" class="headerlink" title="为什么要用NoSQL"></a>为什么要用NoSQL</h2><p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等爆发式的增长</p><p>这时候就需要使用NoSQL数据库</p><blockquote><p>1、单机MySQL的年代</p></blockquote><p><img src="/2021/06/08/Redis/20210425101847.png" alt="image-20210425101847275"></p><p>90年代，一个基本的网站访问量一般不会太大，单个数据库完全足够，那个时候，更多的是使用静态网页html，服务器没有太大压力</p><p>瓶颈</p><p>1、数据量如果太大，一个机器放不下</p><p>2、数据的索引（B + Tree），一个机器内存放不下</p><p>3、访问量（读写混合），一个服务器承受不了</p><p>出现以上情况就需要晋级</p><blockquote><p>2、Memcached（缓存）+ MySQL + 垂直拆分</p></blockquote><p>网站80%的情况都是在读，每次查询数据库十分麻烦，因此使用缓存来保证效率</p><p>发展过程：优化数据结构和索引 —&gt; 文件缓存（IO）—&gt; Memcached</p><p><img src="/2021/06/08/Redis/20210425101916.png" alt="image-20210425101916307"></p><h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h2><blockquote><p>NoSQL</p></blockquote><p>NoSQL = Not Only SQL （不仅仅是SQL）</p><p>关系型数据库： 表格，行，列（POI）</p><p>泛指非关系型数据库，随着web2.0互联网的诞生！ 传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区！ 暴露出很多难以克服的问题，NoSQL在当今大数据的环境下发展十分迅速，Redis是发展最快的，而且是是当下必须要掌握的</p><p>很多数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式，不需要多余的操作就可以横向扩展的！Map<String, object>使用键值对来控制！</String,></p><blockquote><p>NoSQL特点</p></blockquote><p>解耦！</p><p>1、方便扩展（数据之间没有关系，很好扩展）</p><p>2、大数据高性能（Redis一秒写8万次，读取11万，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高）</p><p>3、数据类型是多样型的（不需要事先设计数据库！随取随用！如果是数据量十分大的表，很多人就无法设计了）</p><p>4、传统RDBMS和NoSQL</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">传统的RDBMS<br><span class="hljs-bullet">- </span>结构化组织<br><span class="hljs-bullet">- </span>SQL<br><span class="hljs-bullet">- </span>数据和关系都存在单独的表中 row col<br><span class="hljs-bullet">- </span>操作语言，数据定义语言<br><span class="hljs-bullet">- </span>严格的一致性<br><span class="hljs-bullet">- </span>基础的事务<br><span class="hljs-bullet">- </span>... ... <br></code></pre></div></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">Nosql<br><span class="hljs-bullet">- </span>不仅仅是数据<br><span class="hljs-bullet">- </span>没有固定的查询语言<br><span class="hljs-bullet">- </span>键值对存储，列存储，文档存储，图形数据库（社交关系）<br><span class="hljs-bullet">- </span>最终一致性<br><span class="hljs-bullet">- </span>CAP定理和BASE<br><span class="hljs-bullet">- </span>高性能，高可用，高可扩展<br><span class="hljs-bullet">- </span>... ... <br></code></pre></div></td></tr></table></figure><blockquote><p>了解：3V + 3高</p></blockquote><p>大数据时代的3V：主要是描述问题的</p><p>​    1、海量的Volume</p><p>​    2、多样的Variety</p><p>​    3、实时Velocity</p><p>大数据时代的3高：主要是对程序的要求</p><p>​    1、高并发</p><p>​    2、高可扩（随时水平拆分，机器不够了，可以扩展机器来）</p><p>​    3、高性能 （保证用户体验和性能）</p><p>真正的实践：NoSQL + RDBMS一起使用</p><p>技术没有高低之分，看如何使用！</p><h2 id="阿里演进分析"><a href="#阿里演进分析" class="headerlink" title="阿里演进分析"></a>阿里演进分析</h2><p><img src="/2021/06/08/Redis/20210425101948.png" alt="image-20210425101948320"></p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># 1、商品的基本信息</span><br>名称、价格、商家信息；<br>关系型数据库姐可以解决了！ MySQL/Oracle（淘宝早年就去IOE了）<br>淘宝内部的MySQL不是大家用的MySQL<br><br><span class="hljs-meta"># 2、商品的描述、评论（文字比较多）</span><br>文档型数据库中，MongoDB<br><br><span class="hljs-meta"># 3、图片</span><br>分布式文件系统 FastDFS<br>- 淘宝自己的TFS<br>- Google的 GFS<br>- Hadoop HDFS<br>- 阿里云的oss<br><br><span class="hljs-meta"># 4、商品的关键字（搜索）</span><br>- 搜索引擎 solr elasticsearch<br>- ISearch： 多隆<br><br><span class="hljs-meta"># 5、商品热门的波段信息</span><br>- 内存数据库<br>- RedisTair、Memache<br><br><span class="hljs-meta"># 6、商品的交易，外部的支付接口</span><br>- 三方应用<br></code></pre></div></td></tr></table></figure><p>大型互联网应用的问题：</p><ul><li>数据类型太多了</li><li>数据源繁多，经常重构</li><li>数据要改造，大面积改造</li></ul><p>解决问题：</p><p><img src="/2021/06/08/Redis/20210425105321.png" alt="image-20210425105321106"></p><p>以上都是NoSQL的入门概述</p><h2 id="NoSQL的四大分类"><a href="#NoSQL的四大分类" class="headerlink" title="NoSQL的四大分类"></a>NoSQL的四大分类</h2><p><strong>KV键值对：</strong></p><ul><li>新浪：<strong>Redis</strong></li><li>美团：Redis + Tair</li><li>阿里、百度：Redis + memcache</li></ul><p><strong>文档型数据库（bson格式和json一样）</strong></p><ul><li><strong>MongoDB</strong>（一般必须掌握）<ul><li>MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档</li><li>MongoDB是一个介于关系型数据库和非关系型数据库中间的产品！MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的</li></ul></li><li>ConthDB</li></ul><p><strong>列存储数据库</strong></p><ul><li><strong>HBase</strong></li><li>分布式文件系统</li></ul><p><strong>图关系型数据库</strong></p><p><img src="/2021/06/08/Redis/20210608200625.png" alt="图关系型数据库"></p><ul><li>他不是存图形，放的是关系，比如：朋友圈社交网络，广告推荐</li><li><strong>Neo4j</strong>，InfoGrid</li></ul><blockquote><p>四者对比！</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">Examples举例</th><th style="text-align:center">典型应用场景</th><th style="text-align:center">数据模型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td style="text-align:center">键值（key-value）</td><td style="text-align:center">Tokyo Cabinet/Tyrant,Redis, Voldemort,Oracle BDB</td><td style="text-align:center">内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。[3]</td><td style="text-align:center">Key指向value的键值对，通常用hash table来实现[3]</td><td>查找速度快</td><td>数据无结构化，通常只被当作字符串或者二进制数据</td></tr><tr><td style="text-align:center">列存储数据库</td><td style="text-align:center">Cassandra, HBase,Riak</td><td style="text-align:center">分布式的文件系统</td><td style="text-align:center">以列簇式存储，将同一列数据存在一起</td><td>查找速度快，可扩展性强，更容易进行分布式扩展</td><td>功能相对局限</td></tr><tr><td style="text-align:center">文档型数据库</td><td style="text-align:center">CouchDB,MongoDb</td><td style="text-align:center">Web应用(与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容)</td><td style="text-align:center">Key-Value对应的键值对Value为结构化数据</td><td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要先定义表结构</td><td>查询性能不高，而且缺乏统一的查询语法</td></tr><tr><td style="text-align:center">图形(Graph)数据库</td><td style="text-align:center">Neo4J, InfoGrid, lnfinite Graph</td><td style="text-align:center">社交网络，推荐系统等。专注于构建关系图谱</td><td style="text-align:center">图结构</td><td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td><td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结果后不太好做分布式的集群方案</td></tr></tbody></table></div><h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Redis是什么？</p></blockquote><p>Redis（Remote Dictionary Server），即远程字典服务</p><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</p><p><img src="/2021/06/08/Redis/20210425115126.png" alt="image-20210425115119886"></p><p>redis会周期性的把更新的数据写入磁盘或把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步</p><p>免费和开源，是当下最热门的NoSQL技术之一，也被称为结构化数据库</p><blockquote><p>Redis用途</p></blockquote><p>1、内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）</p><p>2、效率高，可以用于高速缓存</p><p>3、发布订阅系统</p><p>4、地图信息分析</p><p>5、计时器、计数器（浏览量）</p><p>6、 … …</p><blockquote><p>特性</p></blockquote><p>1、多样的数据类型</p><p>2、持久化</p><p>3、集群</p><p>4、事务</p><p>… …</p><blockquote><p>准备</p></blockquote><p>官网：<a href="https://redis.io/">https://redis.io/</a></p><p><img src="/2021/06/08/Redis/20210425115654.png" alt="image-20210425115654201"></p><p><strong>Redis推荐都是在Linux服务器上搭建的</strong></p><h2 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h2><p>1、下载安装包：<a href="https://github.com/dmajkic/redis/releases">https://github.com/dmajkic/redis/releases</a></p><p>2、下载完毕得到压缩包</p><p><img src="/2021/06/08/Redis/20210425120848.png" alt="image-20210425120848964"></p><p>3、解压到自己电脑上的环境目录下</p><p>4、开启Redis，双击运行服务即可</p><p><img src="/2021/06/08/Redis/20210425121430.png" alt="image-20210425121430781"></p><p>5、使用redis客户端来连接redis</p><p><img src="/2021/06/08/Redis/20210425121843.png" alt="image-20210425121842974"></p><p>windows下使用确实简单，但是redis推荐使用Linux开发使用</p><p><img src="/2021/06/08/Redis/20210425122145.png" alt="image-20210425122145780"></p><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><p>1、下载安装包    <strong>redis-6.2.2.tar.gz</strong></p><p>2、解压安装包    程序/opt</p><p><img src="/2021/06/08/Redis/20210427095749.png" alt="image-20210427095741964"></p><p>3、进入解压后的文件可以看到redis的配置文件</p><p><img src="/2021/06/08/Redis/20210427095900.png" alt="image-20210427095900836"></p><p>4、基本的环境安装</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">yum install gcc-c++<br><br>make<br><br>make install<br></code></pre></div></td></tr></table></figure><p><img src="/2021/06/08/Redis/20210427100316.png" alt="image-20210427100316774"></p><p><img src="/2021/06/08/Redis/20210427100346.png" alt="image-20210427100346434"></p><p>5、redis默认安装路径    usr/local/bin</p><p><img src="/2021/06/08/Redis/20210427100537.png" alt="image-20210427100537691"></p><p>6、将redis配置文件，复制到我们的当前目录下</p><p><img src="/2021/06/08/Redis/20210427100837.png" alt="image-20210427100837447"></p><p>7、redis默认不是后台启动的，修改配置文件</p><p>​    改为yes</p><p><img src="/2021/06/08/Redis/20210427101016.png" alt="image-20210427101016158"></p><p>8、启动redis服务</p><p><img src="/2021/06/08/Redis/20210427101429.png" alt="image-20210427101429099"></p><p>9、使用redis-cli进行连接测试</p><p><img src="/2021/06/08/Redis/20210427103808.png" alt="image-20210427103808221"></p><p>10、查看redis进程是否开启</p><p><img src="/2021/06/08/Redis/20210427104116.png" alt="image-20210427104116052"></p><p>11、如何关闭redis服务    shutdown</p><p><img src="/2021/06/08/Redis/20210427104213.png" alt="image-20210427104213680"></p><p>12、再次查看进程是否存在</p><p><img src="/2021/06/08/Redis/20210427104310.png" alt="image-20210427104310636"></p><h2 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h2><p><strong>redis-benchmark</strong> 是一个压力测试工具</p><p>官方自带的性能测试工具</p><p><img src="/2021/06/08/Redis/20210427104647.png" alt="image-20210427104647012"></p><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 测试：100个并发连接100000个请求</span><br>redis-benchmark -h localhost -p 6379 -c 100 -n 100000<br></code></pre></div></td></tr></table></figure><p><img src="/2021/06/08/Redis/20210427110413.png" alt="image-20210427110413714"></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>redis默认有16个数据库</p><p><img src="/2021/06/08/Redis/20210427110726.png" alt="image-20210427110726503"></p><p>默认使用第0个</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; select 2<span class="hljs-comment">#切换数据库</span><br>OK<br>127.0.0.1:6379[2]&gt; DBSIZE<span class="hljs-comment">#查看DB大小</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379[2]&gt; keys *<br>(empty array)<br>127.0.0.1:6379[2]&gt; <span class="hljs-built_in">set</span> name aocan<br>OK<br>127.0.0.1:6379[2]&gt; get name<br><span class="hljs-string">&quot;aocan&quot;</span><br>127.0.0.1:6379[2]&gt; keys *<span class="hljs-comment">#查看数据库所有的key</span><br>1) <span class="hljs-string">&quot;name&quot;</span><br>127.0.0.1:6379[2]&gt; flushall<span class="hljs-comment">#清空所有数据库</span><br>OK<br>127.0.0.1:6379[2]&gt; flushdb<span class="hljs-comment">#清空当前数据库</span><br>OK<br></code></pre></div></td></tr></table></figure><blockquote><p>Redis是单线程的</p></blockquote><p>Redis是很快的，Redis基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了，所以就使用单线程了</p><p>Redis是C语言写的，官方提供的数据为100000+的QPS，完全不比同样是使用key-value的Memcache差</p><p><strong>Redis为什么单线程还这么快</strong></p><p>1、误区1：高性能的服务器一定是多线程的</p><p>2、误区2：多线程（CPU上下文会切换）一定比单线程效率高</p><p>核心：redis是将所有的数据全部放在内存中的，所以使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的 ，在内存情况下，这个就是最佳方案</p><h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><blockquote><p>官网文档</p></blockquote><p><img src="/2021/06/08/Redis/20210427114027.png" alt="image-20210427114027257"></p><p>Redis是一个开源(BSD许可)的，两存中的数据结构存储系统，它可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>。它支持多种类型的数据结构，如字符串 ( strings )，散列 ( hashes )，列表( lists )，集合( sets)，有序集合( sorted sets ）与范围查询，bitmaps ， hyperloglogs和地理空间(geospatial ）索引半径查询。Redis内置了复制( replication )，LUA脚本(LuaRedis是一个开源(BSD许可)的，两存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。它支持多种类型的数据结构，如字符串 ( strings )，散列 ( hashes )，列表( lists )，集合( sets)，有序集合( sorted sets ）与范围查询，bitmaps ，hyperloglogs和地理空间(geospatial）索引半径查询。Redis内置了复制( replication )，LUA脚本(Luascripting )，LRU驱动事件(LRU eviction )，事务 ( transactions）和不同级别的磁盘持久化 ( persistence)，并通过Redis哨兵( Sentinel )和自动分区( Cluster)提供高可用性( high availability )。</p><h2 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; keys *<br>(empty array)<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name aocan<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;name&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> age 1<br>OK<br>127.0.0.1:6379&gt; EXPIRE name 10<span class="hljs-comment">#设置key的过期时间</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; ttl name<span class="hljs-comment">#查看当前key的剩余时间，单位是秒</span><br>(<span class="hljs-built_in">integer</span>) -2<br>127.0.0.1:6379&gt; get name<br>(nil)<br>127.0.0.1:6379&gt; EXISTS name<span class="hljs-comment">#判断当前key是否存在</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; move age 1<span class="hljs-comment">#移动当前key</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name aocan<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;name&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">type</span> name<span class="hljs-comment">#查看当前key的类型</span><br>string<br></code></pre></div></td></tr></table></figure><p>官网可以查命令</p><p><img src="/2021/06/08/Redis/20210427120112.png" alt="image-20210427120112336"></p><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#######################################################################</span><br>[root@acacac bin]<span class="hljs-comment"># redis-server acconfig/redis.conf</span><br>[root@acacac bin]<span class="hljs-comment"># redis-cli -p 6379</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key1 v1<span class="hljs-comment">#设置值</span><br>OK<br>127.0.0.1:6379&gt; get key1<span class="hljs-comment">#获得值</span><br><span class="hljs-string">&quot;v1&quot;</span><br>127.0.0.1:6379&gt; keys *<span class="hljs-comment">#获得所有的key</span><br>1) <span class="hljs-string">&quot;key1&quot;</span><br>127.0.0.1:6379&gt; EXISTS key1<span class="hljs-comment">#判断key是否存在</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; exists key1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; append key1 <span class="hljs-string">&quot;hello&quot;</span><span class="hljs-comment">#追加字符串，如果当前key不存在，就相当于set key</span><br>(<span class="hljs-built_in">integer</span>) 7<br>127.0.0.1:6379&gt; get key1<br><span class="hljs-string">&quot;v1hello&quot;</span><br>127.0.0.1:6379&gt; strlen key1<span class="hljs-comment">#获取字符串的长度</span><br>(<span class="hljs-built_in">integer</span>) 7<br>127.0.0.1:6379&gt; <br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># i++</span><br><span class="hljs-comment"># 步长 i+=</span><br>步长<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> views 0<br>OK<br>127.0.0.1:6379&gt; get views<br><span class="hljs-string">&quot;0&quot;</span><br>127.0.0.1:6379&gt; incr views<span class="hljs-comment">#自增1</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; incr views<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; get views<br><span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; <br>127.0.0.1:6379&gt; decr views<span class="hljs-comment">#自减1</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; decr views<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; incrby views 10<span class="hljs-comment">#设置步长，指定增量</span><br>(<span class="hljs-built_in">integer</span>) 10<br>127.0.0.1:6379&gt; decrby views 5<span class="hljs-comment">#设置步长，指定减量</span><br>(<span class="hljs-built_in">integer</span>) 5<br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># 字符串范围 range</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key1 <span class="hljs-string">&quot;hello&quot;</span><span class="hljs-comment">#设置key1的值</span><br>OK<br>127.0.0.1:6379&gt; get key1<br><span class="hljs-string">&quot;hello&quot;</span><br>127.0.0.1:6379&gt; getrange key1 0 3<span class="hljs-comment">#截取字符串 [0, 3]</span><br><span class="hljs-string">&quot;hell&quot;</span><br>127.0.0.1:6379&gt; getrange key1 0 -1<span class="hljs-comment">#获取全部字符串 和 get key是一样的</span><br><span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-comment"># 替换</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key2 absdds<br>OK<br>127.0.0.1:6379&gt; get key2<br><span class="hljs-string">&quot;absdds&quot;</span><br>127.0.0.1:6379&gt; setrange key2 1 xx<span class="hljs-comment">#替换指定位置开始的字符串</span><br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; get key2<br><span class="hljs-string">&quot;axxdds&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># setex (set with expire)#设置过期时间</span><br><span class="hljs-comment"># setnx (set if not exist)#不存在再设置（再分布式锁中常使用）</span><br>127.0.0.1:6379&gt; setex key3 30 <span class="hljs-string">&quot;hello&quot;</span><span class="hljs-comment">#设置key3的值为hello。，30秒后过期</span><br>OK<br>127.0.0.1:6379&gt; ttl key3<br>(<span class="hljs-built_in">integer</span>) 25<br>127.0.0.1:6379&gt; ttl key3<br>(<span class="hljs-built_in">integer</span>) 23<br>127.0.0.1:6379&gt; get key3<br><span class="hljs-string">&quot;hello&quot;</span><br>127.0.0.1:6379&gt; ttl key3<br>(<span class="hljs-built_in">integer</span>) 7<br>127.0.0.1:6379&gt; ttl key3<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; get key3<br>(nil)<br>127.0.0.1:6379&gt; setnx mykey <span class="hljs-string">&quot;redis&quot;</span><span class="hljs-comment">#如果mykey不存在，创建mykey</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;key2&quot;</span><br>2) <span class="hljs-string">&quot;mykey&quot;</span><br>3) <span class="hljs-string">&quot;key1&quot;</span><br>127.0.0.1:6379&gt; setnx mykey <span class="hljs-string">&quot;MongoDB&quot;</span><span class="hljs-comment">#如果mykey存在，创建失败</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; get mykey<br><span class="hljs-string">&quot;redis&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># mset</span><br><span class="hljs-comment"># mget</span><br>127.0.0.1:6379&gt; keys *<br>(empty array)<br>127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3<span class="hljs-comment">#同时设置多个值</span><br>OK<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;k2&quot;</span><br>2) <span class="hljs-string">&quot;k3&quot;</span><br>3) <span class="hljs-string">&quot;k1&quot;</span><br>127.0.0.1:6379&gt; mget k1 k2 k3<span class="hljs-comment">#同时获取多个值</span><br>1) <span class="hljs-string">&quot;v1&quot;</span><br>2) <span class="hljs-string">&quot;v2&quot;</span><br>3) <span class="hljs-string">&quot;v3&quot;</span><br>127.0.0.1:6379&gt; msetnx k1 v1 k4 v4<span class="hljs-comment">#msetnx是一个原子性操作，要么一起成功要么一起失败</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; get k4<br>(nil)<br><br><span class="hljs-comment"># 对象</span><br><span class="hljs-built_in">set</span> user:1 &#123;name:zhangsan, age:3&#125;<span class="hljs-comment">#设置一个user:1对象 值为json字符串来保存一个对象</span><br><br><span class="hljs-comment">#这里的key是一个巧妙的设计：user:&#123;id&#125;:&#123;filed&#125;</span><br><br>127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 3<br>OK<br>127.0.0.1:6379&gt; mget user:1:name user:1:age<br>1) <span class="hljs-string">&quot;zhangsan&quot;</span><br>2) <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br>getset <span class="hljs-comment"># 先get再set</span><br><br>127.0.0.1:6379&gt; getset db redis<span class="hljs-comment">#如果不存在值，则返回nil</span><br>(nil)<br>127.0.0.1:6379&gt; get db<br><span class="hljs-string">&quot;redis&quot;</span><br>127.0.0.1:6379&gt; getset db mongodb<span class="hljs-comment">#如果存在值，获取原来的值，并设置新的值</span><br><span class="hljs-string">&quot;redis&quot;</span><br>127.0.0.1:6379&gt; get db<br><span class="hljs-string">&quot;mongodb&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>基本的数据类型，列表</p><p><img src="/2021/06/08/Redis/20210602141315.png" alt="List"></p><p>在Redis里面，可以把llist当作栈，队列，阻塞队列</p><p>所有的list命令都是用l开头的，Redis不区分大小写命令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">###########################################################################</span><br>127.0.0.1:6379&gt; lpush list one<span class="hljs-comment">#将一个值或者多个值，插入到列表头部（左）</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lpush list two<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; lpush list three<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; lrange list 0 -1<span class="hljs-comment">#获取list中的值</span><br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>3) <span class="hljs-string">&quot;one&quot;</span><br>127.0.0.1:6379&gt; lrange list 0 1<span class="hljs-comment">#通过区间获取具体的值</span><br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>127.0.0.1:6379&gt; rpush list right<span class="hljs-comment">#将一个值或者多个值，插入到列表尾部（右）</span><br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; lrange list 0 1<br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>3) <span class="hljs-string">&quot;one&quot;</span><br>4) <span class="hljs-string">&quot;right&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># lpop/rpop移除元素</span><br><br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;three&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>3) <span class="hljs-string">&quot;one&quot;</span><br>4) <span class="hljs-string">&quot;right&quot;</span><br>127.0.0.1:6379&gt; lpop list<span class="hljs-comment">#移除list的第一个元素</span><br><span class="hljs-string">&quot;three&quot;</span><br>127.0.0.1:6379&gt; rpop list<span class="hljs-comment">#移除list的最后一个元素</span><br><span class="hljs-string">&quot;right&quot;</span><br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;two&quot;</span><br>2) <span class="hljs-string">&quot;one&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># lindex通过下标获取list中的某一个值</span><br><br>127.0.0.1:6379&gt; lindex list 1<br><span class="hljs-string">&quot;one&quot;</span><br>127.0.0.1:6379&gt; lindex list 0<br><span class="hljs-string">&quot;two&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># llen返回list的长度</span><br><br>127.0.0.1:6379&gt; lpush list one<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lpush list two<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; lpush list three<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; lpush list four<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; llen list<br>(<span class="hljs-built_in">integer</span>) 4<br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># lrem 移除list集合中指定个数的value，精确匹配</span><br><br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;four&quot;</span><br>2) <span class="hljs-string">&quot;four&quot;</span><br>3) <span class="hljs-string">&quot;three&quot;</span><br>4) <span class="hljs-string">&quot;two&quot;</span><br>5) <span class="hljs-string">&quot;one&quot;</span><br>127.0.0.1:6379&gt; lrem list 1 one<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;four&quot;</span><br>2) <span class="hljs-string">&quot;four&quot;</span><br>3) <span class="hljs-string">&quot;three&quot;</span><br>4) <span class="hljs-string">&quot;two&quot;</span><br>127.0.0.1:6379&gt; lpush list four<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; lrem list 2 four<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; lrange list 0 -1<br>1) <span class="hljs-string">&quot;four&quot;</span><br>2) <span class="hljs-string">&quot;three&quot;</span><br>3) <span class="hljs-string">&quot;two&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># ltrim 修剪： list 截断</span><br><br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello&quot;</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello1&quot;</span><br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello2&quot;</span><br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello3&quot;</span><br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; ltrim mylist 1 2<span class="hljs-comment">#通过下标截取指定长度，这个list已经改变了，截断了只剩下截取的元素</span><br>OK<br>127.0.0.1:6379&gt; lrange mylist 0 -1<br>1) <span class="hljs-string">&quot;hello1&quot;</span><br>2) <span class="hljs-string">&quot;hello2&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># rpoplpush移除列表的最后一个元素，并添加到另一个列表</span><br><br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello&quot;</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello1&quot;</span><br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello2&quot;</span><br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello3&quot;</span><br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; rpoplpush mylist myotherlist<br><span class="hljs-string">&quot;hello3&quot;</span><br>127.0.0.1:6379&gt; lrange mylist 0 -1<span class="hljs-comment">#查看原来的列表</span><br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;hello1&quot;</span><br>3) <span class="hljs-string">&quot;hello2&quot;</span><br>127.0.0.1:6379&gt; lrange myotherlist 0 -1<span class="hljs-comment">#查看目标列表</span><br>1) <span class="hljs-string">&quot;hello3&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># lset 将列表中指定下标的值替换为另外一个值，更新操作</span><br><br>127.0.0.1:6379&gt; exists list<span class="hljs-comment"># 判断这个列表是否存在</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; lset list 0 item<span class="hljs-comment">#如果不存在列表我们去更新就会报错</span><br>(error) ERR no such key<br>127.0.0.1:6379&gt; lpush list value<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lrange list 0 0 <br>1) <span class="hljs-string">&quot;value&quot;</span><br>127.0.0.1:6379&gt; lset list 0 item<br>OK<br>127.0.0.1:6379&gt; lrange list 0 0 <br>1) <span class="hljs-string">&quot;item&quot;</span><br>127.0.0.1:6379&gt; lset list 1 item<br>(error) ERR index out of range<br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># linsert 将某个具体的值插入到列表中某个元素的前面或者后面</span><br><br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;hello&quot;</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; rpush mylist <span class="hljs-string">&quot;world&quot;</span><br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; linsert mylist before <span class="hljs-string">&quot;world&quot;</span> <span class="hljs-string">&quot;other&quot;</span><br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; lrange mylist 0 -1<br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;other&quot;</span><br>3) <span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; linsert mylist after world new<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; lrange mylist 0 -1<br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;other&quot;</span><br>3) <span class="hljs-string">&quot;world&quot;</span><br>4) <span class="hljs-string">&quot;new&quot;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>小结</p></blockquote><ul><li>实际上是一个链表，before Node after，left，right都可以插入值</li><li>如果key不存在，创建新的链表</li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，也代表不存在</li><li>在两边插入或者改动值，效率最高。中间元素，相对来说效率会低一点</li></ul><p>消息排队，消息队列 （lpush rpop），栈（lpush，lpop）</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>set中的值是不能重读的</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">###########################################################################</span><br>127.0.0.1:6379&gt; sadd myset hello<span class="hljs-comment">#set集合中添加元素</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset hello2<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset ac<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; smembers myset<span class="hljs-comment">#查看指定set的所有值</span><br>1) <span class="hljs-string">&quot;ac&quot;</span><br>2) <span class="hljs-string">&quot;hello2&quot;</span><br>3) <span class="hljs-string">&quot;hello&quot;</span><br>127.0.0.1:6379&gt; sismember myset hello<span class="hljs-comment">#判断某一个值是不是在set集合中</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sismember myset world<br>(<span class="hljs-built_in">integer</span>) 0<br><br><span class="hljs-comment">###########################################################################</span><br>127.0.0.1:6379&gt; scard myset<span class="hljs-comment">#获取set集合中的元素个数</span><br>(<span class="hljs-built_in">integer</span>) 3<br><br><span class="hljs-comment">###########################################################################</span><br>srem<br><br>127.0.0.1:6379&gt; srem myset hello<span class="hljs-comment">#移除set集合中的指定元素</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; scard myset<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; smembers myset<br>1) <span class="hljs-string">&quot;ac&quot;</span><br>2) <span class="hljs-string">&quot;hello2&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># set 无序不重复</span><br>127.0.0.1:6379&gt; srandmember myset<span class="hljs-comment">#随机输出一个元素</span><br><span class="hljs-string">&quot;ac&quot;</span><br>127.0.0.1:6379&gt; srandmember myset 2<span class="hljs-comment">#随机抽选出指定个数的元素</span><br>1) <span class="hljs-string">&quot;ac&quot;</span><br>2) <span class="hljs-string">&quot;hello2&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># 删除指定的key，随机删除key</span><br><br>127.0.0.1:6379&gt; smembers myset<br>1) <span class="hljs-string">&quot;ac&quot;</span><br>2) <span class="hljs-string">&quot;hello2&quot;</span><br>3) <span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; spop myset<br><span class="hljs-string">&quot;hello2&quot;</span><br>127.0.0.1:6379&gt; spop myset<br><span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; smembers myset<br>1) <span class="hljs-string">&quot;ac&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># 将一个指定的值，移动到另外一个set集合中</span><br><br>127.0.0.1:6379&gt; sadd myset hello<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset world<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset redis<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd myset aaa<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; smembers myset<br>1) <span class="hljs-string">&quot;aaa&quot;</span><br>2) <span class="hljs-string">&quot;hello&quot;</span><br>3) <span class="hljs-string">&quot;redis&quot;</span><br>4) <span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; sadd myset2 hello2<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; smembers myset2<br>1) <span class="hljs-string">&quot;hello2&quot;</span><br>127.0.0.1:6379&gt; smove myset myset2 hello<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; smembers myset<br>1) <span class="hljs-string">&quot;aaa&quot;</span><br>2) <span class="hljs-string">&quot;redis&quot;</span><br>3) <span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; smembers myset2<br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;hello2&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># eg：共同关注（交集）</span><br><span class="hljs-comment">#数字集合类</span><br><span class="hljs-comment"># - 差集 sdiff</span><br><span class="hljs-comment"># - 交集 sinter</span><br><span class="hljs-comment"># - 并集 sunion</span><br><br>127.0.0.1:6379&gt; sadd k1 a<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd k1 b<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd k1 c<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd k2 c<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd k2 d<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd k2 e<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sdiff k1 k2<span class="hljs-comment">#差集</span><br>1) <span class="hljs-string">&quot;b&quot;</span><br>2) <span class="hljs-string">&quot;a&quot;</span><br>127.0.0.1:6379&gt; sinter k1 k2<span class="hljs-comment">#交集</span><br>1) <span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6379&gt; sunion k1 k2<span class="hljs-comment">#并集</span><br>1) <span class="hljs-string">&quot;b&quot;</span><br>2) <span class="hljs-string">&quot;c&quot;</span><br>3) <span class="hljs-string">&quot;a&quot;</span><br>4) <span class="hljs-string">&quot;e&quot;</span><br>5) <span class="hljs-string">&quot;d&quot;</span><br></code></pre></div></td></tr></table></figure><p>微博，A用户将所有关注的人放在一个set集合中，将他的粉丝也放在一个集合中</p><p>共同关注，共同爱好，二度好友（六度分割理论）</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Map集合，key-map 这个值是一个map集合，本质和String类型没有太大区别，还是一个简单的key-value</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; hset myhash field1 redis<span class="hljs-comment">#set一个具体的key-value</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hget myhash field1<span class="hljs-comment">#获取一个字段值</span><br><span class="hljs-string">&quot;redis&quot;</span><br>127.0.0.1:6379&gt; hmset myhash field1 hello field2 world<span class="hljs-comment">#set多个key-value</span><br>OK<br>127.0.0.1:6379&gt; hmget myhash field1 field2<span class="hljs-comment">#获取多个字段值</span><br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; hgetall myhash<span class="hljs-comment">#获取全部的数据</span><br>1) <span class="hljs-string">&quot;field1&quot;</span><br>2) <span class="hljs-string">&quot;hello&quot;</span><br>3) <span class="hljs-string">&quot;field2&quot;</span><br>4) <span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; hdel myhash field1<span class="hljs-comment">#删除hash指定key字段，对应的value值也就消失了</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hgetall myhash<br>1) <span class="hljs-string">&quot;field2&quot;</span><br>2) <span class="hljs-string">&quot;world&quot;</span><br><span class="hljs-comment">###########################################################################</span><br>hlen<br><br>127.0.0.1:6379&gt; hmset myhash field1 hello field2 world<br>OK<br>127.0.0.1:6379&gt; hgetall myhash<br>1) <span class="hljs-string">&quot;field2&quot;</span><br>2) <span class="hljs-string">&quot;world&quot;</span><br>3) <span class="hljs-string">&quot;field1&quot;</span><br>4) <span class="hljs-string">&quot;hello&quot;</span><br>127.0.0.1:6379&gt; hlen myhash<span class="hljs-comment">#获取hash表的字段数量</span><br>(<span class="hljs-built_in">integer</span>) 2<br><br><span class="hljs-comment">###########################################################################</span><br>127.0.0.1:6379&gt; hexists myhash field1<span class="hljs-comment">#判断hash中指定字段是否存在</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hexists myhash field3<br>(<span class="hljs-built_in">integer</span>) 0<br><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># 只获得所有field</span><br><span class="hljs-comment"># 只获得所有value</span><br>127.0.0.1:6379&gt; hkeys myhash<span class="hljs-comment">#只获取所有field</span><br>1) <span class="hljs-string">&quot;field2&quot;</span><br>2) <span class="hljs-string">&quot;field1&quot;</span><br>127.0.0.1:6379&gt; hvals myhash<span class="hljs-comment">#只获取所有value</span><br>1) <span class="hljs-string">&quot;world&quot;</span><br>2) <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure><p>hash变更的数据 user name age，尤其是用户信息之类的，经常变动的信息。Hash更适合对象的存储，String更适合字符串的存储</p><h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><p>在set的基础上，增加了一个值，set k1 v1, zset k1 score1 v1</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; zadd myset 1 one<span class="hljs-comment">#添加一个值</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd myset 2 two 3 three<span class="hljs-comment">#添加多个值</span><br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; zrange myset 0 -1<br>1) <span class="hljs-string">&quot;one&quot;</span><br>2) <span class="hljs-string">&quot;two&quot;</span><br>3) <span class="hljs-string">&quot;three&quot;</span><br><br><span class="hljs-comment">###########################################################################</span><br>排序<br>127.0.0.1:6379&gt; zadd salary 2000 zhangsan<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd salary 2500 lisi<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd salary 200 wangwu<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zrangebyscore salary -inf +inf<span class="hljs-comment">#升序排序 显示全部用户</span><br>1) <span class="hljs-string">&quot;wangwu&quot;</span><br>2) <span class="hljs-string">&quot;zhangsan&quot;</span><br>3) <span class="hljs-string">&quot;lisi&quot;</span><br>127.0.0.1:6379&gt; zrevrangebyscore salary +inf -inf<span class="hljs-comment">#降序排序</span><br>1) <span class="hljs-string">&quot;lisi&quot;</span><br>2) <span class="hljs-string">&quot;zhangsan&quot;</span><br>3) <span class="hljs-string">&quot;wangwu&quot;</span><br>127.0.0.1:6379&gt; zrevrangebyscore salary +inf -inf withscores<br>1) <span class="hljs-string">&quot;lisi&quot;</span><br>2) <span class="hljs-string">&quot;2500&quot;</span><br>3) <span class="hljs-string">&quot;zhangsan&quot;</span><br>4) <span class="hljs-string">&quot;2000&quot;</span><br>5) <span class="hljs-string">&quot;wangwu&quot;</span><br>6) <span class="hljs-string">&quot;200&quot;</span><br><br></code></pre></div></td></tr></table></figure><h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1><h2 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h2><p>…</p><h2 id="hyperloglog基数统计"><a href="#hyperloglog基数统计" class="headerlink" title="hyperloglog基数统计"></a>hyperloglog基数统计</h2><p>基数（不重复的元素个数）</p><p>优点：占用的内存是固定的，2^64不同元素的基数，只需要12KB的内存</p><p><strong>网页的UV （一个人访问一个网站多次，但是还是算作一个人）</strong></p><p>传统方式：set保存用户的id，然后就可以统计set中的元素数量来作为标准判断，这个方式如果保存大量的用户id，就会比较麻烦，我们的目的是为了计数，而不是保存用户id</p><p>0.81%错误率</p><p>…</p><h2 id="bitmaps位图"><a href="#bitmaps位图" class="headerlink" title="bitmaps位图"></a>bitmaps位图</h2><blockquote><p>位存储</p></blockquote><p>统计用户信息，活跃，不活跃     登录，未登录     打卡</p><p>两个状态的，都可以使用Bitmaps</p><p>Bitmaps位图，数据结构，都是操作二进制位来进行记录，就只有0和1两个状态</p><p>…</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis事务本质：一组命令的集合，一个事务中所有的命令会被序列化，在事务执行过程中，会按照顺序执行</p><p>一次性、顺序性、排他性</p><p>==Redis事务没有隔离级别的概念==</p><p>所有的命令在事务中，并没有直接被执行，只有发起执行命令的时候才会执行</p><p>==Redis单条命令是保证原子性的，但是事务不保证原子性==</p><p>redis事务：</p><ul><li>开启事务（multi）</li><li>命令入队（）</li><li>执行事务（exec）</li></ul><blockquote><p>正常执行事务</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<span class="hljs-comment">#开启事务</span><br>OK<br><span class="hljs-comment"># 命令入队</span><br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k1 v1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k2 v2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; get k2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k3 v3<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span><span class="hljs-comment">#执行事务</span><br>1) OK<br>2) OK<br>3) <span class="hljs-string">&quot;v2&quot;</span><br>4) OK<br></code></pre></div></td></tr></table></figure><blockquote><p>放弃事务</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<span class="hljs-comment">#开启事务</span><br>OK<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k1 v1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k2 v2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k4 v4<br>QUEUED<br>127.0.0.1:6379(TX)&gt; discard<span class="hljs-comment">#取消事务</span><br>OK<br>127.0.0.1:6379&gt; get k4<span class="hljs-comment">#事务队列中的命令都不会被执行</span><br>(nil)<br></code></pre></div></td></tr></table></figure><blockquote><p>编译型异常（代码有问题，命令有错），事务中所有的命令都不会被执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k1 v1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k2 v2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k3 v3<br>QUEUED<br>127.0.0.1:6379(TX)&gt; getset k3<span class="hljs-comment">#错误的命令</span><br>(error) ERR wrong number of arguments <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;getset&#x27;</span> <span class="hljs-built_in">command</span><br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k4 v4<br>QUEUED <br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k5 v5<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span><span class="hljs-comment">#执行事务报错</span><br>(error) EXECABORT Transaction discarded because of previous errors.<br>127.0.0.1:6379&gt; get k5<span class="hljs-comment">#所有的命令都不会被执行</span><br>(nil)<br></code></pre></div></td></tr></table></figure><blockquote><p>运行时异常（1/0），如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令会抛出异常</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; incr k1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> v2 k2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k3 v3<br>QUEUED<br>127.0.0.1:6379(TX)&gt; get k3<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span><br>1) (error) ERR value is not an <span class="hljs-built_in">integer</span> or out of range<span class="hljs-comment">#虽然第一条命令报错了，但是依旧正常执行成功了</span><br>2) OK<br>3) OK<br>4) <span class="hljs-string">&quot;v3&quot;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>监控    Watch</p></blockquote><p><strong>悲观锁：</strong></p><ul><li>很悲观，认为什么时候都会出问题，无论做什么都会加锁</li></ul><p><strong>乐观锁：</strong></p><ul><li>很乐观，认为什么时候都不会出问题，所以不会上锁，更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><blockquote><p> Redis监视测试</p></blockquote><p>正常执行成功</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> money 100<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> out 0<br>OK<br>127.0.0.1:6379&gt; watch money <span class="hljs-comment">#监视money对象</span><br>OK<br>127.0.0.1:6379&gt; multi<span class="hljs-comment">#事务正常结束，数据期间没有发生变动，这个时候就正常执行成功</span><br>OK<br>127.0.0.1:6379(TX)&gt; decrby money 20<br>QUEUED<br>127.0.0.1:6379(TX)&gt; incrby out 20<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span><br>1) (<span class="hljs-built_in">integer</span>) 80<br>2) (<span class="hljs-built_in">integer</span>) 20<br></code></pre></div></td></tr></table></figure><p>测试多线程修改值，使用watch当作redis的乐观锁操作</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; watch money<span class="hljs-comment">#监视money</span><br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; decrby money 10<br>QUEUED<br>127.0.0.1:6379(TX)&gt; incrby money 10<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span><span class="hljs-comment">#执行之前，另外一个线程修改了money的值，导致事务执行失败</span><br>(nil)<br></code></pre></div></td></tr></table></figure><p>如果修改失败，获取最新的值就好</p><p><img src="/2021/06/08/Redis/20210602175313.png" alt="Redis执行乐观锁操作"></p><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>使用Java来操作Redis</p><blockquote><p>Jedis是Redis官方推荐的java连接开发工具，使用Java操作Redis中间件</p><p>测试</p></blockquote><ol><li>导入对应的依赖</li><li>编码测试<ul><li>连接数据库</li><li>操作命令</li><li>断开连接</li></ul></li></ol><h2 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h2><p>String</p><p>List</p><p>Set</p><p>Hash</p><p>ZSet</p><h1 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h1><p>启动的时候，通过配置文件启动</p><blockquote><p>单位</p></blockquote><p><img src="/2021/06/08/Redis/20210608091709.png" alt="单位"></p><ol><li>配置文件unit单位对大小写不敏感</li></ol><blockquote><p>包含</p></blockquote><p><img src="/2021/06/08/Redis/20210608091913.png" alt="包含"></p><blockquote><p>网络</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> 127.0.0.1 -::1<span class="hljs-comment">#绑定的ip</span><br>protected-mode yes<span class="hljs-comment">#保护模式</span><br>port 6379<span class="hljs-comment">#端口设置</span><br></code></pre></div></td></tr></table></figure><blockquote><p>通用GENERAL</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs BASH">daemonize yes<span class="hljs-comment">#以守护进程的方式运行，默认是no，需要自己开启为yes</span><br><br>pidfile /var/run/redis_6379.pid<span class="hljs-comment">#如果以后台的方式运行，就需要指定一个pid文件</span><br><br><span class="hljs-comment"># 日志</span><br><span class="hljs-comment"># Specify the server verbosity level.</span><br><span class="hljs-comment"># This can be one of:</span><br><span class="hljs-comment"># debug (a lot of information, useful for development/testing)</span><br><span class="hljs-comment"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="hljs-comment"># notice (moderately verbose, what you want in production probably)生产环境</span><br><span class="hljs-comment"># warning (only very important / critical messages are logged)</span><br>loglevel notice<br>logfile <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">#日志的文件名</span><br>databases 16<span class="hljs-comment">#数据库的数量，默认是16个数据库</span><br>always-show-logo no<span class="hljs-comment">#是否总是显示logo</span><br></code></pre></div></td></tr></table></figure><blockquote><p>快照</p></blockquote><p>持久化，在规定时间内，执行了多少次操作，则会持久化到文件 .rdb .aof</p><p>redis是内存数据库，如果没有持久化，那么数据断电即失</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 如果900s内，至少有一个key进行了修改，就进行持久化操作</span><br>save 3600 1<br><span class="hljs-comment"># 如果300s内，至少10key进行了修改，就进行持久化操作</span><br>save 300 100<br><span class="hljs-comment"># 如果60s内，至少10000key进行了修改，就进行持久化操作</span><br>save 60 10000<br><span class="hljs-comment"># 可以自定义</span><br><br>stop-writes-on-bgsave-error yes<span class="hljs-comment"># 如果持久化出错，是否还要继续工作</span><br><br>rdbcompression yes<span class="hljs-comment"># 是否压缩rdb文件，需要消耗一些cpu资源</span><br><br>rdbchecksum yes<span class="hljs-comment"># 保存rdb文件的时候，进行错误的检查校验</span><br><br>dir ./<span class="hljs-comment"># reb文件保存的目录</span><br></code></pre></div></td></tr></table></figure><blockquote><p>限制CLIENTS</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">maxclients 10000<span class="hljs-comment"># 设置能连接上redis的最大客户端的数量</span><br><br>maxmemory &lt;bytes&gt;<span class="hljs-comment"># redis配置的最大的内存容量</span><br><br>maxmemory-policy noeviction<span class="hljs-comment"># 内存到达上限之后的处理策略</span><br>1. volatile-lru：只设置了过期时间的key进行LRU（默认值）<br>2. allkeys-lru：删除lru算法的key<br>3. volatile-random：随机删除即将过期的key<br>4. allkeys-random：随机删除<br>5. volatile-ttl：删除即将过期的<br>6. noeviction：永不过期，返回错误<br></code></pre></div></td></tr></table></figure><blockquote><p>APPEND ONLY 模式    aof配置</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">appendonly no<span class="hljs-comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用</span><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span><span class="hljs-comment"># 持久化的文件的名字</span><br><br><span class="hljs-comment"># appendfsync always# 每次修改都会sync，消耗性能</span><br>appendfsync everysec<span class="hljs-comment"># 每秒执行一次sync，可能会丢失这1s的数据</span><br><span class="hljs-comment"># appendfsync no# 不执行sync，这个时候操作系统自己同步数据，速度最快</span><br></code></pre></div></td></tr></table></figure><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能</p><h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><blockquote><p>什么是RDB</p></blockquote><p><img src="/2021/06/08/Redis/20210608103012.png" alt="RDB"></p><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p><p>Redis会单独创建 （ fork )一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。一般默认用RDB</p><p>==rdb保存的文件是dump.rdb==</p><p><img src="/2021/06/08/Redis/20210608103436.png" alt="image-20210608103436795"></p><blockquote><p>触发机制</p></blockquote><ol><li>save 的规则满足的情况下，会自动触发rdb的规则</li><li>执行flushall命令，也会触发rdb规则</li><li>退出redis，也会产生rdb文件</li></ol><p>备份就会自动生成一个rdb文件dump.rdb</p><blockquote><p>如何恢复rdb文件</p></blockquote><ol><li><p>只需要将rdb文件放在redis的启动目录就可以，redis启动的时候会自动检查dump.rdb恢复其中的数据</p></li><li><p>查看位置</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; config get dir<br>1) <span class="hljs-string">&quot;dir&quot;</span><br>2) <span class="hljs-string">&quot;/&quot;</span><span class="hljs-comment"># 如果在这个目录下存在dump.rdb文件，启动就会自动恢复其中的数据</span><br></code></pre></div></td></tr></table></figure></li></ol><blockquote><p>默认配置一般够用</p></blockquote><p><strong>优点：</strong></p><div class="hljs code-wrapper"><pre><code> 1. 适合大规模的数据恢复 2. 对数据的完整性要求不高</code></pre></div><p><strong>缺点：</strong></p><div class="hljs code-wrapper"><pre><code>1. 需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改数据就没有了2. fork进行的时候，会占用一定的内容空间</code></pre></div><h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>将所有命令记录下来，恢复的时候就把这个文件全部再执行一遍</p><blockquote><p>是什么</p></blockquote><p><img src="/2021/06/08/Redis/20210608105137.png" alt="AOF"></p><p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来(读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><p>==AOF保存的是aof文件appendonly.aof==</p><p><img src="/2021/06/08/Redis/20210608105333.png" alt="aof配置"></p><p>默认是不开启的，需要手动配置，只需要将appendonly改为yes就开启了aof</p><p>重启，redis就可以生效了</p><p>如果aof文件有错误，redis是启动不起来的，需要修复这个aof文件</p><p>redis提供了一个修复工具==redis-check-aof —fix==</p><p>如果文件正常，重启就可以直接恢复了</p><blockquote><p>优点和缺点</p></blockquote><p><strong>优点：</strong></p><ol><li>每一次修改都同步，文件的完整性会更好</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率是最高的</li></ol><p><strong>缺点：</strong></p><ol><li>相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢</li><li>Aof运行效率也比rdb慢，所以redis默认的配置就是rdb持久化</li></ol><h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><ol><li>RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储</li><li>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</li><li><strong>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</strong></li><li>同时开启两种持久化方式<ul><li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li><li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢?作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段</li></ul></li><li>性能建议<ul><li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 9001这条规则。</li><li>如果Enable AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IО，二是AOF rewrite 的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li><li>如果不Enable AOF，仅靠Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉（断电），会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave 中的RDB文件，载入较新的那个，微博就是这种架构。</li></ul></li></ol><h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><p>Redis 发布订阅(pub/sub)是一种<strong>消息通信模式</strong>∶发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。<br>订阅/发布消息图︰</p><p><img src="/2021/06/08/Redis/20210608114751.png" alt="订阅/发布消息图"></p><p>下图展示了频道channel1，以及订阅这个频道的三个客户端—client2、 client5和client1之间的关系：</p><p><img src="/2021/06/08/Redis/20210608115132.png" alt="关系图"></p><p>当有新消息通过PUBLISH 命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端：</p><p><img src="/2021/06/08/Redis/20210608115205.png" alt="publish"></p><blockquote><p>命令</p></blockquote><p>广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。</p><p><img src="/2021/06/08/Redis/20210608115339.png" alt="常用命令"></p><blockquote><p>原理</p></blockquote><p>Redis是使用C实现的，通过分析Redis源码里的pubsub.c文件，了解发布和订阅机制的底层实现，籍此加深对Redis的理解。<br>Redis通过PUBLISH、SUBSCRIBE和PSUBSCRIBE等命令实现发布和订阅功能。<br>微信︰<br>通过SUBSCRIBE命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个个频道!，而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。SUBSCRIBE命令的关键，就是将客户端添加到给定channel的订阅链表中。</p><p>通过PUBLISH命令向订阅者发送消息，redis-server会使用给定的频道作为键，在它所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。<br>Pub/Sub从字面上理解就是发布( Publish )与订阅(Subscribe )，在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p><p>使用场景：</p><div class="hljs code-wrapper"><pre><code>1. 实时消息系统2. 实时聊天（频道当作聊天室，将消息回显给所有人）3. 订阅，关注系统</code></pre></div><p>稍微复杂的场景就会使用 消息中间件来做MQ（）</p><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；==数据的复制是单向的，只能由主节点到从节点。==Master以<strong>写</strong>为主，Slave以<strong>读</strong>为主。<br>默认情况下，每台Redis服务器都是主节点;且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。主从复制的作用主要包括︰</p><ol><li>数据冗余︰主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复︰当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复;实际上是一种服务的冗余。</li><li>负载均衡︰在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载;尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用（集群）基石∶除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ol><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下︰</p><ol><li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大;</li><li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，==<strong>单台Redis最大使用内存不应该超过20G</strong>==。</li></ol><p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p><p><img src="/2021/06/08/Redis/20210608120510.png" alt="架构图"></p><p>主从复制，读写分离。80%的情况下都是在进行读操作，减缓服务器的压力，架构中经常使用，一主二从</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>只配置从库，不用配置主库</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; info replication<span class="hljs-comment"># 查看当前库的信息</span><br><span class="hljs-comment"># Replication</span><br>role:master<span class="hljs-comment">#角色  master</span><br>connected_slaves:0<span class="hljs-comment"># 没有从机</span><br>master_failover_state:no-failover<br>master_replid:7cdca0c685bfe1a2eb296b1534f23dbb14dcd382<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></div></td></tr></table></figure><p>复制3个配置文件，然后修改对应的信息</p><ol><li>端口</li><li>pid 名字</li><li>log文件名字</li><li>dump.rdb名字</li></ol><blockquote><p>细节</p></blockquote><p>主机可以写，从机不能写只能读。主机中的所有信息和数据，都会自动被从机保存</p><p><strong>主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候主机如果回来了，从机依旧可以直接获取到主机写的信息</strong></p><p>如果是使用命令行来配置的主从，这个时候如果重启了，就会变成主机。只要变为从机，立马就会从主机中获取值</p><blockquote><p> 复制原理</p></blockquote><p>Slave启动成功连接到 master后会发送一个sync同步命令<br>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，==master将传送整个数据文件到slave，并完成一次完全同步==</p><ul><li><strong>全量复制</strong>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中</li><li><strong>增量复制</strong>：Master继续将新的所有收集到的修改命令依次传给slave，完成同步但是只要是重新连接master，一次完全同步(全量复制)将被自动执行</li></ul><p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行，我们是数据一定可以在从机中看到</p><blockquote><p>手动</p></blockquote><p>如果主机断开了连接，我们可以使用下面的指令来让自己变成主机，其他的节点就可以手动连接到最新的这个主节点（手动）。如果原主机修复了，那就重新连接</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">SLAVEOF no one<br></code></pre></div></td></tr></table></figure><h2 id="哨兵模式（自动）"><a href="#哨兵模式（自动）" class="headerlink" title="哨兵模式（自动）"></a>哨兵模式（自动）</h2><blockquote><p>概述</p></blockquote><p>主从切换技术的方法是︰当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel (哨兵）架构来解决这个问题。</p><p>能够后台监控主机是否故障，如果故障了根据投票数自动<strong>将从库转化为主库</strong>。</p><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例</strong>。</p><p><img src="/2021/06/08/Redis/20210608191620.png" alt="哨兵模式"></p><p>这里的哨兵有两个作用</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器</li><li>当哨兵监测到master宕机，会自动将slave切换成为mater，然后通过<strong>发布订阅</strong>通知其他的从服务器，修改配置文件，让他们切换主机</li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式</p><p><img src="/2021/06/08/Redis/20210608192044.png" alt="多哨兵模式"></p><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p><p>主机回来后只能归并到新的主机下，当作从机，这就是哨兵模式的规则</p><blockquote><p>哨兵模式</p></blockquote><p>优点：</p><ol><li>哨兵集群，基于主从复制模式，所有的主从配置优点</li><li>主从可以切换，故障可以转移，系统的可用性会更好</li><li>哨兵模式就是主从模式的升级版，手动到自动，更加健壮</li></ol><p>缺点：</p><ol><li>Redis不方便在线扩容，集群容量一旦到达上限，在线扩容就十分麻烦</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择</li></ol><h1 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h1><blockquote><p>服务的高可用问题</p></blockquote><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。</p><p>参考：<a href="https://www.cnblogs.com/javalanguage/p/12401829.html">https://www.cnblogs.com/javalanguage/p/12401829.html</a></p><h2 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h2><blockquote><p>概念</p></blockquote><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p><blockquote><p>解决方案</p></blockquote><p><strong>布隆过滤器</strong></p><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/43263751">https://zhuanlan.zhihu.com/p/43263751</a></p><p><strong>缓存空对象</strong></p><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源</p><p><img src="/2021/06/08/Redis/20210608194813.png" alt="缓存空对象"></p><p>但是这种方法会存在两个问题:</p><ol><li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</li><li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li></ol><h2 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h2><blockquote><p>概念</p></blockquote><p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。<br>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p><blockquote><p>解决方案</p></blockquote><p><strong>设置热点数据永不过期</strong></p><p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题。</p><p><strong>加互斥锁</strong></p><p>分布式锁︰使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote><p>概念</p></blockquote><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis宕机</p><p>比如对于系统A，假设每天高峰期每秒5000个请求，本来缓存在高峰期可以扛住每秒4000个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。</p><p><img src="/2021/06/08/Redis/20210608195615.png" alt="缓存雪崩"></p><blockquote><p>解决方案</p></blockquote><p><strong>redis高可用</strong></p><p>增加redis，一台挂掉还有其他的继续工作，其实就是搭建集群</p><p><strong>限流降级</strong></p><p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如说对某个key只允许一个线程查询数据和写数据，其他线程等待</p><p><strong>数据预热</strong></p><p>数据预热的含义就是在正式部署之前，把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问签手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="Redis-和-MemeCache-有什么区别？"><a href="#Redis-和-MemeCache-有什么区别？" class="headerlink" title="Redis 和 MemeCache 有什么区别？"></a>Redis 和 MemeCache 有什么区别？</h2><ol><li>存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。</li><li>数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。</li><li>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型</li><li>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除</li></ol><h2 id="Redis-为什么是单线程的？"><a href="#Redis-为什么是单线程的？" class="headerlink" title="Redis 为什么是单线程的？"></a>Redis 为什么是单线程的？</h2><p>因为 redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p><ol><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol><h2 id="Redis-支持的数据类型有哪些？"><a href="#Redis-支持的数据类型有哪些？" class="headerlink" title="Redis 支持的数据类型有哪些？"></a>Redis 支持的数据类型有哪些？</h2><ul><li>string 字符串（可以为整形、浮点型和字符串，统称为元素）</li><li>list 列表（实现队列,元素不唯一，先入先出原则）</li><li>set 集合（各不相同的元素）</li><li>hash hash散列值（hash的key必须是唯一的）</li><li>sort set 有序集合</li></ul><h2 id="Redis-支持的-Java-客户端都有哪些？"><a href="#Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？"></a>Redis 支持的 Java 客户端都有哪些？</h2><p>Redis Desktop Manager 、Redis Client、Redis Studio、jedis</p><h2 id="Jedis-和-Redisson-有哪些区别？"><a href="#Jedis-和-Redisson-有哪些区别？" class="headerlink" title="Jedis 和 Redisson 有哪些区别？"></a>Jedis 和 Redisson 有哪些区别？</h2><p>Jedis 是 Redis的 java 实现客户端，其 API 提供了比较全面的 Redis 命令的支持；Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务‘管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h2 id="怎么保证缓存和数据库数据的一致性？"><a href="#怎么保证缓存和数据库数据的一致性？" class="headerlink" title="怎么保证缓存和数据库数据的一致性？"></a>怎么保证缓存和数据库数据的一致性？</h2><ul><li>延时双删</li><li>binLog 和消息队列</li></ul><h2 id="Redis-持久化方式"><a href="#Redis-持久化方式" class="headerlink" title="Redis 持久化方式"></a>Redis 持久化方式</h2><ul><li>RDB 快照的方式：直接使用快照将数据定时写入磁盘当中，数据量大具有优势。</li><li>AOF 方式：存储redis操作日志进行存储数据，方便数据的复现。</li></ul><h2 id="Redis-分布式锁有什么缺陷？"><a href="#Redis-分布式锁有什么缺陷？" class="headerlink" title="Redis 分布式锁有什么缺陷？"></a>Redis 分布式锁有什么缺陷？</h2><p>在工作和网络上看到过各个版本的Redis分布式锁实现，每种实现都有一些不严谨的地方，甚至有可能是错误的实现，包括在代码中，如果不能正确的使用分布式锁，可能造成严重的生产环境故障。</p><p>redis分布式锁的缺陷</p><p>传送门： <a href="https://blog.csdn.net/matt8/article/details/64442064">https://blog.csdn.net/matt8/article/details/64442064</a></p><h2 id="Redis-淘汰策略有哪些？"><a href="#Redis-淘汰策略有哪些？" class="headerlink" title="Redis 淘汰策略有哪些？"></a>Redis 淘汰策略有哪些？</h2><p>redis 提供 8 种数据淘汰策略：</p><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰（最常用）</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据，写入报错</li><li>volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li><li>allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ul><h2 id="Redis-常见的性能问题有哪些？该如何解决？"><a href="#Redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="Redis 常见的性能问题有哪些？该如何解决？"></a>Redis 常见的性能问题有哪些？该如何解决？</h2><ol><li><p>master 写内存快照，save 命令调度 rdbsave 函数，会阻塞主线程的工程，当快照比较大的时候对性能的影响是非常大的，会间断性暂停服务 。所以 master 最好不要写内存快照。</p></li><li><p>master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响 master重启时的恢复速度。master 最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化，如果数据比较关键，某个 slave 开启 AOF 备份数据，策略每秒为同步一次。 </p></li><li><p>master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂的服务暂停现象。</p></li><li><p>redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，slave 和 master 最好在同一个局域网内。</p></li></ol><h2 id="Redis-和-Mysql-数据库数据如何保持一致性"><a href="#Redis-和-Mysql-数据库数据如何保持一致性" class="headerlink" title="Redis 和 Mysql 数据库数据如何保持一致性"></a>Redis 和 Mysql 数据库数据如何保持一致性</h2><ul><li><p>主要采用策略是延迟双删</p></li><li><p>参考文献：<a href="https://www.51cto.com/article/701851.html">https://www.51cto.com/article/701851.html</a></p></li></ul><h2 id="Redisson-分布式锁（单机）"><a href="#Redisson-分布式锁（单机）" class="headerlink" title="Redisson 分布式锁（单机）"></a>Redisson 分布式锁（单机）</h2><p>下图的意思就是可重入锁的机制，它最大的优点就是相同线程不需要在等待锁，而是可以直接进行相应操作。</p><p><img src="/2021/06/08/Redis/20220302220718.png" alt="Redisson 分布式锁（单机）"></p><p>Redis分布式锁会有个缺陷，就是在 Redis 哨兵模式下:</p><p><code>客户端1</code>对某个 <code>master节点</code>写入了 redisson 锁，此时会异步复制给对应的 slave 节点。但是这个过程中一旦发生 master 节点宕机，主备切换，slave 节点从变为了 master 节点。这时 <code>客户端2</code>来尝试加锁的时候，在新的 master 节点上也能加锁，此时就会导致多个客户端对同一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题， <strong>导致各种脏数据的产生</strong> 。</p><p><code>缺陷</code>在哨兵模式或者主从模式下，如果 master 实例宕机的时候，可能导致多个客户端同时完成加锁。</p><h2 id="RedLock分布式锁（多机版本）"><a href="#RedLock分布式锁（多机版本）" class="headerlink" title="RedLock分布式锁（多机版本）"></a>RedLock分布式锁（多机版本）</h2><p>现在假设有5个 Redis 主节点（<strong>大于3的奇数个</strong>），这样基本保证他们不会同时都宕掉，获取锁和释放锁的过程中，客户端会执行以下操作：</p><ul><li><p>1.获取当前 Unix 时间，以毫秒为单位；</p></li><li><p>2.依次尝试从5个实例，使用相同的 key 和具有唯一性的 value 获取锁；<br>当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间，这样可以避免客户端死等；</p></li><li><p>3.客户端使用当前时间减去开始获取锁时间就得到获取锁使用的时间。当且仅当从半数以上的 Redis 节点取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功；</p></li><li><p>4.如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间，这个很重要；</p></li><li><p>5.如果因为某些原因，获取锁失败（没有在半数以上实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁，无论 Redis 实例是否加锁成功，因为可能服务端响应消息丢失了但是实际成功了，毕竟多释放一次也不会有问题。</p></li></ul><h2 id="Redis-可以做消息队列么？"><a href="#Redis-可以做消息队列么？" class="headerlink" title="Redis 可以做消息队列么？"></a>Redis 可以做消息队列么？</h2><p>Redis 5.0 新增加的一个数据结构 <code>Stream</code> 可以用来做消息队列，<code>Stream</code> 支持：</p><ul><li>发布 / 订阅模式</li><li>按照消费者组进行消费</li><li>消息持久化（ RDB 和 AOF）</li></ul><p>不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</p><p>我们通常建议是不需要使用 Redis 来做消息队列的，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p><p>相关文章推荐：<a href="https://javakeeper.starfish.ink/data-management/Redis/Redis-MQ.html">Redis 消息队列的三种方案（List、Streams、Pub/Sub）</a></p><h2 id="Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复"><a href="#Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)"></a>Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</h2><p><strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。</p><p><strong>快照（snapshotting）持久化（RDB）</strong></p><p>Redis 可以通过<strong>创建快照来获得存储在内存里面的数据在某个时间点上的副本</strong>。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>           #在<span class="hljs-number">900</span>秒(<span class="hljs-number">15</span>分钟)之后，如果至少有<span class="hljs-number">1</span>个key发生变化，Redis就会自动触发BGSAVE命令创建快照。<br><br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span>          #在<span class="hljs-number">300</span>秒(<span class="hljs-number">5</span>分钟)之后，如果至少有<span class="hljs-number">10</span>个key发生变化，Redis就会自动触发BGSAVE命令创建快照。<br><br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span>        #在<span class="hljs-number">60</span>秒(<span class="hljs-number">1</span>分钟)之后，如果至少有<span class="hljs-number">10000</span>个key发生变化，Redis就会自动触发BGSAVE命令创建快照。<br></code></pre></div></td></tr></table></figure><p><strong>AOF（append-only file）持久化</strong></p><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启。</p><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">appendfsync</span> always    <span class="hljs-comment">#每次有数据修改发生时都会写入AOF文件，这样会严重降低Redis的速度</span><br>appendfsync everysec  <span class="hljs-comment">#每秒钟同步一次，显式地将多个写命令同步到硬盘 （推荐）</span><br>appendfsync <span class="hljs-literal">no</span>        <span class="hljs-comment">#让操作系统决定何时进行同步</span><br></code></pre></div></td></tr></table></figure><p><strong>拓展：Redis 4.0 对于持久化机制的优化</strong></p><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><h2 id="3种常用的缓存读写策略"><a href="#3种常用的缓存读写策略" class="headerlink" title="3种常用的缓存读写策略"></a>3种常用的缓存读写策略</h2><ul><li><p><strong>Cache Aside Pattern（旁路缓存模式）</strong></p><p>写：</p><ol><li><p>先更新 DB</p></li><li><p>然后直接删除 cache </p></li></ol><p><strong>若改变顺序会导致数据库缓存数据不一致的问题。</strong></p><p>读：</p><ol><li><p>从 cache 中读取数据，读取到就直接返回</p></li><li><p>cache中读取不到的话，就从 DB 中读取数据返回</p></li><li><p>再把数据放到 cache 中</p></li></ol><p>缺陷：</p><ol><li>首次请求数据一定不在 cache</li><li>写操作比较频繁的话导致 cache 中的数据会被频繁删除，这样会影响缓存命中率</li></ol><p>解决：</p><ol><li>可以将热点数据可以提前放入 cache 中。</li><li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题</li></ol></li><li><p><strong>Read/Write Through Pattern（读写穿透）</strong></p><p>服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。这种策略非常少见， Redis 也没有提供 cache 将数据写入DB的功能。</p><p>写：</p><ol><li>先查 cache，cache 中不存在，直接更新 DB</li><li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）</li></ol><p>读：</p><ol><li>从 cache 中读取数据，读取到就直接返回 </li><li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应</li></ol></li><li><p><strong>Write Behind Pattern（异步缓存写入）</strong></p><p>与读写穿透相似都是由 cache 服务来负责和 DB 的读写。</p><p>不同是<strong>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p><p>这种策略在我们平时开发过程中也非常少见</p></li></ul><h2 id="本地缓存与-Redis-缓存的区别"><a href="#本地缓存与-Redis-缓存的区别" class="headerlink" title="本地缓存与 Redis 缓存的区别"></a>本地缓存与 Redis 缓存的区别</h2><ol><li>读写速度，不考虑并发，本地缓存自然是最快的。</li><li>redis 内存可能 n 多扩充，而本地扩大堆内存代价是很大的。</li><li>本地缓存需要自己实现过期功能，实现不好可能导致极其严重的后果，而redis经过大量的流量验证，许多漏洞无需考试，安全。</li><li>本地缓存无法提供丰富的数据结构，redis可以。redis可以写磁盘，持久化，本地缓存不可以或者说很麻烦要考虑的东西太多。</li><li>使用本地缓存极有可能导致严重的线程安全问题，并发考虑严重。</li></ol><h2 id="Redis-为什么这么快"><a href="#Redis-为什么这么快" class="headerlink" title="Redis 为什么这么快"></a>Redis 为什么这么快</h2><p>根据官方数据，Redis 的 QPS 可以达到约 100000（每秒请求数）。</p><ol><li><p>Redis 是基于内存的数据库，跟磁盘数据库相比，完全吊打磁盘的速度</p></li><li><p>高效的数据结构</p><p><img src="/2021/06/08/Redis/20220320140044.jpg" alt="数据结构"></p></li><li><p>采用 I/O 多路复用技术，并发处理连接。采用了 epoll + 自己实现的简单的事件框架。</p></li></ol><p><strong>参考：<a href="https://www.bilibili.com/video/BV1S54y1R7SB">狂神说</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Java后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署elasticsearch</title>
    <link href="/2021/05/12/EsDeploy/"/>
    <url>/2021/05/12/EsDeploy/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker部署ElasticSearch"><a href="#Docker部署ElasticSearch" class="headerlink" title="Docker部署ElasticSearch"></a>Docker部署ElasticSearch</h1><h2 id="1-1-拉取镜像"><a href="#1-1-拉取镜像" class="headerlink" title="1.1 拉取镜像"></a>1.1 拉取镜像</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker pull elasticsearch:7.12.0<br></code></pre></div></td></tr></table></figure><h2 id="1-2-创建容器并启动"><a href="#1-2-创建容器并启动" class="headerlink" title="1.2 创建容器并启动"></a>1.2 创建容器并启动</h2><p>ElasticSearch的默认端口是9200，把宿主环境9200端口映射到Docker容器中的9200端口，就可以访问到Docker容器中的ElasticSearch服务了，同时把这个容器明明为elasticsearch</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -e &quot;discovery.type=single-node&quot; 镜像id<br></code></pre></div></td></tr></table></figure><h2 id="1-3-配置内存"><a href="#1-3-配置内存" class="headerlink" title="1.3 配置内存"></a>1.3 配置内存</h2><p>避免elasticsearch占用内存过多设置其初始内存和最大内存，修改容器中的==jvm.options==配置文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">修改里面<br><br>-Xms256m<br>-Xmx256m<br></code></pre></div></td></tr></table></figure><h2 id="1-4-配置跨域"><a href="#1-4-配置跨域" class="headerlink" title="1.4 配置跨域"></a>1.4 配置跨域</h2><h3 id="1-4-1-进入容器"><a href="#1-4-1-进入容器" class="headerlink" title="1.4.1 进入容器"></a>1.4.1 进入容器</h3><p>进入容器中修改相应的配置信息</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it elasticsearch /bin/bash<br></code></pre></div></td></tr></table></figure><h3 id="1-4-2-进行配置"><a href="#1-4-2-进行配置" class="headerlink" title="1.4.2 进行配置"></a>1.4.2 进行配置</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 显示文件</span><br>ls<br>结果如下：<br>LICENSE.txt  README.textile  config  lib   modules<br>NOTICE.txt   bin             data    logs  plugins<br><br><span class="hljs-comment"># 进入配置文件夹</span><br><span class="hljs-built_in">cd</span> config<br><br><span class="hljs-comment"># 显示文件</span><br>ls<br>结果如下：<br>elasticsearch.keystore  ingest-geoip  log4j2.properties  roles.yml  users_roles<br>elasticsearch.yml       jvm.options   role_mapping.yml   users<br><br><span class="hljs-comment"># 修改配置文件</span><br>vi elasticsearch.yml<br><br><span class="hljs-comment"># 加入跨域配置</span><br>http.cors.enabled: <span class="hljs-literal">true</span><br>http.cors.allow-origin: <span class="hljs-string">&quot;*&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="1-5-重启容器"><a href="#1-5-重启容器" class="headerlink" title="1.5 重启容器"></a>1.5 重启容器</h2><p>由于修改了配置，因此需要重启ElasticSearch容器</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker restart elasticsearch<br></code></pre></div></td></tr></table></figure><p><img src="/2021/05/12/EsDeploy/20210512142827.png" alt="访问9200端口"></p><h1 id="Docker部署ElasticSearch-head"><a href="#Docker部署ElasticSearch-head" class="headerlink" title="Docker部署ElasticSearch-head"></a>Docker部署ElasticSearch-head</h1><p>安装==ElasticSearch-head==的原因是需要又一个管理界面进行查看ElasticSearch的相关信息</p><h2 id="2-1-拉取镜像"><a href="#2-1-拉取镜像" class="headerlink" title="2.1 拉取镜像"></a>2.1 拉取镜像</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker pull mobz/elasticsearch-head:5<br></code></pre></div></td></tr></table></figure><h2 id="2-2-运行容器"><a href="#2-2-运行容器" class="headerlink" title="2.2 运行容器"></a>2.2 运行容器</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker run -d --name es_admin -p 9100:9100 镜像id<br></code></pre></div></td></tr></table></figure><p><img src="/2021/05/12/EsDeploy/picture/20210512143226.png" alt="访问9100端口"></p><h2 id="2-3-常见问题"><a href="#2-3-常见问题" class="headerlink" title="2.3 常见问题"></a>2.3 常见问题</h2><p>创建索引失败</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it es_admin /bin/bash<br></code></pre></div></td></tr></table></figure><p>使用此命令进入es_head插件安装目录终端</p><p>编辑 <strong>/usr/src/app/_site/vendor.js</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1. 6886行 /contentType: <span class="hljs-string">&quot;application/x-www-form-urlencoded </span><br><span class="hljs-string">    改成 contentType: &quot;</span>application/json;charset=UTF-8<span class="hljs-string">&quot; </span><br><span class="hljs-string">2. 7574行 var inspectData = s.contentType === &quot;</span>application/x-www-form-urlencoded<span class="hljs-string">&quot; &amp;&amp; </span><br><span class="hljs-string">    改成 var inspectData = s.contentType === &quot;</span>application/json;charset=UTF-8<span class="hljs-string">&quot; &amp;&amp;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ElasticSearch</tag>
      
      <tag>Docker部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch</title>
    <link href="/2021/04/30/ElasticSearch/"/>
    <url>/2021/04/30/ElasticSearch/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch概述"><a href="#ElasticSearch概述" class="headerlink" title="ElasticSearch概述"></a>ElasticSearch概述</h1><p><code>Elasticsearch</code>是一个基于<code>Apache Lucene(TM)</code>的开源的<strong>高扩展</strong>的<strong>分布式全文检索引擎</strong>，无论在开源还是专有领域，Lucene 可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。<br>但是，Lucene只是一个库。想要发挥其强大的作用，你需使用Java并要将其集成到你的应用中。Lucene 非常复杂，你需要深入的了解检索相关知识来理解它是如何工作的。<br><code>Elasticsearch</code>也是使用 Java 编写并使用 Lucene 来建立索引并实现搜索功能，但是它的目的是通过简单连贯的<code>RESTful API</code>让全文搜索变得简单并隐藏 Lucene 的复杂性。<br>不过，<code>Elasticsearch</code>不仅仅是 Lucene 和全文搜索引擎，它还提供：</p><ul><li>分布式的实时文件存储，每个字段都被索引并可被搜索</li><li>实时分析的分布式搜索引擎</li><li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li></ul><p>而且，所有的这些功能被集成到一台服务器，你的应用可以通过简单的RESTful API、各种语言的客户端甚至命令行与之交互。上手Elasticsearch非常简单，它提供了许多合理的缺省值，并对初学者隐藏了复杂的搜索引擎理论。它开箱即用（安装即可使用），只需很少的学习既可在生产环境中使用。Elasticsearch在Apache 2 license下许可使用，可以免费下载、使用和修改。<br>随着知识的积累，你可以根据不同的问题领域定制Elasticsearch的高级特性，这一切都是可配置的，并且配置非常灵活。</p><h1 id="ES和solr的差别"><a href="#ES和solr的差别" class="headerlink" title="ES和solr的差别"></a>ES和solr的差别</h1><h2 id="Solr-简介"><a href="#Solr-简介" class="headerlink" title="Solr 简介"></a>Solr 简介</h2><p>Solr 是 Apache 下的一个顶级开源项目，采用 Java 开发，它是基于 Lucene 的全文搜索服务器。Solr 提供了比 Lucene 更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化</p><p>Solr 可以独立运行，运行在 Jetty、Tomcat 等这些 Servlet 容器中，Solr索引的实现方法很简单，用 POST 方法向 Solr 服务器发送一个描述Field 及其内容的XML文档，Solr 根据 xml 文档添加、删除、更新索引 Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回 Xml、json 等格式的查询结果进行解析，组织页面布局。Solr 不提供构建 UI 的功能，Solr 提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。</p><p>Solr 是基于 lucene 开发企业级搜索服务器，实际上就是封装了 lucene。</p><p>Solr 是一个独立的企业级搜索应用服务器，它对外提供类似于 Web-service 的 API 接口。用户可以通过 http 请求，向搜索引擎服务器提交一定格式的文件，生成索引；也可以通过提出查找请求，并得到返回结果。</p><h2 id="Lucene简介"><a href="#Lucene简介" class="headerlink" title="Lucene简介"></a>Lucene简介</h2><p> Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言)。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。<strong>在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前以及最近几年最受欢迎的免费Java信息检索程序库。</strong>人们经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。</p><p>Lucene是一个全文检索引擎的架构。那什么是全文搜索引擎?</p><p>全文搜索引擎是名副其实的搜索引擎，国外具代表性的有 Google、Fast/AlTheWeb、AltaVista、Inktomi、Teoma、WiseNut 等，国内著名的有百度(Baidu)。它们都是通过从互联网上提取的各个网站的信息（以网页文字为主）而建立的数据库中，检索与用户查询条件匹配的相关记录，然后按一定的排列顺序将结果返回给用户，因此他们是真正的搜索引擎。</p><p>从搜索结果来源的角度，全文搜索引擎又可细分为两种，一种是拥有自己的检索程序(Indexer)，俗称”蜘蛛” (Spider) 程序或”机器人”(Robot)程序，并自建网页数据库，搜索结果直接从自身的数据库中调用，如上面提到的7家引擎;另一种则是租用其他引擎的数据库，并按自定的格式排列搜索结果，如 Lycos 引擎。</p><h2 id="Elasticsearch-和-Solr-比较"><a href="#Elasticsearch-和-Solr-比较" class="headerlink" title="Elasticsearch 和 Solr 比较"></a>Elasticsearch 和 Solr 比较</h2><ul><li>当单纯的对已有数据进行搜索时，Solr 更快</li><li>当实时建立索引时，Solr 会产生 io 阻塞，查询性能较差，Elasticsearch 具有明显的优势</li><li>随着数据量的增加，Solr 的搜索效率会变得更低，而 Elasticsearch 却没有明显的变化</li></ul><p><strong>Elasticsearch vs Solr 总结</strong></p><ol><li>es 基本是开箱即用（解压就能用），非常简单。Solr 安装略微复杂一丢丢!</li><li>Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能。</li><li>Solr支持更多格式的数据，比如 JSON、XML、CSV，而 Elasticsearch <strong>仅支持</strong> json 文件格式。</li><li>Solr官方提供的功能更多，而Elasticsearch本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要kibana友好支撑</li><li>Solr查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用;<ul><li>ES 建立索引快，<strong>即实时性查询快</strong>，用于 facebook 新浪等搜索。</li><li>Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。</li></ul></li><li>Solr 比较成熟，有一个更大，更成熟的用户、开发和贡献者社区，而 Elasticsearch 相对开发维护者较少，更新太快，学习使用成本较高。</li></ol><h1 id="ElasticSearch-安装"><a href="#ElasticSearch-安装" class="headerlink" title="ElasticSearch 安装"></a>ElasticSearch 安装</h1><p>声明：JDK1.8，最低要求！ElasticSearch客户端，界面工具！</p><blockquote><p>下载</p></blockquote><p>官网：<a href="https://www.elastic.co/">https://www.elastic.co/</a></p><blockquote><p>window下安装</p></blockquote><ol><li><p>解压就可以使用了</p><p><img src="/2021/04/30/ElasticSearch/image-20210430190355544.png" alt="解压目录"></p></li><li><p>熟悉目录</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">bin 启动文件<br>config 配置文件<br>log4j日志配置文件<br>jvm.optionsjava 虚拟机相关的配置<br>elasticsearch.ymlelasticsearch 的配置文件默认9200端口 跨域<br>lib相关jar包<br>logs日志<br>modules功能模块<br>plugins插件<br></code></pre></div></td></tr></table></figure></li><li><p>启动</p><p>双击 elasticsearch.bat 文件</p></li></ol><p><img src="/2021/04/30/ElasticSearch/20210831144336.png" alt></p><p><img src="/2021/04/30/ElasticSearch/image-20210430191321976.png" alt="启动"></p><p><img src="/2021/04/30/ElasticSearch/image-20210430191459782.png" alt="访问9200端口"></p><blockquote><p>安装可视化界面 es head的插件</p></blockquote><ol><li><p>下载</p></li><li><p>启动</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install<br>npm run start<br></code></pre></div></td></tr></table></figure></li></ol><ol><li><p>连接测试发现存在跨域问题：配置 es</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">http.cors.enabled: <span class="hljs-literal">true</span><br>heep.cors.allow-origin: <span class="hljs-string">&quot;*&quot;</span><br></code></pre></div></td></tr></table></figure></li></ol><ol><li>重启 es 服务器，然后再次连接</li></ol><p>把 es 当作一个数据库（可以建立索引（库），文档（库中的数据））</p><p>这个head当作是一个数据展示工具，后面的查询使用Kibana</p><blockquote><p>了解 ELK</p></blockquote><p>ELK 是 Elasticsearch、Logstash、Kibana 三大开源框架首字母大写简称。市面上也被成为 Elastic Stack。其中 Elasticsearch 是一个基于 Lucene 、分布式、通过 Restful 方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架，可见 Elasticsearch 提供的搜索能力确实强大,市面上很多时候我们简称 Elasticsearch 为 es.Logstash 是 ELK 的中央数据流引擎，用于从不同目标（文件/数据存储/MQ）收集的不同格式数据，经过过滤后支持输出到不同目的地（文件/MQ/redis/elasticsearch/kafka等)。Kibana可以将elasticsearch的数据通过友好的页面展示出来，提供实时分析的功能。</p><p>市面上很多开发只要提到 ELK 能够一致说出它是一个日志分析架构技术栈总称，但实际上 ELK 不仅仅适用于日志分析，它还可以支持其它任何数据分析和收集的场景，日志分析和收集只是更具有代表性。并非唯一性。</p><p><img src="/2021/04/30/ElasticSearch/20210502095342.png" alt></p><blockquote><p>安装 Kibana</p></blockquote><p>Kibana 是一个针对 Elasticsearch 的开源分析及可视化平台，用来搜索、查看交互存储在 Elasticsearch 索引中的数据。使用 Kibana ,可以通过各种图表进行高级数据分析及展示。Kibana 让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板( dashboard )实时显示 Elasticsearch 查询动态。设置 Kibana 非常简单。无需编码或者额外的基础架构，几分钟内就可以完成 Kibana 安装并启动 Elasticsearch 索引监测。</p><p><strong>Kibana版本要与ES一致</strong></p><h1 id="ES-核心概念"><a href="#ES-核心概念" class="headerlink" title="ES 核心概念"></a>ES 核心概念</h1><ol><li>索引</li><li>字段类型（mapping）</li><li>文档（documents）</li></ol><blockquote><p>概述</p></blockquote><p><strong>集群，节点，索引，类型，文档，分片，映射是什么</strong></p><blockquote><p>elasticsearch 是面向文档，关系型数据库和 elasticsearch 客观的对比</p></blockquote><p><img src="/2021/04/30/ElasticSearch/20210502100322.png" alt></p><p>elasticsearch（集群）中可以包含多个索引（数据库），每个索引中可以包含多个类型（表），每个类型下又包含多个文档（行），每个文档中又包含多个字段（列）</p><p><strong>物理设计：</strong></p><p>elasticsearch <strong>在后台把每个索引划分成多个分片</strong>，每个分片可以在集群中的不听服务器间迁移</p><p>一个人就是一个集群</p><p><strong>逻辑设计：</strong></p><p>一个索引类型中，包含多个文档，比如说文档1，文档2。我们索引一篇文档时，可以通过这样一个顺序找到：索引 &gt; 类型 &gt; 文档id，通过这个组合我们就能索引到某个具体的文档。注意：id不必是整数，实际上它是个字符串。</p><blockquote><p>文档</p></blockquote><p>之前说 elasticsearch 是面向文档的，那么就意味着索引和搜索数据的最小单位是文档，elasticsearch 中，文档有几个重要属性:</p><ul><li>自我包含，一篇文档同时包含字段和对应的值，也就是同时包含key:value !</li><li>可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的!</li><li>灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。</li></ul><p>尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符串也可以是整形。因为 elasticsearch 会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在 elasticsearch 中，类型有时候也称为映射类型。</p><blockquote><p>类型</p></blockquote><p>类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。类型中对于字段的定义称为映射，比如 name 映射为字符串类型。我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么 elasticsearch 是怎么做的呢？ elasticsearch 会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch 就开始猜，如果这个值是18，那么 elasticsearch 会认为它是整形。但是 elasticsearch 也可能猜不对，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用。</p><blockquote><p>索引</p></blockquote><p>索引是映射类型的容器，elasticsearch 中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。然后它们被存储到了各个分片上了。我们来研究下分片是如何工作的。</p><p><strong>物理设计：节点和分片 如何工作</strong></p><p>一个集群至少有一个节点，而一个节点就是一个 elasricsearch 进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片( primary shard ,又称主分片)构成的，每一个主分片会有一个副本( replica shard ,又称复制分片)</p><p><img src="/2021/04/30/ElasticSearch/20210502102147.png" alt></p><p>上图是一个有3个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内，这样有利于某个节点挂掉了，数据也不至于丢失。实际上，一个分片是一个 Lucene 索引，一个包含<strong>倒排索引</strong>的文件目录，倒排索引的结构使得 elasticsearch 在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。</p><blockquote><p>倒排索引</p></blockquote><p>elasticsearch 使用的是一种称为倒排索引的结构，采用 Lucene 倒排索作为底层。这种结构适用于快速的全文搜索，一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。例如，现在有两个文档，每个文档包含如下内容︰</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">Study every day, good good up to forever<span class="hljs-comment"># 文档1包含的内容</span><br>To forever, study every day, good good up<span class="hljs-comment"># 文档2包含的内容</span><br></code></pre></div></td></tr></table></figure><p>为了创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者tokens)，然后创建一个包含所有不重复的词条的排序列表，然后列出每个词条出现在哪个文档：</p><p><img src="/2021/04/30/ElasticSearch/20210502102631.png" alt></p><p>现在搜索to forever，只需要查看包含每个词条的文档</p><p><img src="/2021/04/30/ElasticSearch/20210502103014.png" alt></p><p>两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，现在，这两个包含关键字的文档都将返回。再来看一个示例，比如我们通过博客标签来搜索博客文章。那么倒排索引列表就是这样的一个结构：</p><p>elasticsearch 的索引和 Lucene 的索引对比<br>在 elasticsearch 中，索引这个词被频繁使用，这就是术语的使用。在 elasticsearch 中，索引被分为多个分片，每份分片是一个 Lucene 的索引。所以一个 elasticsearch 索引是由多个Lucene索引组成的。别问为什么，谁让 elasticsearch 使用 Lucene 作为底层呢!如无特指，说起索引都是指 elasticsearch 的索引。</p><h1 id="IK-分词器"><a href="#IK-分词器" class="headerlink" title="IK 分词器"></a>IK 分词器</h1><p>分词︰即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词，比如“我叫张三”会被分为”我””叫””张””三”，这显然是不符合要求的，所以我们需要安装中文分词器ik来解决这个问题。<br>IK提供了两个分词算法: ik smart和ik<em>max_word，其中 ik</em> smart为最少切分，ik_max_word为最细粒度划分</p><blockquote><p>安装</p></blockquote><p>下载完毕后放入到  elasticsearch 插件即可，然后重启观察 ES</p><blockquote><p>查看不同的分词效果</p></blockquote><p><img src="/2021/04/30/ElasticSearch/20210507105039.png" alt="ik_smart"></p><p><img src="/2021/04/30/ElasticSearch/20210507105253.png" alt="ik_max_word"></p><blockquote><p>ik 分词器也可以增加自己的配置</p></blockquote><p><img src="/2021/04/30/ElasticSearch/20210507105517.png" alt="配置文件"></p><h1 id="Rest-风格说明"><a href="#Rest-风格说明" class="headerlink" title="Rest 风格说明"></a>Rest 风格说明</h1><p>一种软件架构风格，而不是栋准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>基本Rest命令说明：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>method</strong></th><th style="text-align:center"><strong>url地址</strong></th><th style="text-align:center"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:center">PUT</td><td style="text-align:center">localhost:9200/索引名称/类型名称/文档id</td><td style="text-align:center">创建文档（指定文档id）</td></tr><tr><td style="text-align:center">POST</td><td style="text-align:center">localhost:9200/索引名称/类型名称</td><td style="text-align:center">创建文档（指定文档id）</td></tr><tr><td style="text-align:center">POST</td><td style="text-align:center">localhost:9200/索引名称/类型名称/文档id/_update</td><td style="text-align:center">修改文档</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">localhost:9200/索引名称/类型名称/文档id</td><td style="text-align:center">删除文档</td></tr><tr><td style="text-align:center">GET</td><td style="text-align:center">localhost:9200/索引名称/类型名称/文档id</td><td style="text-align:center">查询文档通过文档id</td></tr><tr><td style="text-align:center">POST</td><td style="text-align:center">localhost:9200/索引名称/类型名称/_search</td><td style="text-align:center">查询所有数据</td></tr></tbody></table></div><h1 id="关于索引的基本操作"><a href="#关于索引的基本操作" class="headerlink" title="关于索引的基本操作"></a>关于索引的基本操作</h1><p><img src="/2021/04/30/ElasticSearch/20210507105954.png" alt></p><p><img src="/2021/04/30/ElasticSearch/20210507110031.png" alt></p><p>扩展︰通过命令 elasticsearch 索引情况!通过 get _cat/ 可以获得es的当前的很多信息！</p><p><img src="/2021/04/30/ElasticSearch/20210507110145.png" alt></p><h1 id="关于文档的基本操作"><a href="#关于文档的基本操作" class="headerlink" title="关于文档的基本操作"></a>关于文档的基本操作</h1><blockquote><p>基本操作</p></blockquote><ol><li><p>添加数据</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">PUT /test2/user/1<br>&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">20</span>,<br>  <span class="hljs-attr">&quot;birth&quot;</span>: <span class="hljs-string">&quot;2001-05-07&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">GET test2/user/1<br></code></pre></div></td></tr></table></figure></li><li><p>更新数据</p><p><img src="/2021/04/30/ElasticSearch/20210507110853.png" alt></p><p>更推荐 post  _update这种更新方式</p></li><li><p>搜索</p><p>查询参数体</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">GET /question/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;content&quot;</span>: <span class="hljs-string">&quot;问题&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/04/30/ElasticSearch/20210507111212.png" alt></p><p>如果存在多条查询出来的结果，匹配度越高则分值越高</p></li></ol><h1 id="结合项目"><a href="#结合项目" class="headerlink" title="结合项目"></a>结合项目</h1><p>最近实验室有个项目需要实现基础的智能问答功能。因此准备利用 es 的搜索功能搜索到问答库中匹配度最高的问题，再找到其对应的回答内容并返回，来实现简单的智能问答。</p><p>下面简要介绍集成 es 到 springboot 项目的步骤，以及部分相关的业务代码。</p><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Elasticsearch相关依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Elasticsearch相关配置</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">elasticsearch:</span><br>    <span class="hljs-attr">repositories:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">cluster-nodes:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9300</span> <span class="hljs-comment"># es的连接地址及端口号</span><br>      <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">elasticsearch</span> <span class="hljs-comment"># es集群的名称</span><br></code></pre></div></td></tr></table></figure><h2 id="创建config-类"><a href="#创建config-类" class="headerlink" title="创建config 类"></a>创建config 类</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsClientConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestHighLevelClient <span class="hljs-title">restHighLevelClient</span><span class="hljs-params">()</span></span>&#123;<br>        RestHighLevelClient restHighLevelClient = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9200</span>, <span class="hljs-string">&quot;http&quot;</span>)));<br>        <span class="hljs-keyword">return</span> restHighLevelClient;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="service-层增加相关接口"><a href="#service-层增加相关接口" class="headerlink" title="service 层增加相关接口"></a>service 层增加相关接口</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从数据库中导入所有问题到ES</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> : int</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> AoCan</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/29 19:54</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">Boolean <span class="hljs-title">importAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据关键字搜索问题</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> : 返回匹配度最高的问题id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> content : 问题内容</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> AoCan</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/29 19:56</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">Integer <span class="hljs-title">search</span><span class="hljs-params">(String content)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br></code></pre></div></td></tr></table></figure><p>相关 service 实现类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">importAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//批量插入数据</span><br>        BulkRequest bulkRequest = <span class="hljs-keyword">new</span> BulkRequest();<br>        bulkRequest.timeout(<span class="hljs-string">&quot;10s&quot;</span>);<br><br>        List&lt;Question&gt; list = questionMapper.getAnswerPassList();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            bulkRequest.add(<span class="hljs-keyword">new</span> IndexRequest(QUESTION).id(<span class="hljs-string">&quot;&quot;</span>+(i+<span class="hljs-number">1</span>)).source(JSON.toJSONString(list.get(i)), XContentType.JSON));<br>        &#125;<br>        BulkResponse bulkResponse = client.bulk(bulkRequest, RequestOptions.DEFAULT);<br>        System.out.println(bulkResponse.hasFailures());<br>        <span class="hljs-keyword">return</span> bulkResponse.hasFailures();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">search</span><span class="hljs-params">(String content)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Integer questionId = <span class="hljs-keyword">null</span>;<br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(QUESTION);<br>        <span class="hljs-comment">//构建搜索条件</span><br>        SearchSourceBuilder sourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();<br><br>        <span class="hljs-comment">//查询条件，我们可以使用QueryBuilders 工具来实现</span><br>        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery()<br>                .should(QueryBuilders.matchQuery(<span class="hljs-string">&quot;content&quot;</span>, content));<br>        sourceBuilder.query(boolQueryBuilder);<br>        sourceBuilder.timeout(<span class="hljs-keyword">new</span> TimeValue(<span class="hljs-number">60</span>, TimeUnit.SECONDS));<br><br>        request.source(sourceBuilder);<br><br>        SearchResponse searchResponse = client.search(request, RequestOptions.DEFAULT);<br><span class="hljs-comment">//        if (searchResponse.getHits().getTotalHits().value != 0 &amp;&amp; searchResponse.getHits().getMaxScore() &gt; MIN_SCORE)&#123;</span><br>        <span class="hljs-keyword">if</span> (searchResponse.getHits().getTotalHits().value != <span class="hljs-number">0</span>)&#123;<br>            isSearched = <span class="hljs-keyword">true</span>;<br>            questionId = (Integer) searchResponse.getHits().getAt(<span class="hljs-number">0</span>).getSourceAsMap().get(<span class="hljs-string">&quot;id&quot;</span>);<br>            String questionContent = (String) searchResponse.getHits().getAt(<span class="hljs-number">0</span>).getSourceAsMap().get(<span class="hljs-string">&quot;content&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> questionId;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h2 id="Controller-层编写"><a href="#Controller-层编写" class="headerlink" title="Controller 层编写"></a>Controller 层编写</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(value = &quot;根据用户的问题获取答案&quot;, notes = &quot;用户提问后获取回答，若获取不到则返回固定字符串&quot;)</span><br><span class="hljs-meta">@ApiImplicitParams(&#123;</span><br><span class="hljs-meta">@ApiImplicitParam(name = &quot;content&quot;, value = &quot;消息内容&quot;, required = true, dataType = &quot;Integer&quot;,paramType = &quot;query&quot;)</span><br><span class="hljs-meta"> &#125;)</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/getAnswerByMessage&quot;, method = RequestMethod.GET)</span><br> <span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;String&gt; <span class="hljs-title">getAnswerByMessage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;content&quot;)</span> String content)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>     Integer userId = RequestAttributeUtil.getUserIdInRequest();<br>     Answer answer = inquiryService.getAnswerByQuestion(userId, content);<br>     <span class="hljs-keyword">if</span> (answer.getContent() != <span class="hljs-keyword">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> CommonResult.success(answer.getContent());<br>     &#125;<span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> CommonResult.success(noAnswerTips);<br>     &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搜索</tag>
      
      <tag>ElasticSearch</tag>
      
      <tag>Kibana</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v-if与v-show的区别</title>
    <link href="/2021/04/28/v-if&amp;v-show/"/>
    <url>/2021/04/28/v-if&amp;v-show/</url>
    
    <content type="html"><![CDATA[<h1 id="vue中v-if与v-show的区别"><a href="#vue中v-if与v-show的区别" class="headerlink" title="vue中v-if与v-show的区别"></a>vue中v-if与v-show的区别</h1><p>共同点：</p><p>​    v-if与v-show都能动态控制dom元素的显示隐藏</p><p>不同点：</p><p>​    查看vue的官方文档</p><p><img src="/2021/04/28/v-if&v-show/picture/20210428140527.png" alt="v-if vs v-show"></p><p>​    简单来说就是v-if显示隐藏是将dom元素整个添加或删除，而v-show隐藏则是为该元素添加css—display:none，dom元素还在。</p><p>​    v-show不支持 <template>元素，也不支持 v-else。</template></p><p>​    ==注意：==当一个元素默认在css中加了display：none属性，这时通过v-show修改为true是无法让元素显示的。原因是显示隐藏切换，只是会修改<strong>element style为display:””或者display:none,并不会覆盖掉或修改已存在的css属性。</strong></p><ul><li><strong>1.手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li><li><strong>2.编译过程</strong>：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li><li><strong>3.编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；</li><li><strong>4.性能消耗：</strong>v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li><li><strong>5.使用场景：</strong>v-if适合运营条件不大可能改变；v-show适合频繁切换。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>前端</tag>
      
      <tag>条件渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决hexo d 报超时的问题</title>
    <link href="/2021/04/25/OvertimeOfHexo-d/"/>
    <url>/2021/04/25/OvertimeOfHexo-d/</url>
    
    <content type="html"><![CDATA[<h1 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h1><blockquote><p>运行hexo d时报错</p></blockquote><p><img src="/2021/04/25/OvertimeOfHexo-d/20210425194953.png" alt="image-20210425194953535"></p><blockquote><p>报错可以看出是连接超时的问题</p></blockquote><h1 id="2、解决"><a href="#2、解决" class="headerlink" title="2、解决"></a>2、解决</h1><blockquote><p>找到git的安装目录，找到ssh_config文件，使用记事本打开</p></blockquote><p><img src="/2021/04/25/OvertimeOfHexo-d/20210425195146.png" alt="image-20210425195146015"></p><blockquote><p>把如下内容复制到ssh_config文件中</p></blockquote><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">Host github.com<br><span class="hljs-keyword">User</span> <span class="hljs-title">git</span><br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br>Port <span class="hljs-number">443</span><br></code></pre></div></td></tr></table></figure><blockquote><p>添加完成后如下图</p></blockquote><p><img src="/2021/04/25/OvertimeOfHexo-d/20210425195319.png" alt="image-20210425195319230"></p><blockquote><p>再次输入 hexo d 即可顺利运行</p></blockquote><p><img src="/2021/04/25/OvertimeOfHexo-d/20210425195421.png" alt="image-20210425195421262"></p>]]></content>
    
    
    <categories>
      
      <category>博客问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习</title>
    <link href="/2021/04/25/Linux/"/>
    <url>/2021/04/25/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="入门概述"><a href="#入门概述" class="headerlink" title="入门概述"></a>入门概述</h1><blockquote><p>Linux简介</p></blockquote><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><blockquote><p>Linux发行版</p></blockquote><p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p><p><img src="/2021/04/25/Linux/20210425183218.png" alt="image-20210425183218207"></p><p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p><p><img src="/2021/04/25/Linux/20210425183235.png" alt="image-20210425183235732"></p><blockquote><p>Linux vs  Windows</p></blockquote><p><img src="/2021/04/25/Linux/20210425183346.png" alt="image-20210425183315039"></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><blockquote><p>安装CentOS（虚拟机安装）</p></blockquote><p>1、可以通过镜像进行安装！</p><p>2、安装 VMware 虚拟机软件</p><blockquote><p>购买云服务器</p></blockquote><p>1、购买完毕后，获取服务器的ip地址，重置服务器密码，就可以远程登录了</p><p>2、xShell工具连接</p><p><strong>注意事项：</strong>如果要打开端口，需要在阿里云的安全组面板中开启对应的出入规则，不然的话会被阿里拦截！</p><blockquote><p>推荐安装宝塔面板，傻瓜式管理服务器</p></blockquote><p>安装教程：<a href="https://www.bt.cn/bbs/thread-19376-1-1.html">https://www.bt.cn/bbs/thread-19376-1-1.html</a></p><p>1、开启对应的端口</p><p>2、一键安装</p><p>3、安装完毕后会得到远程面板的地址，账号，密码，就可以登录了</p><p>4、登录之后就可以可视化的安装环境和部署网站！</p><blockquote><p>关于域名</p></blockquote><p>如果自己的网站想要上线，就一定要购买一个域名然后进行备案</p><h1 id="走进Linux系统"><a href="#走进Linux系统" class="headerlink" title="走进Linux系统"></a>走进Linux系统</h1><blockquote><p>开机登录</p></blockquote><p>开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p><p>开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！</p><p>一般来说，用户的登录方式有三种：</p><ul><li>命令行登录</li><li>ssh登录</li><li>图形界面登录</li></ul><p>最高权限账户为 root，可以操作一切！</p><blockquote><p>关机</p></blockquote><p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>关机指令为：shutdown ；</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">sync </span><span class="hljs-comment"># 将数据由内存同步到硬盘中。</span><br><br><span class="hljs-keyword">shutdown </span><span class="hljs-comment"># 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><br><span class="hljs-keyword">shutdown </span>–h <span class="hljs-number">10</span> <span class="hljs-comment"># 这个命令告诉大家，计算机将在10分钟后关机</span><br><br><span class="hljs-keyword">shutdown </span>–h now <span class="hljs-comment"># 立马关机</span><br><br><span class="hljs-keyword">shutdown </span>–h <span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-comment"># 系统会在今天20:25关机</span><br><br><span class="hljs-keyword">shutdown </span>–h +<span class="hljs-number">10</span> <span class="hljs-comment"># 十分钟后关机</span><br><br><span class="hljs-keyword">shutdown </span>–r now <span class="hljs-comment"># 系统立马重启</span><br><br><span class="hljs-keyword">shutdown </span>–r +<span class="hljs-number">10</span> <span class="hljs-comment"># 系统十分钟后重启</span><br><br>reboot <span class="hljs-comment"># 就是重启，等同于 shutdown –r now</span><br><br>halt <span class="hljs-comment"># 关闭系统，等同于shutdown –h now 和 poweroff</span><br></code></pre></div></td></tr></table></figure><p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p><blockquote><p>系统目录结构</p></blockquote><p>登录系统后，在当前命令窗口输入命令：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> /<br></code></pre></div></td></tr></table></figure><p>会看到如下图所示</p><p><img src="/2021/04/25/Linux/20210425184229.png" alt="image-20210425184229128"></p><p>树状目录结构：</p><p><img src="/2021/04/25/Linux/20210425184310.png" alt="image-20210425184310421"></p><p><strong>以下是对这些目录的解释：</strong></p><ul><li><strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li><strong>/boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li><strong>/dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li><strong>/etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li><li><strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li><strong>/lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</li><li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li><li><strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li><strong>/proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li><li><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li><strong>/sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li><li><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs。</li><li><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</li><li><strong>/usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li><li><strong>/usr/bin：</strong> 系统用户使用的应用程序。</li><li><strong>/usr/sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</li><li><strong>/usr/src：</strong> 内核源代码默认的放置目录。</li><li><strong>/var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li></ul><h1 id="常用的基本命令"><a href="#常用的基本命令" class="headerlink" title="常用的基本命令"></a>常用的基本命令</h1><h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><blockquote><p>绝对路径和相对路径</p></blockquote><p><strong>绝对路径：</strong></p><p>路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。</p><p><strong>相对路径：</strong></p><p>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法</p><blockquote><p>处理目录的常用命令</p></blockquote><ul><li>ls: 列出目录</li><li>cd：切换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><blockquote><p>ls（列出目录）</p><p>cd（切换目录）</p></blockquote><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><blockquote><p>pwd ( 显示目前所在的目录 )</p></blockquote><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><blockquote><p>mkdir （创建新目录）</p></blockquote><p>make directory</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 加了这个 -p 的选项，可以自行帮你创建多层目录！</span><br> <span class="hljs-attribute">mkdir</span> -p test<span class="hljs-number">1</span>/test<span class="hljs-number">2</span>/test<span class="hljs-number">3</span>/test<span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><blockquote><p>rmdir ( 删除空的目录 )</p></blockquote><p>注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录</p><blockquote><p>cp ( 复制文件或目录 )</p></blockquote><p>语法：</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-attr">[root@www ~]</span># <span class="hljs-selector-tag">cp</span> <span class="hljs-selector-attr">[-adfilprsu]</span> 来源档(source) 目标档(destination)<br><span class="hljs-selector-attr">[root@www ~]</span># <span class="hljs-selector-tag">cp</span> <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-tag">source1</span> <span class="hljs-selector-tag">source2</span> <span class="hljs-selector-tag">source3</span> .... <span class="hljs-selector-tag">directory</span><br></code></pre></div></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-a：</strong>相当于 -pdr 的意思，至于 pdr 请参考下列说明；(常用)</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><blockquote><p>rm ( 移除文件或目录 )</p></blockquote><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">rm <span class="hljs-selector-attr">[-fir]</span> 文件或目录<br></code></pre></div></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># 尽量不要在服务器上使用 rm -rf /</span><br></code></pre></div></td></tr></table></figure><blockquote><p>mv  ( 移动文件与目录，或修改名称 )</p></blockquote><p>语法：</p><figure class="highlight autoit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># mv [-fiu] source destination</span><br>[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># mv [options] source1 source2 source3 .... directory</span><br></code></pre></div></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><blockquote><p>看懂文件属性</p></blockquote><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组</p><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p><ul><li>当为[ <strong>d</strong> ]则是目录</li><li>当为[ <strong>-</strong> ]则是文件；</li><li>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；</li><li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li><li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li></ul><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p><p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p><p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><p>每个文件的属性由左边第一部分的10个字符来确定（如下图）：</p><p><img src="/2021/04/25/Linux/20210425185737.png" alt="image-20210425185737757"></p><p>从左至右用 <strong>0-9</strong> 这些数字来表示。</p><p>第 <strong>0</strong> 位确定文件类型，第 <strong>1-3</strong> 位确定属主（该文件的所有者）拥有该文件的权限。</p><p>第<strong>4-6</strong>位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><p>其中，第 <strong>1、4、7</strong> 位表示读权限，如果用 <strong>r</strong> 字符表示，则有读权限，如果用 <strong>-</strong> 字符表示，则没有读权限；</p><p>第 <strong>2、5、8</strong> 位表示写权限，如果用 <strong>w</strong> 字符表示，则有写权限，如果用 <strong>-</strong> 字符表示没有写权限；第 <strong>3、6、9</strong> 位表示可执行权限，如果用 <strong>x</strong> 字符表示，则有执行权限，如果用 <strong>-</strong> 字符表示，则没有执行权限。</p><blockquote><p>修改文件属性</p></blockquote><p><strong>1、chgrp：更改文件属组</strong></p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">chgrp <span class="hljs-selector-attr">[-R]</span> 属组名 文件名<br></code></pre></div></td></tr></table></figure><p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p><p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong></p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">chown <span class="hljs-selector-attr">[–R]</span> 属主名 文件名<br>chown <span class="hljs-selector-attr">[-R]</span> 属主名：属组名 文件名<br></code></pre></div></td></tr></table></figure><p><strong>3、chmod：更改文件9个属性</strong></p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">chmod <span class="hljs-selector-attr">[-R]</span> xyz 文件或目录<br></code></pre></div></td></tr></table></figure><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><h2 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h2><blockquote><p>概述</p></blockquote><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>你可以使用 <em>man [命令]</em>来查看各个命令的使用文档，如 ：man cp。</p><blockquote><p>cat 由第一行开始显示文件内容</p><p>tac</p></blockquote><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写</p><blockquote><p>nl  显示行号</p><p>拓展：Linux链接概念</p></blockquote><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p><p>情况下，<strong>ln</strong> 命令产生硬链接。</p><p><strong>硬连接</strong></p><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><p><strong>软连接</strong></p><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p><h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><p>安装软件一般有三种方式：rpm（jdk：在线发布一个SpringBoot项目）、解压缩（tomcat：启动并通过外网访问）、yum在线安装（docker：直接运行跑起来docker就可以）</p><h2 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h2><p>1、下载jdk rpm，去oracle官网</p><p>2、安装java环境</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># 检测当前系统是否存在java环境java -version</span><br><span class="hljs-meta"># 如果有的话需要卸载</span><br><span class="hljs-meta"># rpm -qa|grep jdk # 检测JDK版本信息</span><br><span class="hljs-meta"># rpm -e --nodeps jdk_</span><br><br><span class="hljs-meta"># 卸载完毕后即可安装jdk</span><br><span class="hljs-meta"># rpm -ivh rpm包</span><br><br><span class="hljs-meta"># 配置环境变量</span><br></code></pre></div></td></tr></table></figure><p>如果存在可以提前卸载</p><p><img src="/2021/04/25/Linux/20210426111737.png" alt="image-20210426111730039"></p><p>安装</p><p><img src="/2021/04/25/Linux/20210426111748.png" alt="image-20210426111748047"></p><p>配置环境变量：<strong>/etc/profile</strong>        在文件的最后面增加java的配置和window安装环境变量一样</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">JAVA_HOME=<span class="hljs-regexp">/usr/</span>java/jdk1.<span class="hljs-number">8.0</span>_291-amd64<br><span class="hljs-keyword">ClASSPATH</span>=%JAVA_HOME%<span class="hljs-regexp">/lib:%JAVA_HOME%/</span>jre/lib<br>export <span class="hljs-keyword">CLASSPATH</span> JAVA_HOME<br></code></pre></div></td></tr></table></figure><p>让这个配置文件生效    <strong>source /etc/profile</strong></p><h2 id="Tomcat安装"><a href="#Tomcat安装" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h2><p>ssm war就需要放到tomcat中运行</p><p>1、下载tomcat，官网下载即可tomcat9    <strong>apache-tomcat-9.0.45.tar.gz</strong></p><p>2、解压这个文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tar -zxvf apache-tomcat-9.0.45.tar.gz<br></code></pre></div></td></tr></table></figure><p><img src="/2021/04/25/Linux/20210426114950.png" alt="image-20210426114950688"></p><p>3、启动tomcat测试    ./xxx.sh脚本即可运行</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># 执行./startup.sh</span><br><span class="hljs-meta"># 停止./shutdown.sh</span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/04/25/Linux/20210426115213.png" alt="image-20210426115213412"></p><p>4、确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的</p><figure class="highlight dsconfig"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 查看firewall服务状态</span><br><span class="hljs-string">systemctl</span> <span class="hljs-string">status</span> <span class="hljs-string">firewalld</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><span class="hljs-comment"># 开启、重启、关闭、firewalld.service服务</span><br><span class="hljs-comment"># 开启</span><br><span class="hljs-string">service</span> <span class="hljs-string">firewalld</span> <span class="hljs-string">start</span><br><span class="hljs-string"></span><span class="hljs-comment"># 重启</span><br><span class="hljs-string">service</span> <span class="hljs-string">firewalld</span> <span class="hljs-string">restart</span><br><span class="hljs-string"></span><span class="hljs-comment"># 关闭</span><br><span class="hljs-string">service</span> <span class="hljs-string">firewalld</span> <span class="hljs-string">stop</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><span class="hljs-comment"># 查看防火墙规则</span><br><span class="hljs-string">firewall-cmd</span> <span class="hljs-built_in">--list-all</span>    <span class="hljs-comment"># 查看全部信息</span><br><span class="hljs-string">firewall-cmd</span> <span class="hljs-built_in">--list-ports</span>  <span class="hljs-comment"># 只看端口信息</span><br><br><span class="hljs-comment"># 开启端口</span><br>开端口命令：<span class="hljs-string">firewall-cmd</span> <span class="hljs-built_in">--zone=public</span> <span class="hljs-built_in">--add-port=80/tcp</span> <span class="hljs-built_in">--permanent</span><br><span class="hljs-built_in">重启防火墙：systemctl</span> <span class="hljs-string">restart</span> <span class="hljs-string">firewalld</span>.<span class="hljs-string">service</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span>命令含义：<br><span class="hljs-built_in">--zone</span> <span class="hljs-comment">#作用域</span><br><span class="hljs-built_in">--add-port=80/tcp</span>  <span class="hljs-comment">#添加端口，格式为：端口/通讯协议</span><br><span class="hljs-built_in">--permanent</span>   <span class="hljs-comment">#永久生效，没有此参数重启后失效</span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/04/25/Linux/20210426115231.png" alt="image-20210426115231727"></p><h2 id="Docker（yum安装）"><a href="#Docker（yum安装）" class="headerlink" title="Docker（yum安装）"></a>Docker（yum安装）</h2><p>官网安装参考手册：<a href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></p><p>一定要联网，yum在线安装</p><blockquote><p>基于CentOS7安装</p></blockquote><p>1、检测CentOS7 </p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">[root<span class="hljs-title">@centos</span> bin]# cat /etc/redhat-<span class="hljs-keyword">release</span> <br>CentOS Linux <span class="hljs-keyword">release</span> <span class="hljs-number">7.9</span>.<span class="hljs-number">2009</span> (Core)<br></code></pre></div></td></tr></table></figure><p>2、安装准备环境</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> 包名<span class="hljs-comment"># yum install 安装命令-y所有的提示都为y</span><br>yum -y <span class="hljs-keyword">install</span> gcc<br>yum -y <span class="hljs-keyword">install</span> gcc-c++<br></code></pre></div></td></tr></table></figure><p>3、清除以前的版本</p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">yum remove docker <span class="hljs-string">\</span><br>          docker-client <span class="hljs-string">\</span><br>          docker-client-latest <span class="hljs-string">\</span><br>          docker-common <span class="hljs-string">\</span><br>          docker-latest <span class="hljs-string">\</span><br>          docker-latest-logrotate <span class="hljs-string">\</span><br>          docker-logrotate <span class="hljs-string">\</span><br>          docker-engine<br></code></pre></div></td></tr></table></figure><p>4、安装需要的软件包</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y yum-utils<br></code></pre></div></td></tr></table></figure><p>5、设置stable镜像仓库</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-comment"># 正确推荐使用国内的</span><br>yum-config-manager --add-repo http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo<br></code></pre></div></td></tr></table></figure><p>6、更新yum软件包索引</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">yum makecache fast</span><br></code></pre></div></td></tr></table></figure><p>7、安装Docker CE</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">yum -<span class="hljs-keyword">y</span> install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io<br></code></pre></div></td></tr></table></figure><p>8、启动docker</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker<br></code></pre></div></td></tr></table></figure><p>9、测试</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">docker <span class="hljs-built_in">version</span><br><br>docker <span class="hljs-built_in">run</span> hello-world<br><br>docker images<br></code></pre></div></td></tr></table></figure><p><strong>参考：<a href="https://www.bilibili.com/video/BV1S54y1R7SB">狂神说</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot学习</title>
    <link href="/2021/04/23/SpringBoot/"/>
    <url>/2021/04/23/SpringBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="回顾Spring"><a href="#回顾Spring" class="headerlink" title="回顾Spring"></a>回顾Spring</h2><p>Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson  。</p><p><strong>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。</strong></p><h2 id="Spring是如何简化Java开发的"><a href="#Spring是如何简化Java开发的" class="headerlink" title="Spring是如何简化Java开发的"></a>Spring是如何简化Java开发的</h2><p>为了降低Java开发的复杂性，Spring采用了以下4种关键策略：</p><p>1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean；</p><p>2、通过IOC，依赖注入（DI）和面向接口实现松耦合；</p><p>3、基于切面（AOP）和惯例进行声明式编程；</p><p>4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate；</p><h2 id="什么是SpringBoot"><a href="#什么是SpringBoot" class="headerlink" title="什么是SpringBoot"></a>什么是SpringBoot</h2><p>开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍；</p><p>言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置，  you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。</p><p>所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。</p><p>是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。</p><p>随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；</p><p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以<strong>约定大于配置的核心思想</strong>，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p><p>简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。</p><p>Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。</p><p><strong>Spring Boot的主要优点：</strong></p><ul><li>为所有Spring开发者更快的入门</li><li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置</li><li>内嵌式容器简化Web项目</li><li>没有冗余代码生成和XML配置的要求</li></ul><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092708.png" alt="image-20210305195239664"></p><h1 id="第一个SpringBoot程序"><a href="#第一个SpringBoot程序" class="headerlink" title="第一个SpringBoot程序"></a>第一个SpringBoot程序</h1><p>官方:提供了一个快速生成的网站， IDEA集成了这个网站</p><ul><li>可以在官网直接下载后，导入idea开发</li><li>直接使用idea创建一个springboot项目(一般开发直接在IDEA中创建) </li></ul><h1 id="原理初探"><a href="#原理初探" class="headerlink" title="原理初探"></a>原理初探</h1><p>自动配置：</p><h2 id="porm-xml"><a href="#porm-xml" class="headerlink" title="porm.xml"></a><strong>porm.xml</strong></h2><ul><li>spring-boot-dependencies：核心依赖在父工程中</li><li>我们在写或者引入一些Springboot依赖的时候，不需要指定版本，就因为有这些版本仓库</li></ul><p><strong>启动器</strong></p><ul><li>```xml<br><dependency><div class="hljs code-wrapper"><pre><code>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;</code></pre></div>&lt;/dependency&gt;<figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><br>- **springboot-boot-starter-xxx**：就是spring-boot的场景启动器<br><br>- **spring-boot-starter-web**：帮我们导入了web模块正常运行所依赖的组件<br><br>- SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；<br><br><br><br>## 主启动类<br><br>```java<br><span class="hljs-comment">//@SpringBootApplication：标注这个类是一个springboot的应用</span><br>@SpringBootApplication<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootDemoApplication</span> &#123;</span><br>    <span class="hljs-comment">//将springboot应用启动</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        SpringApplication.<span class="hljs-built_in">run</span>(SpringbootDemoApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></dependency></li></ul><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><p>进入这个注解：可以看到上面还有很多其他注解！</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(    </span><br><span class="hljs-meta">excludeFilters = &#123;@Filter(    </span><br><span class="hljs-meta">type = FilterType.CUSTOM,    </span><br><span class="hljs-meta">classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="hljs-meta">), @Filter(    </span><br><span class="hljs-meta">type = FilterType.CUSTOM,    </span><br><span class="hljs-meta">classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>这个注解在Spring中很重要 ,它对应XML配置中的元素。</p><p>作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中</p><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；</p><p>我们继续进去这个注解查看</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 点进去得到下面的 </span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Configurationpublic</span> <br><span class="hljs-meta">@interface</span> <br>SpringBootConfiguration &#123;&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Configuration &#123;&#125;<br></code></pre></div></td></tr></table></figure><p>这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；</p><p>里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！</p><p>我们回到 SpringBootApplication 注解中继续看。</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p><p>以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p><p>点进注解接续查看：</p><p><strong>@AutoConfigurationPackage ：自动配置包</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;Registrar.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>@import</strong> ：Spring底层注解@import ， 给容器中导入一个组件</p><p>Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ；</p><p>这个分析完了，退到上一步，继续看</p><p><strong>@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ；</strong></p><p>AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</p><p>1、这个类中有一个这样的方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获得候选的配置</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;    <br>    <span class="hljs-comment">//这里的getSpringFactoriesLoaderFactoryClass（）方法    </span><br>    <span class="hljs-comment">//返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration    </span><br>    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="hljs-keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-keyword">this</span>.getBeanClassLoader());    <br>    Assert.notEmpty(configurations, <span class="hljs-string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);    <br>    <span class="hljs-keyword">return</span> configurations;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>2、这个方法又调用了  SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;    <br>    String factoryClassName = factoryClass.getName();    <br>    <span class="hljs-comment">//这里它又调用了 loadSpringFactories 方法</span><br>    <span class="hljs-keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>3、我们继续点击查看 loadSpringFactories 方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;    <br>    <span class="hljs-comment">//获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身    </span><br>    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);    <br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;        <br>        <span class="hljs-keyword">return</span> result;    <br>    &#125; <span class="hljs-keyword">else</span> &#123;        <br>        <span class="hljs-keyword">try</span> &#123;            <br>            <span class="hljs-comment">//去获取一个资源 &quot;META-INF/spring.factories&quot;            </span><br>            Enumeration&lt;URL&gt; urls = classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>);            <br>            LinkedMultiValueMap result = <span class="hljs-keyword">new</span> LinkedMultiValueMap();<br>            <br>            <span class="hljs-comment">//将读取到的资源遍历，封装成为一个Properties            </span><br>            <span class="hljs-keyword">while</span>(urls.hasMoreElements()) &#123;                <br>                URL url = (URL)urls.nextElement();                <br>                UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);                <br>                Properties properties = PropertiesLoaderUtils.loadProperties(resource);                <br>                Iterator var6 = properties.entrySet().iterator();<br>                <br>                <span class="hljs-keyword">while</span>(var6.hasNext()) &#123;                    <br>                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();                    <br>                    String factoryClassName = ((String)entry.getKey()).trim();                    <br>                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());                    <br>                    <span class="hljs-keyword">int</span> var10 = var9.length;<br>                    <br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var11 = <span class="hljs-number">0</span>; var11 &lt; var10; ++var11) &#123;                        <br>                        String factoryName = var9[var11];                        <br>                        result.add(factoryClassName, factoryName.trim());                    <br>                    &#125;                <br>                &#125;            <br>            &#125;<br>            <br>            cache.put(classLoader, result);            <br>            <span class="hljs-keyword">return</span> result;        <br>        &#125; <span class="hljs-keyword">catch</span> (IOException var13) &#123;            <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var13);        <br>        &#125;    <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>4、发现一个多次出现的文件：spring.factories，全局搜索它</p><h3 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h3><p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092723.png" alt="image-20210306152301707"></p><p><strong>WebMvcAutoConfiguration</strong></p><p>我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092735.png" alt="image-20210306152331857"></p><p>可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！</p><p>所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p><p><strong>结论：</strong></p><ol><li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</li><li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li><li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li><li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li><li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li></ol><h2 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h2><h3 id="不简单的方法"><a href="#不简单的方法" class="headerlink" title="不简单的方法"></a>不简单的方法</h3><p>我最初以为就是运行了一个main方法，没想到却开启了一个服务；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootApplication</span> </span>&#123;    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <br>        SpringApplication.run(SpringbootApplication.class, args);    <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>SpringApplication.run分析</strong></p><p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p><h3 id="SpringApplication-1"><a href="#SpringApplication-1" class="headerlink" title="SpringApplication"></a>SpringApplication</h3><p><strong>这个类主要做了以下四件事情：</strong></p><p>1、推断应用的类型是普通的项目还是Web项目</p><p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p><p>3、找出所有的应用程序监听器，设置到listeners属性中</p><p>4、推断并设置main方法的定义类，找到运行的主类</p><p>查看构造器：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class... primarySources)</span> </span>&#123;    <br>    <span class="hljs-comment">// ......    </span><br>    <span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();    <br>    <span class="hljs-keyword">this</span>.setInitializers(<span class="hljs-keyword">this</span>.getSpringFactoriesInstances();  <br>    <span class="hljs-keyword">this</span>.setListeners(<span class="hljs-keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.class));    <br>    <span class="hljs-keyword">this</span>.mainApplicationClass = <span class="hljs-keyword">this</span>.deduceMainApplicationClass();<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="yaml配置注入"><a href="#yaml配置注入" class="headerlink" title="yaml配置注入"></a>yaml配置注入</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的</p><ul><li><p>application.properties</p></li><li><ul><li>语法结构 ：key=value</li></ul></li><li><p>application.yml</p></li><li><ul><li>语法结构 ：key：空格 value</li></ul></li></ul><p><strong>配置文件的作用 ：</strong>修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；</p><h2 id="yaml概述"><a href="#yaml概述" class="headerlink" title="yaml概述"></a>yaml概述</h2><p>YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）</p><p><strong>这种语言以数据**</strong>作<strong>**为中心，而不是以标记语言为重点！</strong></p><p>以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml</p><p>传统xml配置：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8081<span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>yaml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">server：</span>  <br><span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br></code></pre></div></td></tr></table></figure><h2 id="yaml基础语法"><a href="#yaml基础语法" class="headerlink" title="yaml基础语法"></a>yaml基础语法</h2><p>说明：语法要求严格！</p><p>1、空格不能省略</p><p>2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</p><p>3、属性和值的大小写都是十分敏感的。</p><p><strong>字面量：普通的值  [ 数字，布尔值，字符串  ]</strong></p><p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；</p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">k:</span> v<br></code></pre></div></td></tr></table></figure><p>注意：</p><ul><li><p>“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；</p><p>比如 ：name: “kuang \n shen”  输出 ：kuang  换行  shen</p></li><li><p>‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出</p><p>比如 ：name: ‘kuang \n shen’  输出 ：kuang  \n  shen</p></li></ul><p><strong>对象、Map（键值对）</strong></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#对象、Map格式k:     </span><br><span class="hljs-attr">v1:</span>    <br><span class="hljs-attr">v2:</span><br></code></pre></div></td></tr></table></figure><p>在下一行来写对象的属性和值得关系，注意缩进；比如：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">student:</span>    <br><span class="hljs-attr">name:</span> <span class="hljs-string">qinjiang</span>    <br><span class="hljs-attr">age:</span> <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p>行内写法</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">student:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">qinjiang</span>,<span class="hljs-attr">age:</span> <span class="hljs-number">3</span>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>数组（ List、set ）</strong></p><p>用 - 值表示数组中的一个元素,比如：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">pets:</span> <br><span class="hljs-bullet">-</span> <span class="hljs-string">cat</span> <br><span class="hljs-bullet">-</span> <span class="hljs-string">dog</span> <br><span class="hljs-bullet">-</span> <span class="hljs-string">pig</span><br></code></pre></div></td></tr></table></figure><p>行内写法</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">pets:</span> [<span class="hljs-string">cat</span>,<span class="hljs-string">dog</span>,<span class="hljs-string">pig</span>]<br></code></pre></div></td></tr></table></figure><p><strong>修改SpringBoot的默认端口号</strong></p><p>配置文件中添加，端口号的参数，就可以切换端口；</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <br><span class="hljs-attr">port:</span> <span class="hljs-number">8082</span><br></code></pre></div></td></tr></table></figure><h2 id="yaml注入配置文件"><a href="#yaml注入配置文件" class="headerlink" title="yaml注入配置文件"></a>yaml注入配置文件</h2><p>1、在springboot项目中的resources目录下新建一个文件 application.yaml</p><p>2、编写一个实体类 Dog；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>  <span class="hljs-comment">//注册bean到容器中</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>  <span class="hljs-comment">//注册bean到容器中</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;阿黄&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;18&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>4、在SpringBoot的测试类下注入狗狗输出一下；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot02ConfigApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">//将狗狗自动注入进来</span><br>    Dog dog;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(dog); <span class="hljs-comment">//打印看下狗狗对象</span><br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果成功输出，@Value注入成功</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092800.png" alt="image-20210308194858923"></p><p>5、我们在编写一个复杂一点的实体类：Person 类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>  <span class="hljs-comment">//注册到bean容器中</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Boolean happy;<br>    <span class="hljs-keyword">private</span> Date birth;<br>    <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; maps;<br>    <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;<br>    <span class="hljs-keyword">private</span> Dog dog;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">person:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">qinjiang</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">happy:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">birth:</span> <span class="hljs-number">2000</span><span class="hljs-string">/01/01</span><br>  <span class="hljs-attr">maps:</span> &#123;<span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span>,<span class="hljs-attr">k2:</span> <span class="hljs-string">v2</span>&#125;<br>  <span class="hljs-attr">lists:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">code</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">girl</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">music</span><br>  <span class="hljs-attr">dog:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">旺财</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">@ConfigurationProperties作用：</span><br><span class="hljs-comment">将配置文件中配置的每一个属性的值，映射到这个组件中；</span><br><span class="hljs-comment">告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定</span><br><span class="hljs-comment">参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">@Component</span>  <span class="hljs-comment">//注册到bean容器中</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Boolean happy;<br>    <span class="hljs-keyword">private</span> Date birth;<br>    <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; maps;<br>    <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;<br>    <span class="hljs-keyword">private</span> Dog dog;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092809.png" alt="image-20210308195103669"></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>9、确认以上配置都OK之后，我们去测试类中测试一下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot02ConfigApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">//将狗狗自动注入进来</span><br>    Person person;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(person); <br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092815.png" alt="image-20210308195305285"></p><h2 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h2><p>配置文件还可以编写占位符生成随机数</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">person:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">qinjiang$&#123;random.uuid&#125;</span> <span class="hljs-comment"># 随机uuid</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-string">$&#123;random.int&#125;</span>  <span class="hljs-comment"># 随机int</span><br>  <span class="hljs-attr">happy:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">birth:</span> <span class="hljs-number">2000</span><span class="hljs-string">/01/01</span><br>  <span class="hljs-attr">maps:</span> &#123;<span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span>,<span class="hljs-attr">k2:</span> <span class="hljs-string">v2</span>&#125;<br>  <span class="hljs-attr">lists:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">code</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">girl</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">music</span><br>  <span class="hljs-attr">dog:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">$&#123;person.h:other&#125;_旺财</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h2 id="对比小结"><a href="#对比小结" class="headerlink" title="对比小结"></a>对比小结</h2><p>@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092824.png" alt="image-20210309091607657"></p><p>1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加</p><p>2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下</p><p>3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性</p><p>4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持</p><p><strong>结论：</strong></p><p>配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；</p><p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p><p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties</p><h1 id="JSR303数据校验"><a href="#JSR303数据校验" class="headerlink" title="JSR303数据校验"></a>JSR303数据校验</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式；</p><p><strong>使用数据校验，可以保证数据的正确性；</strong> </p><h2 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@NotNull(message=&quot;名字不能为空&quot;)</span><br><span class="hljs-keyword">private</span> String userName;<br><span class="hljs-meta">@Max(value=120,message=&quot;年龄最大不能查过120&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><span class="hljs-meta">@Email(message=&quot;邮箱格式错误&quot;)</span><br><span class="hljs-keyword">private</span> String email;<br><br>空检查<br><span class="hljs-meta">@Null</span>       验证对象是否为<span class="hljs-keyword">null</span><br><span class="hljs-meta">@NotNull</span>    验证对象是否不为<span class="hljs-keyword">null</span>, 无法查检长度为<span class="hljs-number">0</span>的字符串<br><span class="hljs-meta">@NotBlank</span>   检查约束字符串是不是Null还有被Trim的长度是否大于<span class="hljs-number">0</span>,只对字符串,且会去掉前后空格.<br><span class="hljs-meta">@NotEmpty</span>   检查约束元素是否为NULL或者是EMPTY.<br><br>Booelan检查<br><span class="hljs-meta">@AssertTrue</span>     验证 Boolean 对象是否为 <span class="hljs-keyword">true</span><br><span class="hljs-meta">@AssertFalse</span>    验证 Boolean 对象是否为 <span class="hljs-keyword">false</span><br><br>长度检查<br><span class="hljs-meta">@Size(min=, max=)</span> 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内<br><span class="hljs-meta">@Length(min=, max=)</span> string is between min and max included.<br><br>日期检查<br><span class="hljs-meta">@Past</span>       验证 Date 和 Calendar 对象是否在当前时间之前<br><span class="hljs-meta">@Future</span>     验证 Date 和 Calendar 对象是否在当前时间之后<br><span class="hljs-meta">@Pattern</span>    验证 String 对象是否符合正则表达式的规则<br><br>.......等等<br>除此以外，我们还可以自定义一些数据校验规则<br></code></pre></div></td></tr></table></figure><h1 id="多环境切换"><a href="#多环境切换" class="headerlink" title="多环境切换"></a>多环境切换</h1><p>profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；</p><h2 id="多配置文件"><a href="#多配置文件" class="headerlink" title="多配置文件"></a>多配置文件</h2><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本；</p><p><strong>例如：</strong></p><p>application-test.properties 代表测试环境配置</p><p>application-dev.properties 代表开发环境配置</p><p>但是Springboot并不会直接启动这些配置文件，它<strong>默认使用application.properties主配置文件</strong>；</p><p>我们需要通过一个配置来选择需要激活的环境：</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；</span><br><span class="hljs-comment">#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；</span><br><span class="hljs-meta">spring.profiles.active</span>=<span class="hljs-string">dev</span><br></code></pre></div></td></tr></table></figure><h2 id="yaml的多文档块"><a href="#yaml的多文档块" class="headerlink" title="yaml的多文档块"></a>yaml的多文档块</h2><p>和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><span class="hljs-comment">#选择要激活那个环境块</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">prod</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#配置环境的名称</span><br><br><br><span class="hljs-meta">---</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8084</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">prod</span>  <span class="hljs-comment">#配置环境的名称</span><br></code></pre></div></td></tr></table></figure><p><strong>注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！</strong></p><h2 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="配置文件加载位置"></a>配置文件加载位置</h2><p><strong>外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！</strong></p><p>官方外部配置文件说明参考文档</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092834.png" alt="image-20210309111038585"></p><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">优先级<span class="hljs-number">1</span>：项目路径下的config文件夹配置文件<br>优先级<span class="hljs-number">2</span>：项目路径下配置文件<br>优先级<span class="hljs-number">3</span>：资源路径下的config文件夹配置文件<br>优先级<span class="hljs-number">4</span>：资源路径下配置文件<br></code></pre></div></td></tr></table></figure><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p><p><strong>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</strong></p><p>我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#配置项目的访问路径</span><br><span class="hljs-string">server.servlet.context-path=/ac</span><br></code></pre></div></td></tr></table></figure><h1 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h1><h2 id="分析自动配置原理"><a href="#分析自动配置原理" class="headerlink" title="分析自动配置原理"></a>分析自动配置原理</h2><p>我们以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；</span><br><span class="hljs-meta">@Configuration</span> <br><br><span class="hljs-comment">//启动指定类的ConfigurationProperties功能；</span><br>  <span class="hljs-comment">//进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；</span><br>  <span class="hljs-comment">//并把HttpProperties加入到ioc容器中</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;HttpProperties.class&#125;)</span> <br><br><span class="hljs-comment">//Spring底层@Conditional注解</span><br>  <span class="hljs-comment">//根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；</span><br>  <span class="hljs-comment">//这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效</span><br><span class="hljs-meta">@ConditionalOnWebApplication(</span><br><span class="hljs-meta">    type = Type.SERVLET</span><br><span class="hljs-meta">)</span><br><br><span class="hljs-comment">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span><br><br><span class="hljs-comment">//判断配置文件中是否存在某个配置：spring.http.encoding.enabled；</span><br>  <span class="hljs-comment">//如果不存在，判断也是成立的</span><br>  <span class="hljs-comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span><br><span class="hljs-meta">@ConditionalOnProperty(</span><br><span class="hljs-meta">    prefix = &quot;spring.http.encoding&quot;,</span><br><span class="hljs-meta">    value = &#123;&quot;enabled&quot;&#125;,</span><br><span class="hljs-meta">    matchIfMissing = true</span><br><span class="hljs-meta">)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span> </span>&#123;<br>    <span class="hljs-comment">//他已经和SpringBoot的配置文件映射了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Encoding properties;<br>    <span class="hljs-comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span><span class="hljs-params">(HttpProperties properties)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.properties = properties.getEncoding();<br>    &#125;<br>    <br>    <span class="hljs-comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span> <span class="hljs-comment">//判断容器没有这个组件？</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title">characterEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        CharacterEncodingFilter filter = <span class="hljs-keyword">new</span> OrderedCharacterEncodingFilter();<br>        filter.setEncoding(<span class="hljs-keyword">this</span>.properties.getCharset().name());<br>        filter.setForceRequestEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));<br>        filter.setForceResponseEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));<br>        <span class="hljs-keyword">return</span> filter;<br>    &#125;<br>    <span class="hljs-comment">//。。。。。。。</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！</strong></p><ul><li>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</li><li>这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</li><li>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；</li><li>配置文件能配置什么就可以参照某个功能对应的这个属性类</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//从配置文件中获取指定的值和bean的属性进行绑定</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.http&quot;)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpProperties</span> </span>&#123;<br>    <span class="hljs-comment">// .....</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>去配置文件里面试试前缀看提示</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092842.png" alt="image-20210310141630438"></p><p><strong>这就是自动装配的原理</strong></p><h2 id="精髓"><a href="#精髓" class="headerlink" title="精髓"></a>精髓</h2><p>1、SpringBoot启动会加载大量的自动配置类</p><p>2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；</p><p>3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）</p><p>4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；</p><p><strong>xxxxAutoConfigurartion：自动配置类；</strong>给容器中添加组件</p><p><strong>xxxxProperties:封装配置文件中相关属性；</strong></p><h2 id="了解：-Conditional"><a href="#了解：-Conditional" class="headerlink" title="了解：@Conditional"></a>了解：@Conditional</h2><p>了解完自动装配的原理后，我们来关注一个细节问题，<strong>自动配置类必须在一定的条件下才能生效；</strong></p><p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092848.png" alt="image-20210310141738129"></p><p><strong>那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</strong></p><p>我们怎么知道哪些自动配置类生效？</p><p><strong>我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</strong></p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#开启springboot的调试类</span><br><span class="hljs-attr">debug</span>=<span class="hljs-string">true</span><br></code></pre></div></td></tr></table></figure><p><strong>Positive matches:（自动配置类启用的：正匹配）</strong></p><p><strong>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</strong></p><p><strong>Unconditional classes: （没有条件的类）</strong></p><h1 id="SpringBoot-Web开发"><a href="#SpringBoot-Web开发" class="headerlink" title="SpringBoot Web开发"></a>SpringBoot Web开发</h1><h2 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h2><h3 id="静态资源映射规则"><a href="#静态资源映射规则" class="headerlink" title="静态资源映射规则"></a>静态资源映射规则</h3><p>SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；有一个方法：addResourceHandlers 添加资源处理</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) &#123;<br>        <span class="hljs-comment">// 已禁用默认资源处理</span><br>        logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 缓存控制</span><br>    Duration cachePeriod = <span class="hljs-keyword">this</span>.resourceProperties.getCache().getPeriod();<br>    CacheControl cacheControl = <span class="hljs-keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();<br>    <span class="hljs-comment">// webjars 配置</span><br>    <span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(<span class="hljs-string">&quot;/webjars/**&quot;</span>)) &#123;<br>        customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="hljs-string">&quot;/webjars/**&quot;</span>)<br>                                             .addResourceLocations(<span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>)<br>                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));<br>    &#125;<br>    <span class="hljs-comment">// 静态资源配置</span><br>    String staticPathPattern = <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern();<br>    <span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;<br>        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)<br>                                             .addResourceLocations(getResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations()))<br>                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源</p><h3 id="什么是webjars-呢？"><a href="#什么是webjars-呢？" class="headerlink" title="什么是webjars 呢？"></a>什么是webjars 呢？</h3><p>Webjars本质就是以jar包的方式引入我们的静态资源 ， 以前要导入一个静态资源文件，直接导入即可。</p><p>使用SpringBoot需要使用Webjars，我们可以去搜索一下：</p><p>网站：<a href="https://www.webjars.org">https://www.webjars.org</a> </p><p>要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>导入完毕，查看webjars目录结构，并访问Jquery.js文件！</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092859.png" alt="image-20210310190140137"></p><p>访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：<a href="http://localhost:8080/webjars/jquery/3.4.1/jquery.js">http://localhost:8080/webjars/jquery/3.4.1/jquery.js</a></p><h3 id="第二种静态资源映射规则"><a href="#第二种静态资源映射规则" class="headerlink" title="第二种静态资源映射规则"></a>第二种静态资源映射规则</h3><p>找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，可以点进去看一下分析：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 进入方法</span><br><span class="hljs-keyword">public</span> String[] getStaticLocations() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.staticLocations;<br>&#125;<br><span class="hljs-comment">// 找到对应的值</span><br><span class="hljs-keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;<br><span class="hljs-comment">// 找到路径</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <br>    <span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>,<br>  <span class="hljs-string">&quot;classpath:/resources/&quot;</span>, <br>    <span class="hljs-string">&quot;classpath:/static/&quot;</span>, <br>    <span class="hljs-string">&quot;classpath:/public/&quot;</span> <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。</p><p>所以得出结论，以下四个目录存放的静态资源可以被我们识别：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span><br><span class="hljs-string">&quot;classpath:/resources/&quot;</span><br><span class="hljs-string">&quot;classpath:/static/&quot;</span><br><span class="hljs-string">&quot;classpath:/public/&quot;</span><br></code></pre></div></td></tr></table></figure><p>可以在resources根目录下新建对应的文件夹，都可以存放静态文件；</p><p>比如访问 <a href="http://localhost:8080/1.js">http://localhost:8080/1.js</a> , 就会去这些文件夹中寻找对应的静态资源文件；</p><h3 id="自定义静态资源路径"><a href="#自定义静态资源路径" class="headerlink" title="自定义静态资源路径"></a>自定义静态资源路径</h3><p>也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.resources.static-locations</span>=<span class="hljs-string">classpath:/coding/,classpath:/kuang/</span><br></code></pre></div></td></tr></table></figure><p>一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效</p><p>总结：</p><p>1.在springboot，我们可以使用以下方式处理静态资源</p><div class="hljs code-wrapper"><pre><code>    - webjars  localhost:8080/wbjars/    - public, static, /**, resource    localhost:8080/</code></pre></div><p>2.优先级：resources &gt; static(默认) &gt; public</p><h2 id="首页如何定制"><a href="#首页如何定制" class="headerlink" title="首页如何定制"></a>首页如何定制</h2><p>欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射</p><p><strong>关于网站图标说明</strong>：</p><p>与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。</p><p>1、关闭SpringBoot默认图标</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#关闭默认图标</span><br><span class="hljs-meta">spring.mvc.favicon.enabled</span>=<span class="hljs-string">false</span><br></code></pre></div></td></tr></table></figure><p>2、自己放一个图标在静态资源目录下，我放在 public 目录下</p><p>3、清除浏览器缓存！刷新网页，发现图标已经变成自己的了</p><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，<br>SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的。<br>那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢，SpringBoot推荐你可以来使用模板引擎。<br>那么这模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有以用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图。</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092910.png" alt="image-20210310171302415"></p><p>模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，我们来组装一些数据，我们把这些数据找到。然后把这个模板和这个数据交给模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想不同模板引擎之间，语法有点不一样。</p><p>主要来介绍一下SpringBoot推荐的Thymeleaf模板引擎，是一个高级语言的模板引擎，语法更简单，功能更强大。</p><h3 id="引入Thymeleaf"><a href="#引入Thymeleaf" class="headerlink" title="引入Thymeleaf"></a>引入Thymeleaf</h3><p>Thymeleaf 官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p><p>Thymeleaf 在Github 的主页：<a href="https://github.com/thymeleaf/thymeleaf">https://github.com/thymeleaf/thymeleaf</a></p><p>Spring官方文档：找到对应的版本</p><p>找到对应的pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--thymeleaf--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="Thymeleaf分析"><a href="#Thymeleaf分析" class="headerlink" title="Thymeleaf分析"></a>Thymeleaf分析</h3><p>找一下Thymeleaf的自动配置类：ThymeleafProperties</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(</span><br><span class="hljs-meta">    prefix = &quot;spring.thymeleaf&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThymeleafProperties</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset DEFAULT_ENCODING;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">&quot;.html&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> checkTemplate = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> checkTemplateLocation = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">private</span> String prefix = <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;<br>    <span class="hljs-keyword">private</span> String suffix = <span class="hljs-string">&quot;.html&quot;</span>;<br>    <span class="hljs-keyword">private</span> String mode = <span class="hljs-string">&quot;HTML&quot;</span>;<br>    <span class="hljs-keyword">private</span> Charset encoding;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以在其中看到默认的前缀和后缀！</p><p>我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。</p><p>使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！</p><p><strong>测试</strong></p><p>1、编写一个TestController</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/t1&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//classpath: /templates/test.html</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test&quot;</span>;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>2、编写一个测试页面  test.html 放在 templates 目录下</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>测试页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>3、启动项目请求测试</p><h3 id="Thymeleaf-语法学习"><a href="#Thymeleaf-语法学习" class="headerlink" title="Thymeleaf 语法学习"></a>Thymeleaf 语法学习</h3><p>Thymeleaf 官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p><p><strong>练习 ：查出一些数据，在页面中展示</strong></p><p>1、修改测试请求，增加数据传输；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/t1&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test1</span><span class="hljs-params">(Model model)</span></span>&#123;<br><br>        <span class="hljs-comment">//存入数据</span><br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;Hello,Thymeleaf&quot;</span>);<br>        <span class="hljs-comment">//classpath: /templates/test.html</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>2、使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。</p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">xmlns:</span>th=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span><br></code></pre></div></td></tr></table></figure><p>3、编写前端页面</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>测试页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>4、启动测试！</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092921.png" alt="image-20210310193957835"></p><p>前端：</p><div class="hljs code-wrapper"><pre><code>- 模板：别人写好的，拿来改成自己需要的          x-admin- 框架：组件：自己手动组合拼接！      Bootstrap，Layui，semantic-ui</code></pre></div><h1 id="整合JDBC"><a href="#整合JDBC" class="headerlink" title="整合JDBC"></a>整合JDBC</h1><p>对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。</p><h2 id="创建测试项目测试数据源"><a href="#创建测试项目测试数据源" class="headerlink" title="创建测试项目测试数据源"></a>创建测试项目测试数据源</h2><p>1、新建一个项目测试：引入Spring Web、JDBC API、MySQL Driver模块</p><p>2、项目建好之后，发现自动帮我们导入了如下的启动器：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>3、编写yaml配置文件连接数据库</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></div></td></tr></table></figure><p>4、配置完这一些东西后，我们就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot04DataApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    DataSource dataSource;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-comment">//查看一下默认的数据源</span><br>        System.out.println(dataSource.getClass());<br><br>        <span class="hljs-comment">//获得数据库连接</span><br>        Connection connection = dataSource.getConnection();<br>        System.out.println(connection);<br><br>        <span class="hljs-comment">//xxxx Template: springboot已经配置好模板bean，拿来即用</span><br><br>        <span class="hljs-comment">//关闭</span><br>        connection.close();<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置</p><p>我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Import(</span><br><span class="hljs-meta">    &#123;Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSourceJmxConfiguration.class&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PooledDataSourceConfiguration</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">PooledDataSourceConfiguration</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；</strong></p><h2 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h2><p>1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库；</p><p>2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。</p><p>3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p><p>4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用</p><p>5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类</p><p><strong>JdbcTemplate主要提供以下几类方法：</strong></p><ul><li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li><li>update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li><li>query方法及queryForXXX方法：用于执行查询相关语句；</li><li>call方法：用于执行存储过程、函数相关语句。</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-comment">//查询数据库的所有信息</span><br>    <span class="hljs-comment">//没有实体类，数据库中的东西，怎么获取</span><br>    <span class="hljs-meta">@GetMapping(&quot;/userList&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; userList()&#123;<br>        String sql = <span class="hljs-string">&quot;select * from mybatis.user&quot;</span>;<br>        List&lt;Map&lt;String, Object&gt;&gt; list_maps = jdbcTemplate.queryForList(sql);<br>        <span class="hljs-keyword">return</span> list_maps;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/addUser&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addUser</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;insert into mybatis.user(id,name,pwd) values (4,&#x27;小明&#x27;,&#x27;123546&#x27;)&quot;</span>;<br>        jdbcTemplate.update(sql);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;update-ok&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/updateUser/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;update mybatis.user set name=?,pwd=? where id=&quot;</span> +id;<br><br>        <span class="hljs-comment">//封装</span><br>        Object[] objects = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">2</span>];<br>        objects[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;小明2&quot;</span>;<br>        objects[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;zzzzz&quot;</span>;<br><br>        jdbcTemplate.update(sql,objects);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;updateUser-ok&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/deleteUser/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;delete from mybatis.user where id =?&quot;</span>;<br>        jdbcTemplate.update(sql,id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;deleteUser-ok&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="集成Druid"><a href="#集成Druid" class="headerlink" title="集成Druid"></a>集成Druid</h1><h2 id="Druid简介"><a href="#Druid简介" class="headerlink" title="Druid简介"></a>Druid简介</h2><p>Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。</p><p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。</p><p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p><p>Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</p><p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。</p><p>Github地址：<a href="https://github.com/alibaba/druid/">https://github.com/alibaba/druid/</a></p><p><strong>com.alibaba.druid.pool.DruidDataSource 基本配置参数如下：</strong></p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092930.png" alt="image-20210317191511450"></p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092939.png" alt="image-20210317191527306"></p><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>1、添加上 Druid 数据源依赖。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--druid --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>2、切换数据源</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>  <span class="hljs-comment">#自定义数据源</span><br></code></pre></div></td></tr></table></figure><p>3、数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换</p><p>4、切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><br><br>    <span class="hljs-comment">#Spring Boot 默认是不注入这些属性值的，需要自己绑定</span><br>    <span class="hljs-comment">#druid 数据源专有配置</span><br>    <span class="hljs-attr">initialSize:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">minIdle:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">maxActive:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span><br>    <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span><br>    <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">poolPreparedStatements:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span><br>    <span class="hljs-comment">#如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span><br>    <span class="hljs-comment">#则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span><br>    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall,log4j</span><br>    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">useGlobalDataSourceStat:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br></code></pre></div></td></tr></table></figure><p>5、导入Log4j 的依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>6、现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建</span><br><span class="hljs-comment">       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效</span><br><span class="hljs-comment">       @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中</span><br><span class="hljs-comment">       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>7、去测试类中测试一下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootDataJdbcApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-comment">//DI注入数据源</span><br>    <span class="hljs-meta">@Autowired</span><br>    DataSource dataSource;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-comment">//看一下默认数据源</span><br>        System.out.println(dataSource.getClass());<br>        <span class="hljs-comment">//获得连接</span><br>        Connection connection =   dataSource.getConnection();<br>        System.out.println(connection);<br><br>        DruidDataSource druidDataSource = (DruidDataSource) dataSource;<br>        System.out.println(<span class="hljs-string">&quot;druidDataSource 数据源最大连接数：&quot;</span> + druidDataSource.getMaxActive());<br>        System.out.println(<span class="hljs-string">&quot;druidDataSource 数据源初始化连接数：&quot;</span> + druidDataSource.getInitialSize());<br><br>        <span class="hljs-comment">//关闭连接</span><br>        connection.close();<br>    &#125;<br></code></pre></div></td></tr></table></figure><h2 id="配置Druid数据源监控"><a href="#配置Druid数据源监控" class="headerlink" title="配置Druid数据源监控"></a>配置Druid数据源监控</h2><p>Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。</p><p>所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//后台监控：web.xml, ServletRegistrationBean</span><br><span class="hljs-comment">// 因为Springboot 内置了servlet容器，所以没有web.xml，替代方法：ServletRegistrationBean</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">statViewServlet</span><span class="hljs-params">()</span></span>&#123;<br>    ServletRegistrationBean&lt;StatViewServlet&gt; bean = <span class="hljs-keyword">new</span> ServletRegistrationBean&lt;&gt;(<span class="hljs-keyword">new</span> StatViewServlet(),<span class="hljs-string">&quot;/druid/*&quot;</span>);<br><br>    <span class="hljs-comment">//后台需要有人登录，账号密码设置</span><br>    HashMap&lt;String,String&gt; initParameters = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">//增加配置</span><br>    initParameters.put(<span class="hljs-string">&quot;loginUsername&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);    <span class="hljs-comment">//登录key 是固定的 loginUsername loginPassword</span><br>    initParameters.put(<span class="hljs-string">&quot;loginPassword&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br><br>    <span class="hljs-comment">//允许谁可以访问</span><br>    initParameters.put(<span class="hljs-string">&quot;allow&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><br>    bean.setInitParameters(initParameters); <span class="hljs-comment">//设置初始化参数</span><br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>配置完毕后，我们可以选择访问 ：<a href="http://localhost:8080/druid/login.html">http://localhost:8080/druid/login.html</a></p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423092954.png" alt="image-20210317192040458"></p><p>进入之后</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423093000.png" alt="image-20210317192051289"></p><p><strong>配置 Druid web 监控 filter 过滤器</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//filter</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">webStatFilter</span><span class="hljs-params">()</span></span>&#123;<br>    FilterRegistrationBean bean = <span class="hljs-keyword">new</span> FilterRegistrationBean();<br>    bean.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());<br><br>    <span class="hljs-comment">//可以过滤哪些请求</span><br>    Map&lt;String, String&gt; initParameters = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">//这些东西不进行统计</span><br>    initParameters.put(<span class="hljs-string">&quot;exclusion&quot;</span>,<span class="hljs-string">&quot;*.js,*.css,/druid/*&quot;</span>);<br><br>    bean.setInitParameters(initParameters);<br><br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="集成SpringSecurity"><a href="#集成SpringSecurity" class="headerlink" title="集成SpringSecurity"></a>集成SpringSecurity</h1><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NTAzMTExNg==&amp;mid=2247483957&amp;idx=1&amp;sn=fc30511490b160cd1519e7a7ee3d4ed0&amp;chksm=ce610496f9168d8082bf6cb2e54b0b8628a1db596c1d297d06e756e621569dc3047334b3062c&amp;mpshare=1&amp;scene=23&amp;srcid=0316LBnvo6caEl8bbi0ACvx8&amp;sharer_sharetime=1615878375777&amp;sharer_shareid=47fe4408d4b588cba6ea4fced90c3d01#rd">https://mp.weixin.qq.com/s?__biz=Mzg2NTAzMTExNg==&amp;mid=2247483957&amp;idx=1&amp;sn=fc30511490b160cd1519e7a7ee3d4ed0&amp;chksm=ce610496f9168d8082bf6cb2e54b0b8628a1db596c1d297d06e756e621569dc3047334b3062c&amp;mpshare=1&amp;scene=23&amp;srcid=0316LBnvo6caEl8bbi0ACvx8&amp;sharer_sharetime=1615878375777&amp;sharer_shareid=47fe4408d4b588cba6ea4fced90c3d01#rd</a></p><p>在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。</p><p>市面上存在比较有名的：==Shiro==，==Spring Security== ！</p><p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。</p><p>Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求</p><p>从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为<strong>功能权限</strong>，<strong>访问权限</strong>，和<strong>菜单权限</strong>。代码会写的非常的繁琐，冗余。</p><p>怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。</p><p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括<strong>用户认证</strong>（Authentication）和<strong>用户授权</strong>（Authorization）两个部分。<u>用户认证指的是验证某个用户是否为系统中的合法主体</u>，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。<u>用户授权指的是验证某个用户是否有权限执行某个操作</u>。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p><p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。</p><h2 id="认识SpringSecurity"><a href="#认识SpringSecurity" class="headerlink" title="认识SpringSecurity"></a>认识SpringSecurity</h2><p>Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！</p><p>记住几个类：</p><ul><li>WebSecurityConfigurerAdapter：自定义Security策略</li><li>AuthenticationManagerBuilder：自定义认证策略</li><li>@EnableWebSecurity：开启WebSecurity模式</li></ul><p>Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。</p><p><strong>“认证”（Authentication）</strong></p><p>身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。</p><p>身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。</p><p> <strong>“授权” （Authorization）</strong></p><p>授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。</p><p>这个概念是通用的，而不是只在Spring Security 中存在。</p><h2 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h2><h2 id="权限控制和注销"><a href="#权限控制和注销" class="headerlink" title="权限控制和注销"></a>权限控制和注销</h2><h2 id="记住我"><a href="#记住我" class="headerlink" title="记住我"></a>记住我</h2><h2 id="定制登录页"><a href="#定制登录页" class="headerlink" title="定制登录页"></a>定制登录页</h2><h1 id="Shrio"><a href="#Shrio" class="headerlink" title="Shrio"></a>Shrio</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Apache Shiro 是 Java 的一个安全框架</li><li>目前，使用 Apache Shiro 的人越来越多，因为它相当简单，对比 Spring Security，可能没有 Spring Security 做的功能强大，但是在实际工作时可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了</li><li>Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境</li><li><p>Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。</p><p>Shiro 的 API 也是非常简单；其基本功能点如下图所示：</p></li></ul><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423093009.png" alt="image-20210317194752535"></p><p><strong>Authentication</strong>：身份认证 / 登录，验证用户是不是拥有相应的身份；</p><p><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p><p><strong>Session</strong> <strong>Management</strong>：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；</p><p><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</p><p><strong>Web Support</strong>：Web 支持，可以非常容易的集成到 Web 环境；</p><p><strong>Caching</strong>：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；</p><p><strong>Concurrency</strong>：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</p><p><strong>Testing</strong>：提供测试支持；</p><p><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</p><p><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</p><p><strong>记住一点，Shiro 不会去维护用户、维护权限；这些需要我们自己去设计 / 提供；然后通过相应的接口注入给 Shiro 即可。</strong></p><p><strong>参考：<a href="https://www.bilibili.com/video/BV1S54y1R7SB">狂神说</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Java后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习</title>
    <link href="/2021/04/22/Spring/"/>
    <url>/2021/04/22/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Spring"><a href="#1、Spring" class="headerlink" title="1、Spring"></a>1、Spring</h1><h2 id="1-1-、简介"><a href="#1-1-、简介" class="headerlink" title="1.1 、简介"></a>1.1 、简介</h2><ul><li>Spring：春天—-&gt;给软件行业带来了春天</li><li>2002，首次推出了Spring框架的雏形：interface21框架！</li><li>Spring框架即以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日，发布了1.0正式版</li><li><em>Rod Johnson</em>，Spring Framework创始人，著名作者。很难想象Rod Johnson的学历，他是悉尼大学的博士，然而专业学不是计算机而是音乐学</li><li>Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合现有的技术框架！</li></ul><ul><li>SSH：Struct2 + Spring + Hibernate！</li><li>SSM：SpringMVC + Sping + Mybatis！</li></ul><p>官网：<a href="https://spring.io/projects/spring-framework#overview">https://spring.io/projects/spring-framework#overview</a></p><p>官方下载地址：<a href="https://repo.spring.io/release/org/springframework/spring">http://repo.spring.io/release/org/springframework/spring</a></p><p>GitHub：<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="1-2-、优点"><a href="#1-2-、优点" class="headerlink" title="1.2 、优点"></a>1.2 、优点</h2><ul><li>Spring是一个开源的免费的框架（容器）</li><li>Spring是一个轻量级的、非入侵式的框架</li><li>控制反转（IOC），面向切面编程（AOP）</li><li>支持事务的处理，对框架整合的支持</li></ul><p>总结：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架</p><h2 id="1-3-、组成"><a href="#1-3-、组成" class="headerlink" title="1.3 、组成"></a>1.3 、组成</h2><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090725.png" alt="image-20210121154020298"></p><h2 id="1-4-、拓展"><a href="#1-4-、拓展" class="headerlink" title="1.4 、拓展"></a>1.4 、拓展</h2><p>在Spring的官网有这个介绍：现代化的java开发！说白就是基于Spring的开发</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090732.png" alt="image-20210121154404827"></p><ul><li>Spring Boot<ul><li>一个快速开发的脚手架</li><li>基于SpringBoot可以快速的开发单个微服务</li><li>约定大于配置！</li></ul></li><li>SpringCloud<ul><li>SpringCloud是基于SpringBoot实现的</li></ul></li></ul><p>因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！</p><p><strong>弊端：发展了太久之后，违背了原来的理念！配置十分繁琐，人称“配置地狱”</strong></p><h1 id="2、IOC理论推导"><a href="#2、IOC理论推导" class="headerlink" title="2、IOC理论推导"></a>2、IOC理论推导</h1><p>1.UserDao 接口</p><p>2.UserDaoImpl 实现类</p><p>3.UserService 业务接口</p><p>4.UserServiceImpl 业务实现类</p><p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！</p><p>我们使用一个set接口实现，已经发生革命性的变化</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> UserDao userDao;<br><br><span class="hljs-comment">//利用set进行动态实现值的注入</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.userDao = userDao;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>之前，程序是主动创建对象，控制权在程序员手上</li><li>使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象</li></ul><p>这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了，系统的耦合性大大降低，从而更加专注的在业务的实现上，这是IOC的原型</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090745.png" alt="image-20210121170827182"></p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090755.png" alt="image-20210121170846076"></p><h2 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h2><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p><p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p><p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p><h1 id="3、HelloSpring"><a href="#3、HelloSpring" class="headerlink" title="3、HelloSpring"></a>3、HelloSpring</h1><h2 id="1-导入Spring相关jar包"><a href="#1-导入Spring相关jar包" class="headerlink" title="1.导入Spring相关jar包"></a>1.导入Spring相关jar包</h2><p>注：spring需要导入commons-logging进行日志记录.我们利用maven，他会自动下载对应的依赖项</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="2-编写相关代码"><a href="#2-编写相关代码" class="headerlink" title="2.编写相关代码"></a>2.编写相关代码</h2><p>2.1编写一个Hello实体类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.acacac.pojo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>2.2编写我们的spring文件，这里我们命名为beans.xml</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 使用Spring来创建对象，在Spring这些都称为Bean</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     类型 变量名 = new 类型();</span><br><span class="hljs-comment">     Hello hello = new Hello();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     id = 变量名</span><br><span class="hljs-comment">     class = new 的对象;</span><br><span class="hljs-comment">     property 相当于给对象中的属性设置一个值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.Hello&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>2.3测试</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//获取Spring的上下文对象</span><br>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>        <span class="hljs-comment">//我们的对象现在都在Spring中的管理了，我们要使用，直接去里面取出来就可以！</span><br>        Hello hello = (Hello) context.getBean(<span class="hljs-string">&quot;hello&quot;</span>);<br>        hello.show();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090806.png" alt="image-20210121210705632"></p><h1 id="4、IOC创建对象的方式"><a href="#4、IOC创建对象的方式" class="headerlink" title="4、IOC创建对象的方式"></a>4、IOC创建对象的方式</h1><p>1.使用无参构造创建对象，默认</p><p>2.假设我们要使用有参构造创建对象</p><p>​        1.下标赋值</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.User&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>​        2.类型赋值</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>​        3.参数名</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了</p><h1 id="5、Spring配置"><a href="#5、Spring配置" class="headerlink" title="5、Spring配置"></a>5、Spring配置</h1><h2 id="5-1、别名"><a href="#5-1、别名" class="headerlink" title="5.1、别名"></a>5.1、别名</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 别名，如果添加了别名，我们也可以使用别名获取到这个对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;userNew&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="5-2、Bean的配置"><a href="#5-2、Bean的配置" class="headerlink" title="5.2、Bean的配置"></a>5.2、Bean的配置</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> id：bean的唯一标识符，也就是相当于我们学的对象名</span><br><span class="hljs-comment"> class：bean对象所对应的全限定名：包名 + 类型</span><br><span class="hljs-comment"> name：也是别名，而且name可以同时取多个别名</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.UserT&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user2,u2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="5-3、import"><a href="#5-3、import" class="headerlink" title="5.3、import"></a>5.3、import</h2><p>这个import，一般用于团队开发使用，他可以将多个配置文件，导入合并一个</p><p>假设，现在项目中有多个人开发，这三个人肤质不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的</p><ul><li><p>张三</p></li><li><p>李四</p></li><li><p>王五</p></li><li><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;beans.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;beans2.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;beans3.xml&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><p>使用的时候直接使用总的配置就可以了</p><h1 id="6、依赖注入"><a href="#6、依赖注入" class="headerlink" title="6、依赖注入"></a>6、依赖注入</h1><h2 id="6-1、构造器注入"><a href="#6-1、构造器注入" class="headerlink" title="6.1、构造器注入"></a>6.1、构造器注入</h2><p>前面已经说过了</p><h2 id="6-2、Set方式注入【重点】"><a href="#6-2、Set方式注入【重点】" class="headerlink" title="6.2、Set方式注入【重点】"></a>6.2、Set方式注入【重点】</h2><ul><li>依赖注入：Set注入<ul><li>依赖：bean对象的创建依赖于容器</li><li>注入：bean对象中的所有属性，由容器来注入</li></ul></li></ul><p>【环境搭建】</p><ul><li><p>1.复杂类型</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>2.真实测试对象</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Address address;<br>    <span class="hljs-keyword">private</span> String[] books;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; hobbies;<br>    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; card;<br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; games;<br>    <span class="hljs-keyword">private</span> String wife;<br>    <span class="hljs-keyword">private</span> Properties info;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>3.beans.xml</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.Student&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 第一种，普通值注入，value --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>4.测试类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>        Student student = (Student)context.getBean(<span class="hljs-string">&quot;student&quot;</span>);<br>        System.out.println(student.getName());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>完善注入</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.Address&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;武汉&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.Student&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 第一种，普通值注入，value --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 第二种，Bean注入，ref --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 数组 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;books&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>红楼梦<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>水浒传<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>西游记<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>三国演义<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--List--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>听歌<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>写代码<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>看电影<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--Map--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234567891211&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;银行卡&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;545435435435435&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--Set--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;games&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>LOL<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BOB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>COC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--null--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wife&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--Properties--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;学号&quot;</span>&gt;</span>20210122<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>www.baidu.com<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="6-3、拓展方式注入"><a href="#6-3、拓展方式注入" class="headerlink" title="6.3、拓展方式注入"></a>6.3、拓展方式注入</h2><p>我们可以使用p命名空间和c命名空间进行注入</p><p>官方解释：</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090826.png" alt="image-20210122160909606"></p><p>使用：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:c</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/c&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--p命名空间注入，可以直接注入属性的值：property--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.User&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;张三&quot;</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">&quot;20&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--c命名空间注入，通过构造器注入：construct-args--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.User&quot;</span> <span class="hljs-attr">c:name</span>=<span class="hljs-string">&quot;李四&quot;</span> <span class="hljs-attr">c:age</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>    ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;userbeans.xml&quot;</span>);<br>    User user = context.getBean(<span class="hljs-string">&quot;user2&quot;</span>,User.class);<br>    System.out.println(user.toString());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意点：p命名和c命名空间不能直接使用，需要导入xml约束</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;<br>xmlns:c=&quot;http://www.springframework.org/schema/c&quot;<br></code></pre></div></td></tr></table></figure><h2 id="6-4、bean的作用域"><a href="#6-4、bean的作用域" class="headerlink" title="6.4、bean的作用域"></a>6.4、bean的作用域</h2><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090840.png" alt="image-20210122161358630"></p><p>1.单例模式（Spring默认机制）</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.User&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;张三&quot;</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><p>2.原型模式：每次从容器中get的时候，都会产生一个新对象</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.User&quot;</span> <span class="hljs-attr">c:name</span>=<span class="hljs-string">&quot;李四&quot;</span> <span class="hljs-attr">c:age</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><p>3.其余的request、session、application这些个都只能在web开发中使用到</p><h1 id="7、Bean的自动装配"><a href="#7、Bean的自动装配" class="headerlink" title="7、Bean的自动装配"></a>7、Bean的自动装配</h1><ul><li>自动装配是Spring满足Bean依赖的一种方式</li><li>Spring会在上下文中自动寻找，并自动给bean装配属性</li></ul><p>在Spring中有三种自动装配的方式</p><ul><li>1.在Spring中有三种装配的方式</li><li>2.在java中显示配置</li><li>3.隐式的自动装配bean【重要】</li></ul><h2 id="7-1、测试"><a href="#7-1、测试" class="headerlink" title="7.1、测试"></a>7.1、测试</h2><p>环境搭建：一个人有两个宠物</p><h2 id="7-2、ByName自动装配"><a href="#7-2、ByName自动装配" class="headerlink" title="7.2、ByName自动装配"></a>7.2、ByName自动装配</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">byName：会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.Person&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ac&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="7-3、ByType自动装配"><a href="#7-3、ByType自动装配" class="headerlink" title="7.3、ByType自动装配"></a>7.3、ByType自动装配</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.Cat&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.Dog&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">byName：会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid</span><br><span class="hljs-comment">byType：会自动在容器上下文中查找，和自己对象属性类型相同的的bean</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.pojo.Person&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ac&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>小结：</p><ul><li>byname的时候，需要保证所有的bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致</li><li>bytype的时候，需要保证所有的bean的class唯一，并且这个bean需要和自动注入的属性的类型一致</li></ul><h2 id="7-4、使用注解实现自动装配"><a href="#7-4、使用注解实现自动装配" class="headerlink" title="7.4、使用注解实现自动装配"></a>7.4、使用注解实现自动装配</h2><p>jdk1.5支持的注解，Spring2.5就支持注解了</p><p>The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. </p><p>要使用注解须知：</p><ul><li><p>1.导入约束。 context约束</p></li><li><p><strong><u>2.配置注解的支持：<context:annotation-config></context:annotation-config></u></strong>    <strong>【重要】</strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>@Autowired</p><p>直接在属性上使用即可，也可以在set方式上使用</p><p>使用Autowired我们可以不用编写Set方法了，前提是你这个自动装配的属性在IOC（Spring）容器中存在，且符合名字byname</p><p>科普：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">@Nullable字段标记了这个注解，说明这个字段可以为null<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Autowired &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-comment">//如果显示定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空</span><br>    <span class="hljs-meta">@Autowired(required = false)</span><br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Dog dog;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier(value=”xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">//如果显示定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(value = &quot;cat111&quot;)</span><br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(value = &quot;dog123&quot;)</span><br>    <span class="hljs-keyword">private</span> Dog dog;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>@Resource注解</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-meta">@Resource(name = &quot;cat2&quot;)</span><br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> Dog dog;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>小结：</p><p>@Resource和@Autowired的区别：</p><ul><li>都是用来自动装配的，都可以放在属性字段上</li><li>@Autowired默认按<strong>byType</strong>装配（这个注解是属于spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false。如果Autowired不能唯一自动装配上属性，则需要@Qualifier(value = “xxx”)</li><li>@Resource（这个注解属于J2EE的），默认按照<strong>byName</strong>进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</li><li>执行顺序不同：@Autowired通过byType的方式实现   @Resource默认通过哦byName的方式实现</li><li>推荐使用：@Resource注解在字段上，这样就不用写setter方法了，并且这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅。</li></ul></li></ul><h1 id="8、使用注解开发"><a href="#8、使用注解开发" class="headerlink" title="8、使用注解开发"></a>8、使用注解开发</h1><p>在Spring4之后，要使用注解开发，必须保证app的包导入了</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090853.png" alt="image-20210123104028014"></p><p>使用注解需要导入context约束，增加注解的支持</p><p>1.bean</p><p>2.属性如何注入</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-comment">//相当于 &lt;property name=&quot;name&quot; value=&quot;123&quot;&gt;</span><br>    <span class="hljs-meta">@Value(&quot;123&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>3.衍生的注解</p><p>​    @Component有几个衍生注解，我们在web开发中，会按照mvc三层架构分层</p><ul><li><p>dao    【@Repository】</p></li><li><p>service   【@Service】</p></li><li><p>controller   【@Controller】</p><p>这四个注解功能是一样的，都是代表将某个类注册到Spring中，装配Bean</p></li></ul><p>4.自动装配置</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">- <span class="hljs-meta">@Autowired</span>：自动装配通过类型，名字<br>    如果Autowired不能唯一自动装配上属性，则需要通过<span class="hljs-meta">@Qualifier(value=<span class="hljs-meta-string">&quot;xxx&quot;</span>)</span><br>- <span class="hljs-meta">@Nullable</span>   字段标记了这个注解，说明这个字段可以为<span class="hljs-literal">null</span><br>- <span class="hljs-meta">@Resource</span>   自动装配通过名字，类型<br></code></pre></div></td></tr></table></figure><p>5.作用域</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-comment">//相当于 &lt;property name=&quot;name&quot; value=&quot;123&quot;&gt;</span><br>    <span class="hljs-meta">@Value(&quot;123&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>6.小结</p><p>xml与注解：</p><div class="hljs code-wrapper"><pre><code>* xml更加万能，适用于任何场合，维护简单方便* 注解 不是自己的类使用不了，维护相对复杂</code></pre></div><p>xml与注解最佳实践</p><div class="hljs code-wrapper"><pre><code>* xml用来管理Bean* 注解只负责完成属性的注入* 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启对注解的支持</code></pre></div><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.acacac&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><h1 id="9、使用Java的方式配置Spring"><a href="#9、使用Java的方式配置Spring" class="headerlink" title="9、使用Java的方式配置Spring"></a>9、使用Java的方式配置Spring</h1><p>我们现在完全不使用Spring的xml配置了，全权交给Java来做</p><p>JavaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090904.png" alt="image-20210123115219957"></p><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//这里这个注解的意思，就是说明这个类被Spring接管了，注册到了容器中</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Value(&quot;qwe&quot;)</span> <span class="hljs-comment">//属性注入值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>配置文件</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.acacac.pojo.config;<br><br><span class="hljs-keyword">import</span> com.acacac.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Import;<br><br><span class="hljs-comment">//这个也会被Spring容器接管，注册到容器中，因为它本来就是一个@Component，</span><br><span class="hljs-comment">//@Configuration代表这是一个配置类，就和我们之前看的beans.xml一样</span><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.acacac.pojo&quot;)</span><br><span class="hljs-meta">@Import(TestConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">//注册一个bean，就相当于我们之前写的一个bean标签</span><br>    <span class="hljs-comment">//这个方法的名字，就相当于bean标签中的id属性</span><br>    <span class="hljs-comment">//这个方法的返回值，就相当于bean标签中的class属性</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();  <span class="hljs-comment">//就是返回要注入bean的对象</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//如果完全使用了配置类的方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载</span><br>        ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(TestConfig.class);<br>        User getUser = context.getBean(<span class="hljs-string">&quot;user&quot;</span>,User.class);<br>        System.out.println(getUser.getName());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种纯Java的配置方式，在SpringBoot中随处可见</p><h1 id="10、代理模式"><a href="#10、代理模式" class="headerlink" title="10、代理模式"></a>10、代理模式</h1><p>为什么要学习代理模式？因为这就是SpringAOP的底层  【SpringAOP和SpringMVC】</p><p>代理模式的分类：</p><ul><li>静态代理</li><li>动态代理</li></ul><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090915.png" alt="image-20210124092423271"></p><h2 id="10-1、静态代理"><a href="#10-1、静态代理" class="headerlink" title="10.1、静态代理"></a>10.1、静态代理</h2><p>角色分析：</p><ul><li>抽象角色：一般会使用接口或者抽象类来解决</li><li>真实角色：被代理的角色</li><li>代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作</li><li>客户：访问代理对象的人</li></ul><p>代码步骤：</p><p>1.接口</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//租房</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Rent</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rent</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>2.真实角色</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//房东</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Host</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rent</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;房东要出租房子&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>3.代理角色</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> Host host;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Proxy</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Proxy</span><span class="hljs-params">(Host host)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.host = host;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rent</span><span class="hljs-params">()</span> </span>&#123;<br>        seeHouse();<br>        host.rent();<br>        heTong();<br>        fare();<br>    &#125;<br><br>    <span class="hljs-comment">//看房</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">seeHouse</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;中介带你看房&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//收中介费</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fare</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收中介费&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//签合同</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heTong</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;签租赁合同&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>4.客户端访问代理角色</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//房东要租房子</span><br>        Host host = <span class="hljs-keyword">new</span> Host();<br>        <span class="hljs-comment">//代理，中介帮房租租房子</span><br>        Proxy proxy = <span class="hljs-keyword">new</span> Proxy(host);<br>        <span class="hljs-comment">//不用面对房东，直接找中介租房</span><br>        proxy.rent();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代理模式的好处：</p><ul><li>可以使真实角色的操作更加纯粹，不用去关注一些公共的业务</li><li>公共业务交给代理角色，实现了业务的分工</li><li>公共业务发生扩展的时候，方便集中管理</li></ul><p>缺点：</p><ul><li>一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低</li></ul><h2 id="10-2、加深理解"><a href="#10-2、加深理解" class="headerlink" title="10.2、加深理解"></a>10.2、加深理解</h2><p>代码：对应08-demo02</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090925.png" alt="image-20210124103455415"></p><h2 id="10-3、动态代理"><a href="#10-3、动态代理" class="headerlink" title="10.3、动态代理"></a>10.3、动态代理</h2><ul><li>动态代理和静态代理角色一样</li><li>动态代理的代理类是动态生成的，不是我们直接写好的</li><li>动态代理分为两大类：基于接口的动态代理，基于类的动态代理<ul><li>基于接口—-JDK动态代理 【我们在这里使用】</li><li>基于类：cglib</li><li>java字节码实现：javasist</li></ul></li></ul><p>需要了解两个类：Proxy，InvokationHandler：</p><p>动态代理的好处：</p><ul><li>可以使真实角色的操作更加纯粹，不用去关注一些公共的业务</li><li>公共业务交给代理角色，实现了业务的分工</li><li>公共业务发生扩展的时候，方便集中管理</li><li>一个动态代理类代理的是一个接口，一般就是对应的一类业务</li><li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可</li></ul><h1 id="11、AOP"><a href="#11、AOP" class="headerlink" title="11、AOP"></a>11、AOP</h1><h2 id="11-1、什么是-AOP"><a href="#11-1、什么是-AOP" class="headerlink" title="11.1、什么是 AOP"></a>11.1、什么是 AOP</h2><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p><img src="/2021/04/22/Spring/Users\Administrator\Desktop\640.png" alt="640"></p><h2 id="11-2、AOP在Spring中的作用"><a href="#11-2、AOP在Spring中的作用" class="headerlink" title="11.2、AOP在Spring中的作用"></a>11.2、AOP在Spring中的作用</h2><p>==提供声明式事务；允许用户自定义切面==</p><p>==以下名词需要了解下：==</p><ul><li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</li><li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li><li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</li><li>目标（Target）：被通知对象。</li><li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li><li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li><li>连接点（JointPoint）：与切入点匹配的执行点。</li></ul><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090945" alt="图片"></p><p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090953" alt="图片"></p><p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p><h2 id="11-3、使用Spring实现AOP"><a href="#11-3、使用Spring实现AOP" class="headerlink" title="11.3、使用Spring实现AOP"></a>11.3、使用Spring实现AOP</h2><p>【重点】使用AOP织入，需要导入一个依赖包！</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>第一种方式</strong></p><p><strong>通过 Spring API 实现</strong></p><p>首先编写我们的业务接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span>&#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;增加用户&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span> </span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;删除用户&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;更新用户&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">()</span> </span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;查询用户&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Log</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> </span>&#123;<br><br>   <span class="hljs-comment">//method : 要执行的目标对象的方法</span><br>   <span class="hljs-comment">//objects : 被调用的方法的参数</span><br>   <span class="hljs-comment">//Object : 目标对象</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>       System.out.println( o.getClass().getName() + <span class="hljs-string">&quot;的&quot;</span> + method.getName() + <span class="hljs-string">&quot;方法被执行了&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfterLog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AfterReturningAdvice</span> </span>&#123;<br>   <span class="hljs-comment">//returnValue 返回值</span><br>   <span class="hljs-comment">//method被调用的方法</span><br>   <span class="hljs-comment">//args 被调用的方法的对象的参数</span><br>   <span class="hljs-comment">//target 被调用的目标对象</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;执行了&quot;</span> + target.getClass().getName()<br>       +<span class="hljs-string">&quot;的&quot;</span>+method.getName()+<span class="hljs-string">&quot;方法,&quot;</span><br>       +<span class="hljs-string">&quot;返回值：&quot;</span>+returnValue);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/aop</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!--注册bean--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.service.UserServiceImpl&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.log.Log&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.log.AfterLog&quot;</span>/&gt;</span><br><br>   <span class="hljs-comment">&lt;!--aop的配置--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--切入点 expression:表达式匹配要执行的方法--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span><br>       <span class="hljs-comment">&lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>       ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>       UserService userService = (UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>       userService.search();<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p><p>==Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .== </p><p><strong>第二种方式</strong></p><p><strong>自定义类来实现Aop</strong></p><p>目标业务类不变依旧是userServiceImpl</p><p>第一步 : 写我们自己的一个切入类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiyPointcut</span> </span>&#123;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;---------方法执行前---------&quot;</span>);<br>  &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;---------方法执行后---------&quot;</span>);<br>  &#125;<br>   <br>&#125;<br></code></pre></div></td></tr></table></figure><p>去spring中配置</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第二种方式自定义实现--&gt;</span><br><span class="hljs-comment">&lt;!--注册bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;diy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.config.DiyPointcut&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--aop的配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--第二种方式：使用AOP的标签实现--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;diy&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;diyPonitcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;diyPonitcut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;diyPonitcut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>       ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>       UserService userService = (UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>       userService.add();<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>第三种方式</strong></p><p><strong>使用注解实现</strong></p><p>第一步：编写一个注解实现的增强类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.config;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationPointcut</span> </span>&#123;<br>   <span class="hljs-meta">@Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;---------方法执行前---------&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;---------方法执行后---------&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint jp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;环绕前&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;签名:&quot;</span>+jp.getSignature());<br>       <span class="hljs-comment">//执行目标方法proceed</span><br>       Object proceed = jp.proceed();<br>       System.out.println(<span class="hljs-string">&quot;环绕后&quot;</span>);<br>       System.out.println(proceed);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第三种方式:注解实现--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;annotationPointcut&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.diy.AnnotationPointCut&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--开启注解支持--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><p>aop:aspectj-autoproxy：说明</p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">通过aop命名空间的<span class="hljs-variable">&lt;aop:aspectj-autoproxy /&gt;</span>声明自动为spring容器中那些配置<span class="hljs-meta">@aspectJ切面的bean创建代理，织入切面。当然，spring</span> 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被<span class="hljs-variable">&lt;aop:aspectj-autoproxy /&gt;</span>隐藏起来了<br></code></pre></div></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objectivec">&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-<span class="hljs-keyword">class</span>属性，默认为<span class="hljs-literal">false</span>，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;时，表示使用<span class="hljs-built_in">CGLib</span>动态代理技术织入增强。不过即使proxy-target-<span class="hljs-keyword">class</span>设置为<span class="hljs-literal">false</span>，如果目标类没有声明接口，则spring将自动使用<span class="hljs-built_in">CGLib</span>动态代理。<br></code></pre></div></td></tr></table></figure><h1 id="12、整合Mybatis"><a href="#12、整合Mybatis" class="headerlink" title="12、整合Mybatis"></a>12、整合Mybatis</h1><p>步骤：</p><p>1.导入相关jar包</p><ul><li>junit</li><li>mybatis</li><li>mysql数据库</li><li>spring相关</li><li>aop织入</li><li>mybatis-spring  【new】</li></ul><p>2.编写配置文件</p><p>3.测试</p><h2 id="12-1、回忆mybatis"><a href="#12-1、回忆mybatis" class="headerlink" title="12.1、回忆mybatis"></a>12.1、回忆mybatis</h2><p>1.编写实体类</p><p>2.编写核心配置文件</p><p>3.编写接口</p><p>4.编写Mapper.xml</p><p>5.测试</p><h2 id="12-2、Mybatis-Spring"><a href="#12-2、Mybatis-Spring" class="headerlink" title="12.2、Mybatis-Spring"></a>12.2、Mybatis-Spring</h2><p>1.编写数据源配置</p><p>2.sqlSessionFactory</p><p>3.sqlSessionTemplate</p><p>4.需要给接口加实现类【】</p><p>5.将自己写的实现类，注入到Spring中</p><p>6.测试</p><h1 id="13、声明式事务"><a href="#13、声明式事务" class="headerlink" title="13、声明式事务"></a>13、声明式事务</h1><h2 id="1、回顾事务"><a href="#1、回顾事务" class="headerlink" title="1、回顾事务"></a>1、回顾事务</h2><ul><li>把一组业务当成一个业务来做，要么都成功，要么都失败</li><li>事务在项目开发中，十分重要，涉及到数据的一致性问题</li><li>确保完整性和一致性</li></ul><p>事务ACID原则：</p><ul><li>原子性</li><li>一致性</li><li>隔离性<ul><li>多个业务可能操作同一个资源，防止数据损坏</li></ul></li><li>持久性<ul><li>事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中</li></ul></li></ul><p><strong>参考：<a href="https://www.bilibili.com/video/BV1S54y1R7SB">狂神说</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Java后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC学习</title>
    <link href="/2021/04/22/SpringMVC/"/>
    <url>/2021/04/22/SpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>ssm: mybatis+Spring+SpringMVC   <strong>MVC三层架构</strong></p><p>MVC：模型（dao，service）视图（jsp）控制器（Servlet）</p><p>SpringMVC的特点：</p><ul><li>1.轻量级，简单易学</li><li>2.高效，基于请求响应的MVC框架</li><li>3.与Spring兼容性好，无缝结合</li><li>4.约定大于配置</li><li>5.功能强大：RESTful、数据验证、格式化、本地化、主题等</li><li>6.简洁灵活</li></ul><p>Spring：大杂烩，我们可以将SpringMVC中所有要用到的bean，注册到Spring中</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090643.png" alt="image-20210223111906096"></p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090653.png" alt="image-20210223112126827"></p><p>SpringMVC流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/20210423090703.png" alt="image-20210223112150791"></p><p><strong>简要分析执行流程</strong></p><ul><li><p>1.DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求</p><ul><li>我们假设请求的url为：<a href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></li><li>如上url拆为三部分：</li><li><a href="http://localhost:8080服务器域名">http://localhost:8080服务器域名</a></li><li>SpringMVC部署在服务器上的web站点</li><li>hello表示控制器</li><li>通过分析，如上url表示为：请求位于服务器localhost:8080的SpringMVC站点的hello控制器</li></ul></li><li><p>2.HandlerMapping为处理器映射。DispatchServlet调用</p><p>HandkerMapping, HandlerMapping根据请求url查找Handler</p></li><li><p>3.HandlerExecution表示具体的Handler，其主要作用是根据url查找控制器，如上url被查找控制器为：hello</p></li><li><p>4.HandlerExecution将解析后的信息传递给DispatcherServlet，如解析控制器映射等</p></li><li><p>5.HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler</p></li><li><p>6.Handler让具体的Controller执行</p></li></ul><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置DispatcherServlet：这个是SpringMVC的核心；请求分发器，前端控制器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--DispatcherServlet要绑定Spring的配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--启动级别：1--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">在SpringMVC中，//*</span><br><span class="hljs-comment">/：只匹配所有请求，不会去匹配jsp页面</span><br><span class="hljs-comment">/*：匹配所有请求，包括jsp页面</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>==在SpringMVC中，/    /<em>==<br>==/：只匹配所有请求，不会去匹配jsp页面==<br>==/</em>：匹配所有请求，包括jsp页面==</p><h1 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h1><p>springmvc-servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--自动扫描播包，让指定包下的注解生效，由IOC容器统一管理--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.ac.controller&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">支持mvc注解驱动</span><br><span class="hljs-comment">在spring中一般采用@RequestMapping注解来完成映射关系</span><br><span class="hljs-comment">要想使@RequestMapping注解生效</span><br><span class="hljs-comment">必须向上下文中注册DefaultAnnotationHandlerMapping</span><br><span class="hljs-comment">和一个AnnotationMethodHandlerAdapter实例</span><br><span class="hljs-comment">这两个实例分别在类级别和方法级别处理</span><br><span class="hljs-comment">而annotation-driven配置帮助我们自动完成上述两个实例的注入</span><br><span class="hljs-comment">--&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--视图解析器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;internalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>小结</strong></p><ul><li>1.新建一个web项目</li><li>2.导入相关jar包</li><li>3.编写web.xml，注册DispatchServlet</li><li>4.编写springmvc配置文件</li><li>5.接下来就是去创建对应的控制类，controller</li><li>6.最后完善前端视图和controller之间的对应</li><li>7.测试运行调试</li></ul><p>使用springMVC必须配置的三大件：</p><p><strong>处理器映射器、处理器适配器、视图解析器</strong></p><p>通常我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置</p><h1 id="SpringMVC：Controller及RestFul风格"><a href="#SpringMVC：Controller及RestFul风格" class="headerlink" title="SpringMVC：Controller及RestFul风格"></a>SpringMVC：Controller及RestFul风格</h1><p><strong>控制器Controller</strong></p><ul><li>控制器复杂提供访问应用程序的行为，通常通过接口定义或==注解==定义两种方法实现</li><li>控制器负责解析用户的请求并将其转换为一个模型</li><li>在SpringMVC中的一个控制器类可以包含多个方法</li><li>在SpringMVC中，对于Controller的配置方法有很多种</li></ul><h2 id="实现Controller接口"><a href="#实现Controller接口" class="headerlink" title="实现Controller接口"></a><strong>实现Controller接口</strong></h2><p>Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//只要实现了Controller接口的类，说明这就是一个控制器了</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControllerTest1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;ControllerTest1&quot;</span>);<br>        mv.setViewName(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>实现接口Controller定义控制器是较老的办法</li><li>缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦</li></ul><h2 id="使用注解-Controller"><a href="#使用注解-Controller" class="headerlink" title="使用注解@Controller"></a><strong>使用注解@Controller</strong></h2><ul><li><p>@Controller注解类型用于声明Spring类的实例是一个控制器（在学IOC时还有另外3个注解）；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> 组件<br><span class="hljs-meta">@Service</span> service<br><span class="hljs-meta">@Controller</span> controller<br><span class="hljs-meta">@Repository</span> dao<br></code></pre></div></td></tr></table></figure></li><li><p>Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--自动扫描指定的包，下面所有注解类交给IOC容器管理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.ac.controller&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>增加一个ControllerTest2类，使用注解实现：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//@Controller注解的类会自动添加到Spring上下文中</span><br><span class="hljs-meta">@Controller</span> <span class="hljs-comment">//代表这个类会被Spring接管，这个被注解的类中的方法，如果返回值是String，并且有具体页面可以跳转，那么就会被视图解析器解析</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControllerTest2</span> </span>&#123;<br>    <br>    <span class="hljs-comment">//映射访问路径</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/t2&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        <span class="hljs-comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span><br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;ControllerTest2&quot;</span>);<br>        <span class="hljs-comment">//返回视图位置</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>运行Tomcat测试</p></li></ul><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a><strong>RequestMapping</strong></h2><ul><li><p>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上，用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径</p></li><li><p>为了测试结论更加准确，我们可以加上一个项目名测试 myweb</p></li><li><p>只注解在方法上面</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControllerTest3</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/t1&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test1</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;ControllerTest3&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>同时注解类和方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/c3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControllerTest3</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/t1&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test1</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;ControllerTest3&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="RestFul风格"><a href="#RestFul风格" class="headerlink" title="RestFul风格"></a>RestFul风格</h2><p>概念</p><p>RestFul就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制</p><p>功能</p><ul><li>资源：互联网所有的事物都可以被抽象为资源</li><li>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作</li><li>分别对应添加、删除、修改、查询</li></ul><p><strong>传统方式操作资源</strong>：通过不同的参数来实现不同的效果！方法单一，post和get</p><ul><li><a href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询，GET</li><li><a href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增，POST</li><li><a href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新，POST</li><li><a href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除，GET或POST</li></ul><p><strong>使用RestFul操作资源</strong>：可以通过不同的请求方式来实现不同的效果！如下：请求地址是一样的，但功能可以不同</p><ul><li><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询，GET</li><li><a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增，POST</li><li><a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新，PUT</li><li><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除，DELETE</li></ul><h1 id="重定向和转发"><a href="#重定向和转发" class="headerlink" title="重定向和转发"></a>重定向和转发</h1><p>重定向不需要视图解析器，本质就是重新请求一个新地方</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/image-20210226162647357.png" alt></p><h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h2 id="处理提交数据"><a href="#处理提交数据" class="headerlink" title="处理提交数据"></a>处理提交数据</h2><p>1.提交的域名称和处理方法的参数名一致</p><p>2.提交的域名称和处理方法的参数名不一致</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/t1&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test1</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String name, Model model)</span></span>&#123;<br>    <span class="hljs-comment">//1.接收前端参数</span><br>    System.out.println(<span class="hljs-string">&quot;接收前端的参数为：&quot;</span>+name);<br>    <span class="hljs-comment">//2.将返回的结果传递给前端</span><br>    model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,name);<br><br>    <span class="hljs-comment">//3.视图跳转</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-meta">@RequestParam</span>注解<br></code></pre></div></td></tr></table></figure><p>3.提交的是一个对象</p><p>​    要求提交的表单域和对象的属性名一致，参数使用对象即可</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//前端接收的是一个对象：id, name, age</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1.接收端用户传递的参数，判断参数的名字，假设名字直接在方法上，可以直接使用</span><br><span class="hljs-comment">    2.假设传递的是一个对象User，匹配User对象中的字段名；如果名字一致则OK，否则，匹配不到</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@GetMapping(&quot;/t2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test2</span><span class="hljs-params">(User user)</span></span>&#123;<br>    System.out.println(user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​    说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null</p><h2 id="数据显示到前端"><a href="#数据显示到前端" class="headerlink" title="数据显示到前端"></a>数据显示到前端</h2><p><strong>第一种：通过ModelAndView</strong></p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/image-20210226171121875.png" alt="image-20210226171121875"></p><p><strong>第二种：通过ModelMap</strong></p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/image-20210226171153214.png" alt="image-20210226171153214"></p><p><strong>第三种：通过Model</strong></p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/image-20210226171207434.png" alt="image-20210226171207434"></p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams">LinkedHashMap：<br><br>ModelMap：继承了LinkedHashMap，所有他拥有LinkedHashMap的全部功能<br><br><span class="hljs-keyword">Model</span>：精简版（大部分情况，我们都直接使用<span class="hljs-keyword">Model</span>）<br></code></pre></div></td></tr></table></figure><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><ul><li>JSON(JavaScript object Notation, JS对象标记)是一种轻量级的数据交换格式，目前使用特别广泛。</li><li>采用完全独立于编程语言的<strong>文本格式</strong>来存储和表示数据。</li><li>简洁和清晰的层次结构使得JSON成为理想的数据交换语言。</li><li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li></ul><p>在JavaScript语言中，一切都是对象。因此，任何JavaScript支持的类型都可以通过JSON来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p><ul><li>对象表示为键值对，数据由逗号分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ul><p><strong>JSON键值对</strong>是用来保存JavaScript对象的一种方式，和JavaScript对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号””包裹，使用冒号∶分隔，然后紧接着值:</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;zhangsan&quot;</span>&#125;<br>&#123;<span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>&#125;<br>&#123;<span class="hljs-attr">&quot;sex&quot;</span> <span class="hljs-attr">&quot;男&quot;</span>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>JSON是JavaScript对象的字符串表示法，它使用文本表示一个JS对象的信息，本质是一个字符串。</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/image-20210226174047022.png" alt="image-20210226174047022"></p></li></ul><p><strong>JSON和JavaScript对象互转</strong></p><ul><li><p>要实现从JSON字符串转换为JavaScript对象，使用JSON.parse()方法:</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/image-20210226174155056.png" alt="image-20210226174155056"></p></li><li><p>要实现从JavaScript对象转换为JSON字符串，使用JSON.stringify()方法:</p><p><img src="https://raw.githubusercontent.com/acacac13/picBed/master/image-20210226174216293.png" alt="image-20210226174216293"></p></li></ul><h2 id="Controller返回JSON数据"><a href="#Controller返回JSON数据" class="headerlink" title="Controller返回JSON数据"></a>Controller返回JSON数据</h2><ul><li>Jackson应该是目前比较好的json解析工具了</li><li>当然工具不止这一个，比如还有阿里巴巴的fastjson等等</li><li>我们这里使用Jackson，使用它需要导入它的jar包</li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li><p>配置SpringMVC需要的配置</p><p>web.xml</p></li><li><p>出现乱码问题，需要设置一下他的编码格式为utf-8，以及返回类型</p></li><li><p>通过@RequestMaping的produces属性来实现，修改下代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//produces：指定响应体返回类型和编码</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/j1&quot;,produces = &quot;application/json;charset=utf-8&quot;)</span><br></code></pre></div></td></tr></table></figure></li></ul><p>==【注意：使用json记得处理乱码问题】==</p><p><strong>乱码优化</strong></p><p>乱码统一解决</p><p>上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了!<br>我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置!</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--JSON乱码问题配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span> <span class="hljs-attr">register-defaults</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;objectMapper&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;failOnEmptyBeans&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h1 id="整合SSM框架"><a href="#整合SSM框架" class="headerlink" title="整合SSM框架"></a>整合SSM框架</h1><h2 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h2><p>创建一个存放书籍数据的数据库表</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE `ssmbuild`;<br><br>USE `ssmbuild`;<br><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `books`;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `books` (<br>`bookID` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;书id&#x27;</span>,<br>`bookName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;书名&#x27;</span>,<br>`bookCounts` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;数量&#x27;</span>,<br>`detail` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;描述&#x27;</span>,<br>KEY `bookID` (`bookID`)<br>) ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><br><span class="hljs-keyword">INSERT</span>  <span class="hljs-keyword">INTO</span> `books`(`bookID`,`bookName`,`bookCounts`,`detail`)<span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;从入门到放弃&#x27;</span>),<br>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;MySQL&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;从删库到跑路&#x27;</span>),<br>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Linux&#x27;</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;从进门到进牢&#x27;</span>);<br></code></pre></div></td></tr></table></figure><h2 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h2><p>1、新建一Maven项目！ssmbuild ， 添加web的支持</p><p>2、导入相关的pom依赖！</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--Junit--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--数据库驱动--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-comment">&lt;!-- 数据库连接池 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!--Servlet - JSP --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!--Mybatis--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!--Spring--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>3、Maven资源过滤设置</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>4、建立基本结构和配置框架！</p><ul><li><p>com.kuang.pojo</p></li><li><p>com.kuang.dao</p></li><li><p>com.kuang.service</p></li><li><p>com.kuang.controller</p></li><li><p>mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">       <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">       <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><h2 id="Mybatis层编写"><a href="#Mybatis层编写" class="headerlink" title="Mybatis层编写"></a>Mybatis层编写</h2><p>1、数据库配置文件 <strong>database.properties</strong></p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">jdbc.driver</span> = <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-meta">jdbc.url</span> = <span class="hljs-string">jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-meta">jdbc.user</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">jdbc.password</span>=<span class="hljs-string">root</span><br></code></pre></div></td></tr></table></figure><p>2、IDEA关联数据库</p><p>3、编写MyBatis的核心配置文件</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">       <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">       <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>   <br>   <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kuang.pojo&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/kuang/dao/BookMapper.xml&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>4、编写数据库对应的实体类 com.kuang.pojo.Books</p><p>使用lombok插件！</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.pojo;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Books</span> </span>&#123;<br>   <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> bookID;<br>   <span class="hljs-keyword">private</span> String bookName;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> bookCounts;<br>   <span class="hljs-keyword">private</span> String detail;<br>   <br>&#125;<br></code></pre></div></td></tr></table></figure><p>5、编写Dao层的 Mapper接口！</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.dao;<br><br><span class="hljs-keyword">import</span> com.kuang.pojo.Books;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookMapper</span> </span>&#123;<br><br>   <span class="hljs-comment">//增加一个Book</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Books book)</span></span>;<br><br>   <span class="hljs-comment">//根据id删除一个Book</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteBookById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br><br>   <span class="hljs-comment">//更新Book</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateBook</span><span class="hljs-params">(Books books)</span></span>;<br><br>   <span class="hljs-comment">//根据id查询,返回一个Book</span><br>   <span class="hljs-function">Books <span class="hljs-title">queryBookById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br><br>   <span class="hljs-comment">//查询全部Book,返回list集合</span><br>   <span class="hljs-function">List&lt;Books&gt; <span class="hljs-title">queryAllBook</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>6、编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包；</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">       <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">       <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kuang.dao.BookMapper&quot;</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!--增加一个Book--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addBook&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Books&quot;</span>&gt;</span><br>      insert into ssmbuild.books(bookName,bookCounts,detail)<br>      values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;)<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!--根据id删除一个Book--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteBookById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>      delete from ssmbuild.books where bookID=#&#123;bookID&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!--更新Book--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBook&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Books&quot;</span>&gt;</span><br>      update ssmbuild.books<br>      set bookName = #&#123;bookName&#125;,bookCounts = #&#123;bookCounts&#125;,detail = #&#123;detail&#125;<br>      where bookID = #&#123;bookID&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!--根据id查询,返回一个Book--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBookById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Books&quot;</span>&gt;</span><br>      select * from ssmbuild.books<br>      where bookID = #&#123;bookID&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!--查询全部Book--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryAllBook&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Books&quot;</span>&gt;</span><br>      SELECT * from ssmbuild.books<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>7、编写Service层的接口和实现类</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.service;<br><br><span class="hljs-keyword">import</span> com.kuang.pojo.Books;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">//BookService:底下需要去实现,调用dao层</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookService</span> </span>&#123;<br>   <span class="hljs-comment">//增加一个Book</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Books book)</span></span>;<br>   <span class="hljs-comment">//根据id删除一个Book</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteBookById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br>   <span class="hljs-comment">//更新Book</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateBook</span><span class="hljs-params">(Books books)</span></span>;<br>   <span class="hljs-comment">//根据id查询,返回一个Book</span><br>   <span class="hljs-function">Books <span class="hljs-title">queryBookById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br>   <span class="hljs-comment">//查询全部Book,返回list集合</span><br>   <span class="hljs-function">List&lt;Books&gt; <span class="hljs-title">queryAllBook</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.service;<br><br><span class="hljs-keyword">import</span> com.kuang.dao.BookMapper;<br><span class="hljs-keyword">import</span> com.kuang.pojo.Books;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BookService</span> </span>&#123;<br><br>   <span class="hljs-comment">//调用dao层的操作，设置一个set接口，方便Spring管理</span><br>   <span class="hljs-keyword">private</span> BookMapper bookMapper;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBookMapper</span><span class="hljs-params">(BookMapper bookMapper)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.bookMapper = bookMapper;<br>  &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Books book)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> bookMapper.addBook(book);<br>  &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteBookById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> bookMapper.deleteBookById(id);<br>  &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateBook</span><span class="hljs-params">(Books books)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> bookMapper.updateBook(books);<br>  &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Books <span class="hljs-title">queryBookById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> bookMapper.queryBookById(id);<br>  &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Books&gt; <span class="hljs-title">queryAllBook</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> bookMapper.queryAllBook();<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>OK，到此，底层需求操作编写完毕！</strong></p><h2 id="Spring层"><a href="#Spring层" class="headerlink" title="Spring层"></a>Spring层</h2><p>1、配置<strong>Spring整合MyBatis</strong>，我们这里数据源使用c3p0连接池；</p><p>2、我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">       https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 配置整合mybatis --&gt;</span><br>   <span class="hljs-comment">&lt;!-- 1.关联数据库文件 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:database.properties&quot;</span>/&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 2.数据库连接池 --&gt;</span><br>   <span class="hljs-comment">&lt;!--数据库连接池</span><br><span class="hljs-comment">       dbcp 半自动化操作 不能自动连接</span><br><span class="hljs-comment">       c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）</span><br><span class="hljs-comment">   --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 配置连接池属性 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><br>       <span class="hljs-comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;30&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>       <span class="hljs-comment">&lt;!-- 关闭连接后不自动commit --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoCommitOnClose&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>       <span class="hljs-comment">&lt;!-- 获取连接超时时间 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;checkoutTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span><br>       <span class="hljs-comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;acquireRetryAttempts&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 注入数据库连接池 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>       <span class="hljs-comment">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span><br>   <span class="hljs-comment">&lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 注入sqlSessionFactory --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>       <span class="hljs-comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.kuang.dao&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>3、<strong>Spring整合service层</strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 扫描service相关的bean --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang.service&quot;</span> /&gt;</span><br><br>   <span class="hljs-comment">&lt;!--BookServiceImpl注入到IOC容器中--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BookServiceImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.service.BookServiceImpl&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookMapper&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;bookMapper&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 配置事务管理器 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 注入数据库连接池 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="SpringMVC层"><a href="#SpringMVC层" class="headerlink" title="SpringMVC层"></a>SpringMVC层</h2><p>1、<strong>web.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!--DispatcherServlet--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>           <span class="hljs-comment">&lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;</span>  <br>           <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!--encodingFilter--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span><br>          org.springframework.web.filter.CharacterEncodingFilter<br>       <span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br>   <br>   <span class="hljs-comment">&lt;!--Session过期时间--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br>   <br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>2、<strong>spring-mvc.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-tag"><span class="hljs-string">   https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 配置SpringMVC --&gt;</span><br>   <span class="hljs-comment">&lt;!-- 1.开启SpringMVC注解驱动 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span><br>   <span class="hljs-comment">&lt;!-- 2.静态资源默认servlet配置--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 4.扫描web相关的bean --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang.controller&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>3、<strong>Spring配置整合文件，applicationContext.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;spring-dao.xml&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;spring-service.xml&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;spring-mvc.xml&quot;</span>/&gt;</span><br>   <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>1、BookController 类编写 ， 方法一：查询全部书籍</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookController</span> </span>&#123;<br><br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-meta">@Qualifier(&quot;BookServiceImpl&quot;)</span><br>   <span class="hljs-keyword">private</span> BookService bookService;<br><br>   <span class="hljs-meta">@RequestMapping(&quot;/allBook&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">list</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>       List&lt;Books&gt; list = bookService.queryAllBook();<br>       model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>, list);<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;allBook&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>2、编写首页 <strong>index.jsp</strong></p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span> %&gt;<br>&lt;!DOCTYPE HTML&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>   &lt;title&gt;首页&lt;/title&gt;<br>   &lt;style type=<span class="hljs-string">&quot;text/css&quot;</span>&gt;<br>       a &#123;<br>           text-decoration: none;<br>           color: black;<br>           font-size: 18px;<br>      &#125;<br>       h3 &#123;<br>           width: 180px;<br>           height: 38px;<br>           margin: 100px auto;<br>           text-align: center;<br>           line-height: 38px;<br>           background: deepskyblue;<br>           border-radius: 4px;<br>      &#125;<br>   &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;h3&gt;<br>   &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;&gt;点击进入列表页&lt;/a&gt;<br>&lt;/h3&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></div></td></tr></table></figure><p>3、书籍列表页面 <strong>allbook.jsp</strong></p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;%@ taglib prefix=<span class="hljs-string">&quot;c&quot;</span> uri=<span class="hljs-string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>   &lt;title&gt;书籍列表&lt;/title&gt;<br>   &lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;<br>   &lt;!-- 引入 Bootstrap --&gt;<br>   &lt;link href=<span class="hljs-string">&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> rel=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br><br>   &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;row clearfix&quot;</span>&gt;<br>       &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-md-12 column&quot;</span>&gt;<br>           &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;page-header&quot;</span>&gt;<br>               &lt;h1&gt;<br>                   &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;<br>               &lt;/h1&gt;<br>           &lt;/div&gt;<br>       &lt;/div&gt;<br>   &lt;/div&gt;<br><br>   &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;row&quot;</span>&gt;<br>       &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-md-4 column&quot;</span>&gt;<br>           &lt;a class=&quot;btn btn-primary&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toAddBook&quot;&gt;新增&lt;/a&gt;<br>       &lt;/div&gt;<br>   &lt;/div&gt;<br><br>   &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;row clearfix&quot;</span>&gt;<br>       &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-md-12 column&quot;</span>&gt;<br>           &lt;table <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;table table-hover table-striped&quot;</span>&gt;<br>               &lt;thead&gt;<br>               &lt;tr&gt;<br>                   &lt;th&gt;书籍编号&lt;/th&gt;<br>                   &lt;th&gt;书籍名字&lt;/th&gt;<br>                   &lt;th&gt;书籍数量&lt;/th&gt;<br>                   &lt;th&gt;书籍详情&lt;/th&gt;<br>                   &lt;th&gt;操作&lt;/th&gt;<br>               &lt;/tr&gt;<br>               &lt;/thead&gt;<br><br>               &lt;tbody&gt;<br>               &lt;c:forEach <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;book&quot;</span> items=<span class="hljs-string">&quot;$&#123;requestScope.get(&#x27;list&#x27;)&#125;&quot;</span>&gt;<br>                   &lt;tr&gt;<br>                       &lt;td&gt;$&#123;book.getBookID()&#125;&lt;/td&gt;<br>                       &lt;td&gt;$&#123;book.getBookName()&#125;&lt;/td&gt;<br>                       &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;/td&gt;<br>                       &lt;td&gt;$&#123;book.getDetail()&#125;&lt;/td&gt;<br>                       &lt;td&gt;<br>                           &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;/a&gt; |<br>                           &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/del/$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;/a&gt;<br>                       &lt;/td&gt;<br>                   &lt;/tr&gt;<br>               &lt;/c:forEach&gt;<br>               &lt;/tbody&gt;<br>           &lt;/table&gt;<br>       &lt;/div&gt;<br>   &lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></div></td></tr></table></figure><p>4、BookController 类编写 ， 方法二：添加书籍</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/toAddBook&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toAddPaper</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;addBook&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/addBook&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addPaper</span><span class="hljs-params">(Books books)</span> </span>&#123;<br>   System.out.println(books);<br>   bookService.addBook(books);<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/book/allBook&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>5、添加书籍页面：<strong>addBook.jsp</strong></p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;%@ taglib prefix=<span class="hljs-string">&quot;c&quot;</span> uri=<span class="hljs-string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br><br>&lt;html&gt;<br>&lt;head&gt;<br>   &lt;title&gt;新增书籍&lt;/title&gt;<br>   &lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;<br>   &lt;!-- 引入 Bootstrap --&gt;<br>   &lt;link href=<span class="hljs-string">&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> rel=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br><br>   &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;row clearfix&quot;</span>&gt;<br>       &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-md-12 column&quot;</span>&gt;<br>           &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;page-header&quot;</span>&gt;<br>               &lt;h1&gt;<br>                   &lt;small&gt;新增书籍&lt;/small&gt;<br>               &lt;/h1&gt;<br>           &lt;/div&gt;<br>       &lt;/div&gt;<br>   &lt;/div&gt;<br>   &lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/addBook&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>      书籍名称：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;bookName&quot;</span>&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;<br>      书籍数量：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;bookCounts&quot;</span>&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;<br>      书籍详情：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;detail&quot;</span>&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;<br>       &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;添加&quot;</span>&gt;<br>   &lt;/form&gt;<br><br>&lt;/div&gt;<br></code></pre></div></td></tr></table></figure><p>6、BookController 类编写 ， 方法三：修改书籍</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/toUpdateBook&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toUpdateBook</span><span class="hljs-params">(Model model, <span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>   Books books = bookService.queryBookById(id);<br>   System.out.println(books);<br>   model.addAttribute(<span class="hljs-string">&quot;book&quot;</span>,books );<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;updateBook&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/updateBook&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateBook</span><span class="hljs-params">(Model model, Books book)</span> </span>&#123;<br>   System.out.println(book);<br>   bookService.updateBook(book);<br>   Books books = bookService.queryBookById(book.getBookID());<br>   model.addAttribute(<span class="hljs-string">&quot;books&quot;</span>, books);<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/book/allBook&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>7、修改书籍页面  <strong>updateBook.jsp</strong></p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;%@ taglib prefix=<span class="hljs-string">&quot;c&quot;</span> uri=<span class="hljs-string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>   &lt;title&gt;修改信息&lt;/title&gt;<br>   &lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;<br>   &lt;!-- 引入 Bootstrap --&gt;<br>   &lt;link href=<span class="hljs-string">&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> rel=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br><br>   &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;row clearfix&quot;</span>&gt;<br>       &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-md-12 column&quot;</span>&gt;<br>           &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;page-header&quot;</span>&gt;<br>               &lt;h1&gt;<br>                   &lt;small&gt;修改信息&lt;/small&gt;<br>               &lt;/h1&gt;<br>           &lt;/div&gt;<br>       &lt;/div&gt;<br>   &lt;/div&gt;<br><br>   &lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/updateBook&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>       &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;bookID&quot;</span> value=<span class="hljs-string">&quot;$&#123;book.getBookID()&#125;&quot;</span>/&gt;<br>      书籍名称：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;bookName&quot;</span> value=<span class="hljs-string">&quot;$&#123;book.getBookName()&#125;&quot;</span>/&gt;<br>      书籍数量：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;bookCounts&quot;</span> value=<span class="hljs-string">&quot;$&#123;book.getBookCounts()&#125;&quot;</span>/&gt;<br>      书籍详情：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;detail&quot;</span> value=<span class="hljs-string">&quot;$&#123;book.getDetail() &#125;&quot;</span>/&gt;<br>       &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>/&gt;<br>   &lt;/form&gt;<br><br>&lt;/div&gt;<br></code></pre></div></td></tr></table></figure><p>8、BookController 类编写 ， 方法四：删除书籍</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/del/&#123;bookId&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deleteBook</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bookId&quot;)</span> <span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>   bookService.deleteBookById(id);<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/book/allBook&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><strong>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</strong></li><li>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li><li><strong>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</strong></li><li>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。</li><li>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</li><li><p>就和国内百度的搜索框一样!</p></li><li><p>传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。</p></li><li>使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。</li><li>使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。</li></ul><h2 id="伪造AJAX"><a href="#伪造AJAX" class="headerlink" title="伪造AJAX"></a>伪造AJAX</h2><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>iframe<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> myDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><br><span class="javascript">        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;currentTime&#x27;</span>).innerText = myDate.getTime();</span><br>    &#125;;<br><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LoadPage</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> targetUrl =  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;url&#x27;</span>).value;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(targetUrl);</span><br><span class="javascript">        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;iframePosition&quot;</span>).src = targetUrl;</span><br>    &#125;<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>请输入要加载的地址：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;currentTime&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;LoadPage()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>加载页面位置：<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframePosition&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100%;height: 500px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>利用AJAX可以做：</strong></p><ul><li>注册时，输入用户名自动检测用户是否已经存在。</li><li>登陆时，提示用户名密码错误</li><li>删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。</li><li>….等等</li></ul><h2 id="jQuery-ajax"><a href="#jQuery-ajax" class="headerlink" title="jQuery.ajax"></a>jQuery.ajax</h2><p>纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！</p><p>Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</p><p>jQuery 提供多个与 AJAX 有关的方法。</p><p>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。</p><p>jQuery 不是生产者，而是大自然搬运工。</p><p>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jQuery.ajax(...)</span><br><span class="hljs-keyword"> </span>     部分参数：<br>            url：请求地址<br>            type：请求方式，GET、POST（<span class="hljs-number">1</span>.<span class="hljs-number">9</span>.<span class="hljs-number">0</span>之后用method）<br>        headers：请求头<br>            data：要发送的数据<br>    contentType：即将发送信息至服务器的内容编码类型(默认: <span class="hljs-string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>)<br>          async：是否异步<br>        timeout：设置请求超时时间（毫秒）<br>      <span class="hljs-keyword">beforeSend：发送请求前执行的函数(全局)</span><br><span class="hljs-keyword"> </span>       complete：完成之后执行的回调函数(全局)<br>        success：成功之后执行的回调函数(全局)<br>          error：失败之后执行的回调函数(全局)<br>        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型<br>        dataType：将服务器端返回的数据转换成指定类型<br>          <span class="hljs-string">&quot;xml&quot;</span>: 将服务器端返回的内容转换成xml格式<br>          <span class="hljs-string">&quot;text&quot;</span>: 将服务器端返回的内容转换成普通文本格式<br>          <span class="hljs-string">&quot;html&quot;</span>: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含<span class="hljs-keyword">JavaScript标签，则会尝试去执行。</span><br><span class="hljs-keyword"> </span>       <span class="hljs-string">&quot;script&quot;</span>: 尝试将返回值当作<span class="hljs-keyword">JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式</span><br><span class="hljs-keyword"> </span>         <span class="hljs-string">&quot;json&quot;</span>: 将服务器端返回的内容转换成相应的<span class="hljs-keyword">JavaScript对象</span><br><span class="hljs-keyword"> </span>       <span class="hljs-string">&quot;jsonp&quot;</span>: <span class="hljs-keyword">JSONP </span>格式使用 <span class="hljs-keyword">JSONP </span>形式调用函数时，如 <span class="hljs-string">&quot;myurl?callback=?&quot;</span> <span class="hljs-keyword">jQuery </span>将自动替换 ? 为正确的函数名，以执行回调函数<br></code></pre></div></td></tr></table></figure><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p><p><strong>过滤器与拦截器的区别：</strong>拦截器是AOP思想的具体应用。</p><p><strong>过滤器</strong></p><ul><li>servlet规范中的一部分，任何java web工程都可以使用</li><li>在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截</li></ul><p><strong>拦截器</strong> </p><ul><li>拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li><li>拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的</li></ul><h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><p>那如何实现拦截器呢？</p><p>想要自定义拦截器，必须实现 HandlerInterceptor 接口。</p><p>1、新建一个Moudule ， springmvc-07-Interceptor  ， 添加web支持</p><p>2、配置web.xml 和 springmvc-servlet.xml 文件</p><p>3、编写一个拦截器</p><p>4、在springmvc的配置文件中配置拦截器</p><p>5、编写一个Controller，接收请求</p><p>6、前端 index.jsp</p><p>7、启动tomcat 测试一下！</p><h2 id="验证用户是否登录-认证用户"><a href="#验证用户是否登录-认证用户" class="headerlink" title="验证用户是否登录 (认证用户)"></a>验证用户是否登录 (认证用户)</h2><p><strong>实现思路</strong></p><p>1、有一个登陆页面，需要写一个controller访问页面。</p><p>2、登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。<em>返回登陆成功。</em></p><p>3、拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面</p><p><strong>测试：</strong></p><p>1、编写一个登陆页面  login.jsp</p><p>2、编写一个Controller处理请求</p><p>3、编写一个登陆成功的页面 success.jsp</p><p>4、在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！</p><p>5、编写用户登录拦截器</p><p>6、在Springmvc的配置文件中注册拦截器</p><p>7、再次重启Tomcat测试！</p><h1 id="文件上传和下载"><a href="#文件上传和下载" class="headerlink" title="文件上传和下载"></a>文件上传和下载</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。</p><p>前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；</p><p><strong>对表单中的 enctype 属性做个详细的说明：</strong></p><ul><li>application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。</li><li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li><li>text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。</li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。</p><ul><li>Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。</li><li>而Spring MVC则提供了更简单的封装。</li><li>Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。</li><li>Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类：</li><li>CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。</li></ul><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>1、导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包；</p><p>2、配置bean：multipartResolver</p><p>【<strong>注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！</strong>】</p><p>CommonsMultipartFile 的 常用方法：</p><ul><li><strong>String getOriginalFilename()：获取上传文件的原名</strong></li><li><strong>InputStream getInputStream()：获取文件流</strong></li><li><strong>void transferTo(File dest)：将上传文件保存到一个目录文件中</strong></li></ul><p>3、编写前端页面</p><p>4、<strong>Controller</strong></p><p>5、测试上传文件，OK！</p><p><strong>采用file.Transto 来保存上传的文件</strong></p><p>1、编写Controller</p><p>2、前端表单提交地址修改</p><p>3、访问提交测试，OK！</p><h2 id="文件下载文件下载步骤："><a href="#文件下载文件下载步骤：" class="headerlink" title="文件下载文件下载步骤："></a>文件下载<strong>文件下载步骤：</strong></h2><p>1、设置 response 响应头</p><p>2、读取文件 — InputStream</p><p>3、写出文件 — OutputStream</p><p>4、执行操作</p><p>5、关闭流 （先开后关）</p><p><strong>参考：<a href="https://www.bilibili.com/video/BV1S54y1R7SB">狂神说</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Java后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis学习</title>
    <link href="/2021/04/05/Mybatis/"/>
    <url>/2021/04/05/Mybatis/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><p>回顾：</p><ul><li>JDBC</li><li>Mysql</li><li>java基础</li><li>Maven</li><li>Junit</li></ul><h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><h2 id="1-1、什么是Mybatis"><a href="#1-1、什么是Mybatis" class="headerlink" title="1.1、什么是Mybatis"></a>1.1、什么是Mybatis</h2><p><img src="/2021/04/05/Mybatis/image-20210126204430750.png" alt="image-20210126204430750"></p><ul><li>MyBatis 是一款优秀的<strong>持久层框架</strong></li><li>它支持自定义 SQL、存储过程以及高级映射。</li><li>MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。</li><li>MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li><li>MyBatis 本是apache的一个<a href="https://baike.baidu.com/item/开源项目/3406069">开源项目</a>iBatis, 2010年这个<a href="https://baike.baidu.com/item/项目/477803">项目</a>由apache software foundation 迁移到了<a href="https://baike.baidu.com/item/google code/2346604">google code</a>，并且改名为MyBatis 。</li><li>2013年11月迁移到<a href="https://baike.baidu.com/item/Github/10145341">Github</a>。</li></ul><p>如何获得Mybatis？</p><ul><li><p>Maven仓库</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>Github：<a href="https://github.com/mybatis/mybatis-3/releases">https://github.com/mybatis/mybatis-3/releases</a></p></li><li><p>中文文档：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p></li></ul><h2 id="1-2、持久化"><a href="#1-2、持久化" class="headerlink" title="1.2、持久化"></a>1.2、持久化</h2><p>数据持久化</p><ul><li>持久化就是将程序的数据在持久状态和瞬时状态转化的过程</li><li>内存：<strong>断电即失</strong></li><li>数据库(jdbc)，io文件持久化。</li><li>生活：冷藏</li></ul><p><strong>为什么需要持久化？</strong></p><ul><li>有一些对象，不能让他丢掉。</li><li>内存太贵了</li></ul><h2 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h2><p>Dao层，Service层，Controller层</p><ul><li>完成持久化工作的代码块</li><li>层界限十分明显</li></ul><h2 id="1-4、为什么需要Mybatis？"><a href="#1-4、为什么需要Mybatis？" class="headerlink" title="1.4、为什么需要Mybatis？"></a>1.4、为什么需要Mybatis？</h2><ul><li>帮助程序员把数据存入数据库中</li><li>方便</li><li>传统的JDBC代码太复杂了。简化 框架 自动化</li><li>不用Mybatis也可以。更容易上手。</li><li>优点：<ul><li><strong>简单易学</strong>：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li><li><strong>灵活</strong>：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li><li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。<strong>sql和代码的分离，提高了可维护性</strong>。</li><li><strong>提供映射标签，支持对象与数据库的orm字段关系映射</strong></li><li><strong>提供对象关系映射标签，支持对象关系组建维护</strong></li><li><strong>提供xml标签，支持编写动态sql</strong>。</li></ul></li></ul><p><strong>最重要的一点：使用的人多</strong></p><p>Spring SpringMVC SpringBoot</p><h1 id="2、第一个Mybatis程序"><a href="#2、第一个Mybatis程序" class="headerlink" title="2、第一个Mybatis程序"></a>2、第一个Mybatis程序</h1><p>思路：搭建环境 —&gt; 导入Mybatis —&gt; 编写代码 —&gt; 测试</p><h2 id="2-1、搭建环境"><a href="#2-1、搭建环境" class="headerlink" title="2.1、搭建环境"></a>2.1、搭建环境</h2><p>搭建数据库</p><p>新建项目</p><p>1.新建一个普通的maven项目</p><p>2.删除src目录</p><p>3.导入maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mysql驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mybatis--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--junit--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="2-2、创建一个模块"><a href="#2-2、创建一个模块" class="headerlink" title="2.2、创建一个模块"></a>2.2、创建一个模块</h2><ul><li><p>编写mybatis的核心配置文件</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--configuration核心配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>编写mybatis工具类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//sqlSessionFactory --&gt; sqlSession</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisUtils</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//使用Mybatis第一步：获取sqlSessionFactory对象</span><br>            String resource = <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>            InputStream inputStream = Resources.getResourceAsStream(resource);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//既然有了SqlSessionFactory，顾名思义，我们就可以从中获得SqlSession的实例了</span><br>    <span class="hljs-comment">//SqlSession完全包含了面向数据库执行SQL命令所需的所有方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-3、编写代码"><a href="#2-3、编写代码" class="headerlink" title="2.3、编写代码"></a>2.3、编写代码</h2><ul><li><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String pwd;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, String pwd)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.pwd = pwd;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPwd</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pwd;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPwd</span><span class="hljs-params">(String pwd)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.pwd = pwd;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, pwd=&#x27;&quot;</span> + pwd + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>Dao接口</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>接口实现类由原来的UserDaoImpl转变为一个Mapper配置文件</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--namespace绑定一个对应的Dao/Mapper接口--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.acacac.dao.UserDao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.acacac.pojo.User&quot;</span>&gt;</span><br>    select * from mybatis.user<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><h2 id="2-4、测试"><a href="#2-4、测试" class="headerlink" title="2.4、测试"></a>2.4、测试</h2><p>注意点：</p><p>org.apache.ibatis.binding.BindingException: Type interface com.acacac.dao.UserDao is not known to the MapperRegistry.</p><p><strong>MapperRegistry是什么？</strong></p><p>核心配置文件中注册mappers</p><p><img src="/2021/04/05/Mybatis/image-20210127214318311.png" alt="image-20210127214318311"></p><p>注意</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li>Junit测试</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//第一步：获得SqlSession对像</span><br>        SqlSession sqlSession = MybatisUtils.getSqlSession();<br><br>        <span class="hljs-comment">//方式一：getMapper</span><br>        UserDao userDao = sqlSession.getMapper(UserDao.class);<br>        List&lt;User&gt; userList = userDao.getUserList();<br><br>        <span class="hljs-keyword">for</span> (User user : userList) &#123;<br>            System.out.println(user);<br>        &#125;<br><br>        <span class="hljs-comment">//关闭SqlSession</span><br>        sqlSession.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可能遇到的问题：</p><ul><li>1.配置文件没有注册</li><li>2.绑定接口错误</li><li>3.方法名不对</li><li>4.返回类型不对</li><li>5.Maven导出资源问题</li><li><strong>6.mybatis-config不能有中文注释</strong></li></ul><h1 id="3、CRUD"><a href="#3、CRUD" class="headerlink" title="3、CRUD"></a>3、CRUD</h1><h2 id="1、namespace"><a href="#1、namespace" class="headerlink" title="1、namespace"></a>1、namespace</h2><p>namespace中的包名要和Dao/mapper接口的包名一致</p><h2 id="2、select"><a href="#2、select" class="headerlink" title="2、select"></a>2、select</h2><p>选择，查询语句；</p><ul><li>id：就是对应的namespace中的方法名；</li><li>resultTypr：Sql语句执行的返回值</li><li>parameterType：参数类型</li></ul><p>1.编写接口</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//根据ID查询用户</span><br><span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br></code></pre></div></td></tr></table></figure><p>2.编写对应的mapper中的sql语句</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.acacac.pojo.User&quot;</span>&gt;</span><br>    select * from mybatis.user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>3.测试</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUserById</span><span class="hljs-params">()</span></span>&#123;<br>    SqlSession sqlSession = MybatisUtils.getSqlSession();<br><br>    UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br><br>    User user = mapper.getUserById(<span class="hljs-number">1</span>);<br>    System.out.println(user);<br><br><br>    sqlSession.close();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3、Insert"><a href="#3、Insert" class="headerlink" title="3、Insert"></a>3、Insert</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--对象中的属性，可以直接取出来--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.acacac.pojo.User&quot;</span>&gt;</span><br>    insert into mybatis.user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="4、update"><a href="#4、update" class="headerlink" title="4、update"></a>4、update</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.acacac.pojo.User&quot;</span>&gt;</span><br>    update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="5、delete"><a href="#5、delete" class="headerlink" title="5、delete"></a>5、delete</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    delete from mybatis.user where id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>注意点：</p><ul><li><strong>增删改需要提交事务</strong></li></ul><h2 id="6、常见错误"><a href="#6、常见错误" class="headerlink" title="6、常见错误"></a>6、常见错误</h2><ul><li>标签不要匹配错</li><li>resource绑定mapper，需要使用路径</li><li>程序配置文件必须符合规范</li><li>NullPointerException，没有注册到资源</li><li>输出的xml文件存在中文乱码问题</li><li>maven资源没有导出问题</li></ul><h2 id="7、万能Map"><a href="#7、万能Map" class="headerlink" title="7、万能Map"></a>7、万能Map</h2><p>假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//万能的Map</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addUser2</span><span class="hljs-params">(Map&lt;String,Object&gt; map)</span></span>;<br></code></pre></div></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser2&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    insert into mybatis.user(id,pwd) values (#&#123;userid&#125;,#&#123;password&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser2</span><span class="hljs-params">()</span></span>&#123;<br>    SqlSession sqlSession = MybatisUtils.getSqlSession();<br>    UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br><br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<br>    map.put(<span class="hljs-string">&quot;userid&quot;</span>,<span class="hljs-number">5</span>);<br>    map.put(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;222333&quot;</span>);<br>    mapper.addUser2(map);<br>    sqlSession.commit();<br>    sqlSession.close();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Map传递参数，直接在sql中取出key即可    【parameterType=”map”】</p><p>对象传递参数，直接在sql中取对象的属性即可    【parameterType=”Object”】</p><p>只有一个基本类型参数的情况下，可以直接在sql中取到</p><p>多个参数用Map，<strong>或者注解</strong></p><h2 id="8、思考题"><a href="#8、思考题" class="headerlink" title="8、思考题"></a>8、思考题</h2><p>模糊查询怎么写？</p><p>1.Java代码执行的时候，传递通配符% %</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;User&gt; userList = mapper.getUserLike(<span class="hljs-string">&quot;%李%&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>2.在sql拼接中使用通配符</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">select * from mybatis.user where name like  &quot;%&quot;#&#123;value&#125;&quot;%&quot;<br></code></pre></div></td></tr></table></figure><h1 id="4、配置解析"><a href="#4、配置解析" class="headerlink" title="4、配置解析"></a>4、配置解析</h1><h2 id="1、核心配置文件"><a href="#1、核心配置文件" class="headerlink" title="1、核心配置文件"></a>1、核心配置文件</h2><ul><li>mybatis-config.xml</li><li>MyBatis的配置文件包含了会深深影响MyBatis行为的设置和属性信息</li></ul><figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm"><span class="hljs-title">configuration</span>（配置）<br><span class="hljs-title">properties</span>（属性）<br><span class="hljs-title">settings</span>（设置）<br>typeAliases（类型别名）<br>typeHandlers（类型处理器）<br><span class="hljs-title">objectFactory</span>（对象工厂）<br><span class="hljs-title">plugins</span>（插件）<br><span class="hljs-title">environments</span>（环境配置）<br><span class="hljs-title">environment</span>（环境变量）<br><span class="hljs-title">transactionManager</span>（事务管理器）<br><span class="hljs-title">dataSource</span>（数据源）<br><span class="hljs-title">databaseIdProvider</span>（数据库厂商标识）<br><span class="hljs-title">mappers</span>（映射器）<br></code></pre></div></td></tr></table></figure><h2 id="2、环境配置（environments）"><a href="#2、环境配置（environments）" class="headerlink" title="2、环境配置（environments）"></a>2、环境配置（environments）</h2><p>MyBatis 可以配置成适应多种环境</p><p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p><p>学会使用配置多套运行环境</p><p>Mybatis默认的事务管理器就是JDBC，连接池：POOLED</p><h2 id="3、属性（properties）"><a href="#3、属性（properties）" class="headerlink" title="3、属性（properties）"></a>3、属性（properties）</h2><p>我们可以通过properties属性来实现引用配置文件</p><p>这些属性都是可外部配置且可动态替换的，既可以在典型的java属性文件中配置，亦可通过properties元素的子元素来传递。【db.properties】</p><p><img src="/2021/04/05/Mybatis/image-20210128172423088.png" alt="image-20210128172423088"></p><p>编写一个配置文件</p><p>db.properties</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">driver</span> = <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">url</span> = <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT&amp;nullCatalogMeansCurrent = true</span><br><span class="hljs-attr">username</span> = <span class="hljs-string">root</span><br><span class="hljs-attr">password</span> = <span class="hljs-string">root</span><br></code></pre></div></td></tr></table></figure><p>在核心配置文件中引入</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入外部配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li>可以直接引入外部文件</li><li>可以在其中增加一些属性配置</li><li>如果两个文件有同一个字段，优先使用外部配置文件的</li></ul><h2 id="4、类型别名（typeAliases）"><a href="#4、类型别名（typeAliases）" class="headerlink" title="4、类型别名（typeAliases）"></a>4、类型别名（typeAliases）</h2><ul><li>类型别名是为Java类型设置一个短的名字</li><li>存在的意义仅存在于用来减少类完全限定名的冗余</li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--可以给实体类起别名--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.acacac.pojo.User&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;User&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p><p>扫描实体类的包，它的默认别名就为这个类的类名，首字母小写</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--可以给实体类起别名--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.acacac.pojo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>在实体类比较少的时候，使用第一种方式。</p><p>如果实体类十分多，建议使用第二种。</p><p>第一种可以DIY别名，第二种则不行，如果非要改，需要在实体类上增加注解</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Ailas(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br></code></pre></div></td></tr></table></figure><h2 id="5、设置"><a href="#5、设置" class="headerlink" title="5、设置"></a>5、设置</h2><p>这是MyBtis中极为重要的调整设置，它们会改变MyBatis的运行时行为。</p><p><img src="/2021/04/05/Mybatis/image-20210128180332104.png" alt="image-20210128180332104"></p><p><img src="/2021/04/05/Mybatis/image-20210128180413580.png" alt="image-20210128180413580"></p><h2 id="6、其他配置"><a href="#6、其他配置" class="headerlink" title="6、其他配置"></a>6、其他配置</h2><ul><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li><li>plugins（插件）<ul><li>mybatis-generator-core</li><li>mybatis-plus</li><li>通用mapper</li></ul></li></ul><h2 id="7、映射器（mappers）"><a href="#7、映射器（mappers）" class="headerlink" title="7、映射器（mappers）"></a>7、映射器（mappers）</h2><p>MapperRegistry：注册绑定我们的Mapper文件</p><p>方式一：【推荐使用】</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/acacac/dao/UserMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>方式二：使用class文件绑定注册</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;mapper resource=&quot;com/acacac/dao/UserMapper.xml&quot;/&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.dao.UserMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>注意点：</p><ul><li>接口和他的Mapper配置文件必须同名</li><li>接口和他的Mapper配置文件必须在同一个包下</li></ul><p>方式三：使用扫描包进行注入绑定</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;mapper resource=&quot;com/acacac/dao/UserMapper.xml&quot;/&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;mapper class=&quot;com.acacac.dao.UserMapper&quot;/&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.acacac.dao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>注意点：</p><ul><li>接口和他的Mapper配置文件必须同名</li><li>接口和他的Mapper配置文件必须在同一个包下</li></ul><h2 id="8、生命周期和作用域"><a href="#8、生命周期和作用域" class="headerlink" title="8、生命周期和作用域"></a>8、生命周期和作用域</h2><p><img src="/2021/04/05/Mybatis/image-20210129095212057.png" alt="image-20210129095212057"></p><p>作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong>。</p><p><strong>SqlSessionFactoryBuilder</strong>：</p><ul><li>一旦创建了SqlSessionFactory，就不再需要它了</li><li>局部变量</li></ul><p><strong>SqlSessionFactory</strong>：</p><ul><li>说白了就是可以想象为：数据库连接池</li><li>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例</strong></li><li>因此 SqlSessionFactory 的最佳作用域是应用作用域</li><li>最简单的就是使用<strong>单例模式</strong>或者<strong>静态单例模式</strong></li></ul><p><strong>SqlSession</strong>：</p><ul><li>连接到连接池的一个请求</li><li>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域</li><li>用完之后需要赶紧关闭，否则资源被占用</li></ul><p><img src="/2021/04/05/Mybatis/image-20210129095853276.png" alt="image-20210129095853276"></p><p>这里面的每一个Mapper，就代表一个具体的业务</p><h1 id="5、解决属性名和字段名不一致的问题"><a href="#5、解决属性名和字段名不一致的问题" class="headerlink" title="5、解决属性名和字段名不一致的问题"></a>5、解决属性名和字段名不一致的问题</h1><h2 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h2><p>数据库中的字段：</p><p><img src="/2021/04/05/Mybatis/image-20210129100239054.png" alt="image-20210129100239054"></p><p>新建一个项目，拷贝之前的，测试实体类字段不一致的情况</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>测试出现问题</p><p><img src="/2021/04/05/Mybatis/image-20210129101449601.png" alt="image-20210129101449601"></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">//        select * from mybatis.user where id = #&#123;id&#125;<br><br>//类型处理器<br>//        select id,name,pwd from mybatis.user where id = #&#123;id&#125;<br></code></pre></div></td></tr></table></figure><p>解决方法：</p><ul><li><p>起别名</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.acacac.pojo.User&quot;</span>&gt;</span><br>    select id,name,pwd as password from mybatis.user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><h2 id="2、resultMap"><a href="#2、resultMap" class="headerlink" title="2、resultMap"></a>2、resultMap</h2><p>结果集映射</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">id</span><span class="hljs-built_in">name</span>pwd<br><span class="hljs-built_in">id</span><span class="hljs-built_in">name</span>password<br></code></pre></div></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--结果集映射--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--column数据库中的字段，property实体类中的属性--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span><br>    select * from mybatis.user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li>resultMap 元素是 MyBatis 中最重要最强大的元素</li><li>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了</li><li>ResultMap 的优秀之处——你完全可以不用显式地配置它们</li><li>如果世界总使这么简单就好了</li></ul><h1 id="6、日志"><a href="#6、日志" class="headerlink" title="6、日志"></a>6、日志</h1><h2 id="6-1、日志工厂"><a href="#6-1、日志工厂" class="headerlink" title="6.1、日志工厂"></a>6.1、日志工厂</h2><p>如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手</p><p>曾经：sout、debug</p><p>现在：日志工厂</p><p><img src="/2021/04/05/Mybatis/image-20210129104446062.png" alt="image-20210129104446062"></p><ul><li>SLF4J </li><li>LOG4J 【掌握】</li><li>LOG4J2 </li><li>JDK_LOGGING </li><li>COMMONS_LOGGING </li><li>STDOUT_LOGGING 【掌握】</li><li>NO_LOGGING</li></ul><p>在Mybatis中具体使用哪一个日志实现，在设置中设定</p><p><strong>STDOUT_LOGGING标准日志输出</strong></p><p>在mybatis核心配置文件中，配置我们的日志</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/04/05/Mybatis/image-20210129110120211.png" alt="image-20210129110120211"></p><h2 id="6-2、Log4j"><a href="#6-2、Log4j" class="headerlink" title="6.2、Log4j"></a>6.2、Log4j</h2><ul><li>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/控制台/2438626">控制台</a>、文件、<a href="https://baike.baidu.com/item/GUI">GUI</a>组件</li><li>我们也可以控制每一条日志的输出格式</li><li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程</li><li>通过一个<a href="https://baike.baidu.com/item/配置文件/286550">配置文件</a>来灵活地进行配置，而不需要修改应用的代码</li></ul><p>1.先导入log4j的包</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>2.log4j.properties</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><br><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">DEBUG,console,file</span><br><br><span class="hljs-comment">#控制台输出的相关配置</span><br><span class="hljs-meta">log4j.appender.console</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.console.Target</span>=<span class="hljs-string">System.out</span><br><span class="hljs-meta">log4j.appender.console.Threshold</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.appender.console.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="hljs-string">[%c]-%m%n</span><br><br><span class="hljs-comment">#文件输出的相关配置</span><br><span class="hljs-meta">log4j.appender.file</span>=<span class="hljs-string">org.apache.log4j.RollingFileAppender</span><br><span class="hljs-meta">log4j.appender.file.File</span>=<span class="hljs-string">.log/ac.log</span><br><span class="hljs-meta">log4j.appender.file.MaxFileSize</span>=<span class="hljs-string">10mb</span><br><span class="hljs-meta">log4j.appender.file.Threshold</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.appender.file.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="hljs-string">[%p][%d&#123;yy-mm-dd&#125;][%c]%m%n</span><br><br><span class="hljs-comment">#日志输出级别</span><br><span class="hljs-meta">log4j.logger.org.mybatis</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.Statement</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.ResultSet</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="hljs-string">DEBUG</span><br></code></pre></div></td></tr></table></figure><p>3.配置log4j为日志的实现</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>4.Log4j的使用，直接测试刚才的查询</p><p><img src="/2021/04/05/Mybatis/image-20210130124844186.png" alt="image-20210130124844186"></p><p><strong>简单使用</strong></p><p>​    1.在要使用Log4j的类中，导入包 import org.apache.log4j.Logger;</p><p>​    2.日志对象，参数为当前类的class</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Logger logger = Logger.getLogger(UserDaoTest.class);<br></code></pre></div></td></tr></table></figure><p>​    3.日志级别</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">logger.info(<span class="hljs-string">&quot;info:进入了testLog4j&quot;</span>);<br>logger.debug(<span class="hljs-string">&quot;debug:进入了testLog4j&quot;</span>);<br>logger.error(<span class="hljs-string">&quot;error:进入了testLog4j&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>问题：生成log文件打不开</p><p>解决：<a href="https://blog.csdn.net/weixin_43837880/article/details/111567307">https://blog.csdn.net/weixin_43837880/article/details/111567307</a></p><p><img src="/2021/04/05/Mybatis/image-20210130131532793.png" alt="image-20210130131532793"></p><h1 id="7、分页"><a href="#7、分页" class="headerlink" title="7、分页"></a>7、分页</h1><p><strong>思考：为什么要分页？</strong></p><ul><li>减少数据的处理量</li></ul><h2 id="7-1、使用Limit分页"><a href="#7-1、使用Limit分页" class="headerlink" title="7.1、使用Limit分页"></a>7.1、使用Limit分页</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">语法：<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> limit startIndex,pageSize;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> limit <span class="hljs-number">3</span>; #[<span class="hljs-number">0</span>,n]<br></code></pre></div></td></tr></table></figure><p>使用Mybatis实现分页，核心是SQL</p><p>​    1.接口</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//分页</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByLimit</span><span class="hljs-params">(Map&lt;String,Integer&gt; map)</span></span>;<br></code></pre></div></td></tr></table></figure><p>​    2.Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByLimit&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span><br>    select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>​    3.测试</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUserByLimit</span><span class="hljs-params">()</span></span>&#123;<br>    SqlSession sqlSession = MybatisUtils.getSqlSession();<br>    UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br><br>    HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();<br>    map.put(<span class="hljs-string">&quot;startIndex&quot;</span>,<span class="hljs-number">1</span>);<br>    map.put(<span class="hljs-string">&quot;pageSize&quot;</span>,<span class="hljs-number">2</span>);<br><br>    List&lt;User&gt; userList = mapper.getUserByLimit(map);<br>    <span class="hljs-keyword">for</span> (User user : userList) &#123;<br>        System.out.println(user);<br>    &#125;<br><br>    sqlSession.close();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="7-2、RowBounds分页（不常用）"><a href="#7-2、RowBounds分页（不常用）" class="headerlink" title="7.2、RowBounds分页（不常用）"></a>7.2、RowBounds分页（不常用）</h2><p>不使用SQL实现分页</p><h2 id="7-3、分页插件"><a href="#7-3、分页插件" class="headerlink" title="7.3、分页插件"></a>7.3、分页插件</h2><p><img src="/2021/04/05/Mybatis/image-20210130214207059.png" alt="image-20210130214207059"></p><p>了解即可</p><h1 id="8、使用注解开发"><a href="#8、使用注解开发" class="headerlink" title="8、使用注解开发"></a>8、使用注解开发</h1><h2 id="8-1、面向接口编程"><a href="#8-1、面向接口编程" class="headerlink" title="8.1、面向接口编程"></a>8.1、面向接口编程</h2><ul><li><strong>根本原因：解耦，可拓展，提高复用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发变得容易，规范性更好</strong></li><li>在一个面向对象的系统中，系统的各种功能是由许许多多不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的，对系统设计人员来讲就不那么重要了；</li><li>而各个对象之间的协作关系则成为系统设计的关键。消到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是按照这种思想来编程。</li></ul><p><strong>关于接口的理解</strong></p><ul><li>接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离</li><li>接口本身反映了系统设计人员对系统的抽象理解</li><li>接口应有两类：<ul><li>第一类是对一个个体的抽象，它可对应为一个抽象体（abstract class）；</li><li>第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；</li></ul></li><li>一个个体可能有多个抽象面。抽象面与抽象体是有区别的</li></ul><p><strong>三个面向区别</strong></p><ul><li>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性和方法</li><li>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现</li><li>接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题，更多的体现就是对系统整体的架构</li></ul><h2 id="8-2、使用注解开发"><a href="#8-2、使用注解开发" class="headerlink" title="8.2、使用注解开发"></a>8.2、使用注解开发</h2><p>1.注解在接口上实现</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from user&quot;)</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUsers</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure><p>2.需要在核心配置文件中绑定接口</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--绑定接口--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acacac.dao.UserMapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>3.测试</p><p>本质：反射机制实现</p><p>底层：动态代理</p><p><img src="/2021/04/05/Mybatis/image-20210201113534920.png" alt="image-20210201113534920"></p><p><strong>Mybatis详细的执行流程</strong></p><p><img src="/2021/04/05/Mybatis/image-20210201140903631.png" alt="image-20210201140903631"></p><h2 id="8-3、CRUD"><a href="#8-3、CRUD" class="headerlink" title="8.3、CRUD"></a>8.3、CRUD</h2><p>我们可以在工具类创建的时候实现自动提交事务</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编写接口，增加注解</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from user&quot;)</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUsers</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//方法存在多个参数，所有的参数前面必须加上@Param(&quot;id&quot;)注解</span><br>    <span class="hljs-meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>;<br><br>    <span class="hljs-meta">@Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>;<br><br>    <span class="hljs-meta">@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;<br><br>    <span class="hljs-meta">@Delete(&quot;delete from user where id = #&#123;uid&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;uid&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>测试类</p><p>【注意：我们必须要将接口注册绑定到我们的核心配置文件中】</p><p><strong>关于@Param()注解</strong></p><ul><li>基本类型的参数或者String类型，需要加上</li><li>引用类型不需要加</li><li>如果只有一个基本类型的话，可以忽略，但是建议都加上</li><li>我们在SQL中引用的就是我们这里的@Param()中设定的属性名</li></ul><p><strong>#{}   ￥{}区别</strong></p><p>尽量使用#{}，前者可以防止SQL注入，后者不行</p><h1 id="9、Lombok"><a href="#9、Lombok" class="headerlink" title="9、Lombok"></a>9、Lombok</h1><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">has</span> <span class="hljs-title">a</span> <span class="hljs-title">fully</span> <span class="hljs-title">featured</span> <span class="hljs-title">builder</span>, <span class="hljs-title">Automate</span> <span class="hljs-title">your</span> <span class="hljs-title">logging</span> <span class="hljs-title">variables</span>, <span class="hljs-title">and</span> <span class="hljs-title">much</span> <span class="hljs-title">more</span>.</span><br></code></pre></div></td></tr></table></figure><ul><li>Java library</li><li>plugs</li><li>build tools</li><li>with one annotation your class</li></ul><p>使用步骤：</p><ul><li><p>1.在IDEA中安装Lombok插件</p></li><li><p>2.在项目中导入lombok的jar包</p></li><li><p>3.在实体类上加注解即可</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br></code></pre></div></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span> and <span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@FieldNameConstants</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@EqualsAndHashCode</span><br><span class="hljs-meta">@AllArgsConstructor</span>, <span class="hljs-meta">@RequiredArgsConstructor</span> and <span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Log</span>, <span class="hljs-meta">@Log4j</span>, <span class="hljs-meta">@Log4j2</span>, <span class="hljs-meta">@Slf4j</span>, <span class="hljs-meta">@XSlf4j</span>, <span class="hljs-meta">@CommonsLog</span>, <span class="hljs-meta">@JBossLog</span>, <span class="hljs-meta">@Flogger</span>, <span class="hljs-meta">@CustomLog</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@SuperBuilder</span><br><span class="hljs-meta">@Singular</span><br><span class="hljs-meta">@Delegate</span><br><span class="hljs-meta">@Value</span><br><span class="hljs-meta">@Accessors</span><br><span class="hljs-meta">@Wither</span><br><span class="hljs-meta">@With</span><br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-meta">@val</span><br><span class="hljs-meta">@var</span><br></code></pre></div></td></tr></table></figure><p>说明：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span>：无参构造，get、set、toString、hashcode、equals<br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br></code></pre></div></td></tr></table></figure></li></ul><h1 id="10、多对一处理"><a href="#10、多对一处理" class="headerlink" title="10、多对一处理"></a>10、多对一处理</h1><p>多对一：</p><p><img src="/2021/04/05/Mybatis/image-20210201160828144.png" alt="image-20210201160828144"></p><ul><li>多个学生，对应一个老师</li><li>对于学生这边而言，<strong>关联</strong>.. 多个学生，关联一个老师 【多对一】</li><li>对于老师而言，<strong>集合</strong>，一个老师，有很多学生 【一对多】</li></ul><p><img src="/2021/04/05/Mybatis/image-20210201163322262.png" alt="image-20210201163322262"></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">table</span> teacher(<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY(id)<br>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> teacher(id, name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;张老师&#x27;</span>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student(<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>tid <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (id),<br>KEY fktid (tid),<br><span class="hljs-keyword">CONSTRAINT</span> fktid <span class="hljs-keyword">FOREIGN</span> KEY (tid) <span class="hljs-keyword">REFERENCES</span> teacher (id)<br>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student (id,name,tid) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student (id,name,tid) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;小红&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student (id,name,tid) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;小张&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student (id,name,tid) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;小李&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student (id,name,tid) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;小王&#x27;</span>,<span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure><h2 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h2><ul><li>1.导入lombok</li><li>2.新建实体类Teacher，Student</li><li>3.建立Mapper接口</li><li>4.建立Mapper.xml文件</li><li>5.在核心配置文件中绑定注册我们的Mapper接口或文件  【方式很多，随心选】</li><li>6.测试查询是否能够成功</li></ul><h2 id="按照查询嵌套处理"><a href="#按照查询嵌套处理" class="headerlink" title="按照查询嵌套处理"></a>按照查询嵌套处理</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">思路：</span><br><span class="hljs-comment">1.查询所有的学生信息</span><br><span class="hljs-comment">2.根据查询出来的学生的tid，寻找对应的老师子查询</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudent&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span>&gt;</span><br>    select * from mybatis.student;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.acacac.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.acacac.pojo.Teacher&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getTeacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.acacac.pojo.Teacher&quot;</span>&gt;</span><br>    select * from mybatis.teacher where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="按照结果嵌套处理"><a href="#按照结果嵌套处理" class="headerlink" title="按照结果嵌套处理"></a>按照结果嵌套处理</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--按照结果嵌套处理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudent2&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentTeacher2&quot;</span>&gt;</span><br>    select s.id sid,s.name sname,t.name tname<br>    from mybatis.student s, mybatis.teacher t<br>    where s.tid = t.id;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentTeacher2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.acacac.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.acacac.pojo.Teacher&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>回顾Mysql多对一查询方式</p><ul><li>子查询</li><li>联表查询</li></ul><h1 id="11、一对多处理"><a href="#11、一对多处理" class="headerlink" title="11、一对多处理"></a>11、一对多处理</h1><p>比如：一个老师拥有多个学生</p><p>对于老师而言，就是一对多的关系</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tid;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">//一个老师拥有多个学生</span><br>    <span class="hljs-keyword">private</span> List&lt;Student&gt; students;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="按照结果嵌套处理-1"><a href="#按照结果嵌套处理-1" class="headerlink" title="按照结果嵌套处理"></a>按照结果嵌套处理</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--按照结果嵌套查询--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span>&gt;</span><br>    SELECT s.id sid, s.name sname, t.name tname,t.id tid<br>    from mybatis.student s, mybatis.teacher t<br>    where s.tid = t.id and t.id = #&#123;tid&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.acacac.pojo.Teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--复杂的属性，我们需要单独处理 对象：association  集合：collection</span><br><span class="hljs-comment">javaType=&quot;&quot; 指定属性的类型</span><br><span class="hljs-comment">集合中的泛型信息，我们使用ofType获取</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;com.acacac.pojo.Student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="按照查询嵌套处理-1"><a href="#按照查询嵌套处理-1" class="headerlink" title="按照查询嵌套处理"></a>按照查询嵌套处理</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher2&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;TeacherStudent2&quot;</span>&gt;</span><br>    select * from mybatis.teacher where id = #&#123;tid&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TeacherStudent2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.acacac.pojo.Teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;ArrayList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getStudentByTeacherId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentByTeacherId&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.acacac.pojo.Student&quot;</span>&gt;</span><br>    select * from mybatis.student where tid = #&#123;tid&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>1.关联 - association 【多对一】</li><li>2.集合 - collection 【一对多】</li><li>3.javaType &amp; ofType<ul><li>javaType用来指定实体类中属性的类型</li><li>ofType用来指定映射到List或者集合中的pojo类型，泛型中的约束类型</li></ul></li></ul><p>注意点：</p><ul><li>保证SQL的可读性，尽量保证通俗易懂</li><li>注意一对多和多对一中，属性名和字段的问题</li><li>如果问题不好排查错误，可以使用日志，建议使用Log4j</li></ul><h1 id="12、动态SQL"><a href="#12、动态SQL" class="headerlink" title="12、动态SQL"></a>12、动态SQL</h1><p>==<strong>什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句</strong>==</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。<br><br>if<br>choose (when, otherwise)<br>trim (where, set)<br>foreach<br></code></pre></div></td></tr></table></figure><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> blog(<br>id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;博客id&#x27;</span>,<br>title <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;博客标题&#x27;</span>,<br>author <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;博客作者&#x27;</span>,<br>create_time datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>views <span class="hljs-type">int</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;浏览量&#x27;</span><br>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br></code></pre></div></td></tr></table></figure><p>创建一次基础工程</p><ul><li><p>1.导包</p></li><li><p>2.编写配置文件</p></li><li><p>3.编写实体类</p></li><li><p>```java<br>@Data<br>public class Blog {</p><div class="hljs code-wrapper"><pre><code>private int id;private String title;private String author;private Date createTime;private int views;</code></pre></div><p>}</p><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta"><br>- <span class="hljs-number">4.</span>编写实体类对应Mapper接口和Mapper.xml文件<br><br><br><br><span class="hljs-meta">## IF</span><br><br>```xml<br>&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;queryBlogIF&quot;</span> parameterType=<span class="hljs-string">&quot;map&quot;</span> resultType=<span class="hljs-string">&quot;com.acacac.pojo.Blog&quot;</span>&gt;<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> mybatis.blog <span class="hljs-keyword">where</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span><br>    &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;title != null&quot;</span>&gt;<br>        and title = <span class="hljs-meta">#&#123;title&#125;</span><br>    &lt;/<span class="hljs-keyword">if</span>&gt;<br>    &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;author != null&quot;</span>&gt;<br>        and author = <span class="hljs-meta">#&#123;author&#125;</span><br>    &lt;/<span class="hljs-keyword">if</span>&gt;<br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose (when, otherwise)"></a>choose (when, otherwise)</h2><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xaml">&lt;select id&#x3D;&quot;queryBlogChoose&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;com.acacac.pojo.Blog&quot;&gt;<br>    select * from mybatis.blog<br>    &lt;where&gt;<br>        &lt;choose&gt;<br>            &lt;when test&#x3D;&quot;title !&#x3D; null&quot;&gt;<br>                title &#x3D; #&#123;title&#125;<br>            &lt;&#x2F;when&gt;<br>            &lt;when test&#x3D;&quot;author !&#x3D; null&quot;&gt;<br>                and author &#x3D; #&#123;author&#125;<br>            &lt;&#x2F;when&gt;<br>            &lt;otherwise&gt;<br>                and views &#x3D; #&#123;views&#125;<br>            &lt;&#x2F;otherwise&gt;<br>        &lt;&#x2F;choose&gt;<br>    &lt;&#x2F;where&gt;<br>&lt;&#x2F;select&gt;<br></code></pre></div></td></tr></table></figure><h2 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim (where, set)"></a>trim (where, set)</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">select * from mybatis.blog<br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>        title = #&#123;title&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>        and author = #&#123;author&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBlog&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    update mybatis.blog<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>            title = #&#123;title&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>            author = #&#123;author&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>==<strong>所谓的动态SQL，本质还是SQL语句，知识我们可以在SQL层面，去执行一个逻辑代码</strong>==</p><h2 id="Foreach"><a href="#Foreach" class="headerlink" title="Foreach"></a>Foreach</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <br><br>  <span class="hljs-operator">&lt;</span>foreach item<span class="hljs-operator">=</span>&quot;id&quot; collection<span class="hljs-operator">=</span>&quot;ids&quot;<br>      <span class="hljs-keyword">open</span><span class="hljs-operator">=</span>&quot;(&quot; separator<span class="hljs-operator">=</span>&quot;or&quot; <span class="hljs-keyword">close</span><span class="hljs-operator">=</span>&quot;)&quot;<span class="hljs-operator">&gt;</span><br>        #&#123;id&#125;<br>  <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>foreach<span class="hljs-operator">&gt;</span><br><br>(id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">or</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">or</span> id<span class="hljs-operator">=</span><span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><p><img src="/2021/04/05/Mybatis/image-20210203120637938.png" alt="image-20210203120637938"></p><p><img src="/2021/04/05/Mybatis/image-20210203120719677.png" alt="image-20210203120719677"></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xaml">&lt;!--<br>    select * from mybatis.blog where 1&#x3D;1 and (id&#x3D;1 or id&#x3D;2 or id&#x3D;3)<br>现在传递一个万能的map，这个map中可以存在一个集合<br>--&gt;<br>&lt;select id&#x3D;&quot;queryBlogForeach&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;com.acacac.pojo.Blog&quot;&gt;<br>    select * from mybatis.blog<br>    &lt;where&gt;<br>        &lt;foreach collection&#x3D;&quot;ids&quot; item&#x3D;&quot;id&quot; open&#x3D;&quot;and (&quot; close&#x3D;&quot;)&quot; separator&#x3D;&quot;or&quot;&gt;<br>            id &#x3D; #&#123;id&#125;<br>        &lt;&#x2F;foreach&gt;<br>    &lt;&#x2F;where&gt;<br>&lt;&#x2F;select&gt;<br></code></pre></div></td></tr></table></figure><p>==动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合即可==</p><p>建议：</p><ul><li>先在Mysql中写出完整的SQL，再对应的去修改成为我们的动态SQL实现通用即可</li></ul><h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><p>有的时候，我们可能会将一些功能的部分抽取出来，方便复用</p><ul><li><p>1.使用SQL标签抽取公共的部分</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">sql</span> id<span class="hljs-operator">=</span>&quot;if-title-author&quot;<span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;title != null&quot;<span class="hljs-operator">&gt;</span><br>        title = #&#123;title&#125;<br>    <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;author != null&quot;<span class="hljs-operator">&gt;</span><br>        and author = #&#123;author&#125;<br>    <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">sql</span><span class="hljs-operator">&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>2.在需要使用的地方使用include标签引用即可</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>&quot;queryBlogIF&quot; parameterType<span class="hljs-operator">=</span>&quot;map&quot; resultType<span class="hljs-operator">=</span>&quot;com.acacac.pojo.Blog&quot;<span class="hljs-operator">&gt;</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mybatis.blog<br>    <span class="hljs-operator">&lt;</span><span class="hljs-keyword">where</span><span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;</span>include refid<span class="hljs-operator">=</span>&quot;if-title-author&quot;<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>include<span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">where</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><p>注意事项：</p><ul><li>最好基于单表来定义SQL片段</li><li>不要存在where标签</li></ul><h1 id="13、缓存（了解）"><a href="#13、缓存（了解）" class="headerlink" title="13、缓存（了解）"></a>13、缓存（了解）</h1><h2 id="13-1、简介"><a href="#13-1、简介" class="headerlink" title="13.1、简介"></a>13.1、简介</h2><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">查询：连接数据库，耗资源<br>一次查询的结果，给他暂存在一个可以直接取到的地方！ <span class="hljs-comment">--&gt; 内存：缓存</span><br><br>我们再次查询相同数据的时候，直接走缓存，就不用走数据库了<br></code></pre></div></td></tr></table></figure><p>1.什么是缓存【Cache】？</p><div class="hljs code-wrapper"><pre><code>- 存在内存中的临时数据- 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</code></pre></div><p>2.为什么使用缓存?</p><ul><li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li></ul><p>3.什么样的数据能使用缓存?</p><ul><li>经常查询并且不经常改变的数据。【可以使用缓存】</li></ul><h2 id="13-2、Mybatis缓存"><a href="#13-2、Mybatis缓存" class="headerlink" title="13.2、Mybatis缓存"></a>13.2、Mybatis缓存</h2><ul><li>MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率</li><li>MyBatis系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong><ul><li>默认情况下，只有一级缓存开启。(SqlSession级别的缓存，也称为本地缓存)</li><li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存</li><li>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</li></ul></li></ul><h2 id="13-3、一级缓存"><a href="#13-3、一级缓存" class="headerlink" title="13.3、一级缓存"></a>13.3、一级缓存</h2><ul><li>一级缓存也叫本地缓存：SqlSession<ul><li>与数据库同一次绘画期间查询到的数据会放在本地缓存中</li><li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库</li></ul></li></ul><p>测试步骤：</p><ul><li>1.开启日志</li><li>2.测试在一个Session中查询两次相同记录</li><li>3.查看日志输出</li></ul><p><img src="/2021/04/05/Mybatis/image-20210203155702652.png" alt="image-20210203155702652"></p><p>缓存失效的情况：</p><ul><li><p>1.查询不同的东西</p></li><li><p>2.增删改操作，可能会改变原来的数据，所以必定会刷新缓存</p><p><img src="/2021/04/05/Mybatis/image-20210203160134963.png" alt="image-20210203160134963"></p></li><li><p>3.查询不同的Mapper.xml</p></li><li><p>4.手动清理缓存</p><p><img src="/2021/04/05/Mybatis/image-20210203160336527.png" alt="image-20210203160336527"></p></li></ul><p>小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段</p><p>一级缓存就是一个Map</p><h2 id="13-4、二级缓存"><a href="#13-4、二级缓存" class="headerlink" title="13.4、二级缓存"></a>13.4、二级缓存</h2><ul><li>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</li><li>基于namespace级别的缓存，一个名称空间，对应一个二级缓存</li><li>工作机制<ul><li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中</li><li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存在中的数据被保存到二级缓存中</li><li>新的会话查询信息，就可以从二级缓存中获取内容</li><li>不同的mapper查出的数据会放在自己对应的缓存（map）中</li></ul></li></ul><p>步骤：</p><ul><li><p>1.开启全局缓存</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--显式的开启全局缓存--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>2.在要使用二级缓存的Mapper中开启</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在当前Mapper.xml中使用二级缓存--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><p>也可以自定义参数</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在当前Mapper.xml中使用二级缓存--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span> <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span> <span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>3.测试</p><ul><li><p>1.问题：我们需要将实体类序列化，否则就会报错</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Caused by: java.io.NotSerializableException: com.acacac.pojo.User<br></code></pre></div></td></tr></table></figure></li></ul></li></ul><p>小结：</p><ul><li>只要开启了二级缓存，在同一个Mapper下就有效</li><li>所有的数据都会先放在一级缓存中</li><li>只有当前会话提交，或者关闭的时候，才会提交到二级缓存中</li></ul><h2 id="13-5、缓存原理"><a href="#13-5、缓存原理" class="headerlink" title="13.5、缓存原理"></a>13.5、缓存原理</h2><p><img src="/2021/04/05/Mybatis/image-20210203162940760.png" alt="image-20210203162940760"></p><h2 id="13-6、自定义缓存-ehcache"><a href="#13-6、自定义缓存-ehcache" class="headerlink" title="13.6、自定义缓存-ehcache"></a>13.6、自定义缓存-ehcache</h2><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存<br></code></pre></div></td></tr></table></figure><p>要在程序中使用ehcache，先要导包</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.caches<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>在mapper中指定使用我们的ehcache实现</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><p>ehcache.xml</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">&quot;http://ehcache.org/ehcache.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 磁盘缓存位置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;java.io.tmpdir/ehcache&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 默认缓存 --&gt;</span><br>    &lt;defaultCache<br>            maxEntriesLocalHeap=&quot;10000&quot;<br>            eternal=&quot;false&quot;<br>            timeToIdleSeconds=&quot;120&quot;<br>            timeToLiveSeconds=&quot;120&quot;<br>            maxEntriesLocalDisk=&quot;10000000&quot;<br>            diskExpiryThreadIntervalSeconds=&quot;120&quot;<br>            memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">persistence</span> <span class="hljs-attr">strategy</span>=<span class="hljs-string">&quot;localTempSwap&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">defaultCache</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- helloworld缓存 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;HelloWorldCache&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">&quot;5&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">&quot;5&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">&quot;LRU&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>Redis数据库做缓存    K-V </p><p><strong>参考：<a href="https://www.bilibili.com/video/BV1S54y1R7SB">狂神说</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Java后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
