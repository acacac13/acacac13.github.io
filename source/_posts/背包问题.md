---
title: 背包问题
date: 2021-10-11 19:53:51
index_img: https://gitee.com/acacac13/images/raw/master/20211011195451.jpg
banner_img: https://gitee.com/acacac13/images/raw/master/20211011195451.jpg
tags:
  - 动态规划
  - 背包
categories: 数据结构与算法
---

# 什么是背包问题

> 有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

以上就是一个经典的01背包问题。

![背包问题](https://gitee.com/acacac13/images/raw/master/20211011102602.png)

![各类背包问题](https://gitee.com/acacac13/images/raw/master/20211011104935.png)

# 二维dp数组01背包

假设背包最大重量为4，物品为：

|       | 重量 | 价值 |
| :---: | :--: | :--: |
| 物品0 |  1   |  15  |
| 物品1 |  3   |  20  |
| 物品2 |  4   |  30  |

问背包能背的物品最大价值是多少？

1. dp[i, j]表示从下表i为0-i的物品中任意取，放进容量为j的背包，价值总和最大是多少

2. `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])` 

3. `dp[i][0] = 0`, `dp[0][j] = 15`

4. 确定遍历顺序，先遍历物品再遍历背包重量（均可，但先遍历物品更好理解）

   ```java
   // weight数组的大小 就是物品个数
   for(int i = 1; i < weight.size(); i++) { // 遍历物品
       for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
           if (j < weight[i]) dp[i][j] = dp[i - 1][j]; 
           else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
   
       }
   }
   ```

5. 推导一遍dp数组

   |       |  0   |  1   |  2   |  3   |  4   |
   | :---: | :--: | :--: | :--: | :--: | :--: |
   | 物品0 |  0   |  15  |  15  |  15  |  15  |
   | 物品1 |  0   |  15  |  15  |  20  |  35  |
   | 物品2 |  0   |  15  |  15  |  20  |  35  |

**难点：初始化和遍历顺序**

# 一维dp数组（滚动数组）

原递推公式为：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i] + value[i]])`，`dp[i][j]`的值只与上一层的值有关，所以可以只用一个一维数组

1. dp[j] 表示容量为j的背包，所背的物品价值可以最大为dp[j]

2. `dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`

3. 初始为0

4. 遍历顺序

   ```java
   for(int i = 0; i < weight.size(); i++) { // 遍历物品
       for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
           dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
       }
   }
   ```

   [注意]：二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。**倒叙遍历是为了保证物品i只被放入一次！**。但如果一旦正序遍历了，那么物品0就会被重复加入多次！

5. 推导一遍

   物品0：

   |  0   |  15  |  15  |  15  |  15  |
   | :--: | :--: | :--: | :--: | :--: |

   物品1：

   |  0   |  15  |  15  |  20  |  35  |
   | :--: | :--: | :--: | :--: | :--: |

   物品2：

   |  0   |  15  |  15  |  20  |  35  |
   | :--: | :--: | :--: | :--: | :--: |

   

# 应用

1. [leetcode-416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

# 参考

1. [代码随想录](https://programmercarl.com/)
